Common subdirectories: /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/.svn and /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/.svn
Only in /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC: AGE
Common subdirectories: /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/C14b and /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/C14b
Common subdirectories: /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/CFC and /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/CFC
Only in /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC: CMOC
Only in /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC: CanOE
Only in /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC: CanOE.tar.gz
Common subdirectories: /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/MY_TRC and /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/MY_TRC
Only in /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC: OUTPUT
Common subdirectories: /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/PISCES and /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/PISCES
Common subdirectories: /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/TRP and /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/TRP
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/oce_trc.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/oce_trc.F90
MODULE oce_trc							MODULE oce_trc
   !!========================================================	   !!========================================================
   !!                      ***  MODULE  oce_trc  ***		   !!                      ***  MODULE  oce_trc  ***
   !! TOP :   variables shared between ocean and passive trac	   !! TOP :   variables shared between ocean and passive trac
   !!========================================================	   !!========================================================
   !! History :   1.0  !  2004-03  (C. Ethe)  original code	   !! History :   1.0  !  2004-03  (C. Ethe)  original code
   !!             2.0  !  2007-12 (C. Ethe, G. Madec)  rewrit	   !!             2.0  !  2007-12 (C. Ethe, G. Madec)  rewrit
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#if defined key_top						#if defined key_top
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   'key_top'                                            	   !!   'key_top'                                            
   !!--------------------------------------------------------	   !!--------------------------------------------------------

   !* Domain size *						   !* Domain size *
   USE par_oce , ONLY :   jpi      =>   jpi        !: first  	   USE par_oce , ONLY :   jpi      =>   jpi        !: first  
   USE par_oce , ONLY :   jpj      =>   jpj        !: second 	   USE par_oce , ONLY :   jpj      =>   jpj        !: second 
   USE par_oce , ONLY :   jpk      =>   jpk        !: number 	   USE par_oce , ONLY :   jpk      =>   jpk        !: number 
   USE par_oce , ONLY :   jpim1    =>   jpim1      !: jpi - 1	   USE par_oce , ONLY :   jpim1    =>   jpim1      !: jpi - 1
   USE par_oce , ONLY :   jpjm1    =>   jpjm1      !: jpj - 1	   USE par_oce , ONLY :   jpjm1    =>   jpjm1      !: jpj - 1
   USE par_oce , ONLY :   jpkm1    =>   jpkm1      !: jpk - 1	   USE par_oce , ONLY :   jpkm1    =>   jpkm1      !: jpk - 1
   USE par_oce , ONLY :   jpij     =>   jpij       !: jpi x j	   USE par_oce , ONLY :   jpij     =>   jpij       !: jpi x j
   USE par_oce , ONLY :   lk_esopa =>   lk_esopa   !: flag to	   USE par_oce , ONLY :   lk_esopa =>   lk_esopa   !: flag to
   USE par_oce , ONLY :   jp_tem   =>   jp_tem     !: indice 	   USE par_oce , ONLY :   jp_tem   =>   jp_tem     !: indice 
   USE par_oce , ONLY :   jp_sal   =>   jp_sal     !: indice 	   USE par_oce , ONLY :   jp_sal   =>   jp_sal     !: indice 

   !* IO manager *						   !* IO manager *
   USE in_out_manager    					   USE in_out_manager    
 								 
   !* Memory Allocation *					   !* Memory Allocation *
   USE wrk_nemo      						   USE wrk_nemo      
 								 
   !* Timing *							   !* Timing *
   USE timing    						   USE timing    
 								 
   !* MPP library                         			   !* MPP library                         
   USE lib_mpp 							   USE lib_mpp 

   !* Fortran utilities                         		   !* Fortran utilities                         
   USE lib_fortran						   USE lib_fortran

   !* Lateral boundary conditions                         	   !* Lateral boundary conditions                         
   USE lbclnk							   USE lbclnk

   !* physical constants *					   !* physical constants *
   USE phycst            					   USE phycst            

   !* 1D configuration						   !* 1D configuration
   USE c1d                                         		   USE c1d                                         

   !* model domain *						   !* model domain *
   USE dom_oce 							   USE dom_oce 

   USE domvvl, ONLY : un_td, vn_td          !: thickness diff	   USE domvvl, ONLY : un_td, vn_td          !: thickness diff
   USE domvvl, ONLY : ln_vvl_ztilde         !: ztilde vertica	   USE domvvl, ONLY : ln_vvl_ztilde         !: ztilde vertica
   USE domvvl, ONLY : ln_vvl_layer          !: level  vertica	   USE domvvl, ONLY : ln_vvl_layer          !: level  vertica

   !* ocean fields: here now and after fields *			   !* ocean fields: here now and after fields *
   USE oce , ONLY :   ua      =>    ua      !: i-horizontal v	   USE oce , ONLY :   ua      =>    ua      !: i-horizontal v
   USE oce , ONLY :   va      =>    va      !: j-horizontal v	   USE oce , ONLY :   va      =>    va      !: j-horizontal v
   USE oce , ONLY :   un      =>    un      !: i-horizontal v	   USE oce , ONLY :   un      =>    un      !: i-horizontal v
   USE oce , ONLY :   vn      =>    vn      !: j-horizontal v	   USE oce , ONLY :   vn      =>    vn      !: j-horizontal v
   USE oce , ONLY :   wn      =>    wn      !: vertical veloc	   USE oce , ONLY :   wn      =>    wn      !: vertical veloc
   USE oce , ONLY :   tsn     =>    tsn     !: 4D array conta	   USE oce , ONLY :   tsn     =>    tsn     !: 4D array conta
   USE oce , ONLY :   tsb     =>    tsb     !: 4D array conta	   USE oce , ONLY :   tsb     =>    tsb     !: 4D array conta
   USE oce , ONLY :   tsa     =>    tsa     !: 4D array conta	   USE oce , ONLY :   tsa     =>    tsa     !: 4D array conta
   USE oce , ONLY :   rhop    =>    rhop    !: potential volu	   USE oce , ONLY :   rhop    =>    rhop    !: potential volu
   USE oce , ONLY :   rhd     =>    rhd     !: in situ densit	   USE oce , ONLY :   rhd     =>    rhd     !: in situ densit
#if defined key_offline						#if defined key_offline
   USE oce , ONLY :   rab_n   =>    rab_n   !: local thermal/	   USE oce , ONLY :   rab_n   =>    rab_n   !: local thermal/
#endif								#endif
   USE oce , ONLY :   hdivn   =>    hdivn   !: horizontal div	   USE oce , ONLY :   hdivn   =>    hdivn   !: horizontal div
   USE oce , ONLY :   rotn    =>    rotn    !: relative vorti	   USE oce , ONLY :   rotn    =>    rotn    !: relative vorti
   USE oce , ONLY :   hdivb   =>    hdivb   !: horizontal div	   USE oce , ONLY :   hdivb   =>    hdivb   !: horizontal div
   USE oce , ONLY :   rotb    =>    rotb    !: relative vorti	   USE oce , ONLY :   rotb    =>    rotb    !: relative vorti
   USE oce , ONLY :   sshn    =>    sshn    !: sea surface he	   USE oce , ONLY :   sshn    =>    sshn    !: sea surface he
   USE oce , ONLY :   sshb    =>    sshb    !: sea surface he	   USE oce , ONLY :   sshb    =>    sshb    !: sea surface he
   USE oce , ONLY :   ssha    =>    ssha    !: sea surface he	   USE oce , ONLY :   ssha    =>    ssha    !: sea surface he
   USE oce , ONLY :   l_traldf_rot => l_traldf_rot  !: rotate	   USE oce , ONLY :   l_traldf_rot => l_traldf_rot  !: rotate

   !* surface fluxes *						   !* surface fluxes *
   USE sbc_oce , ONLY :   utau       =>    utau       !: i-su	   USE sbc_oce , ONLY :   utau       =>    utau       !: i-su
   USE sbc_oce , ONLY :   vtau       =>    vtau       !: j-su	   USE sbc_oce , ONLY :   vtau       =>    vtau       !: j-su
   USE sbc_oce , ONLY :   wndm       =>    wndm       !: 10m 	   USE sbc_oce , ONLY :   wndm       =>    wndm       !: 10m 
   USE sbc_oce , ONLY :   qsr        =>    qsr        !: pene	   USE sbc_oce , ONLY :   qsr        =>    qsr        !: pene
   USE sbc_oce , ONLY :   emp        =>    emp        !: fres	   USE sbc_oce , ONLY :   emp        =>    emp        !: fres
   USE sbc_oce , ONLY :   emp_b      =>    emp_b      !: fres	   USE sbc_oce , ONLY :   emp_b      =>    emp_b      !: fres
   USE sbc_oce , ONLY :   fmmflx     =>    fmmflx     !: fres	   USE sbc_oce , ONLY :   fmmflx     =>    fmmflx     !: fres
   USE sbc_oce , ONLY :   rnf        =>    rnf        !: rive	   USE sbc_oce , ONLY :   rnf        =>    rnf        !: rive
   USE sbc_oce , ONLY :   ln_dm2dc   =>    ln_dm2dc   !: Diur	   USE sbc_oce , ONLY :   ln_dm2dc   =>    ln_dm2dc   !: Diur
   USE sbc_oce , ONLY :   ncpl_qsr_freq   =>   ncpl_qsr_freq 	   USE sbc_oce , ONLY :   ncpl_qsr_freq   =>   ncpl_qsr_freq 
   USE sbc_oce , ONLY :   ln_rnf     =>    ln_rnf     !: runo	   USE sbc_oce , ONLY :   ln_rnf     =>    ln_rnf     !: runo
   USE sbc_oce , ONLY :   fr_i       =>    fr_i       !: ice 	   USE sbc_oce , ONLY :   fr_i       =>    fr_i       !: ice 
   USE sbc_oce , ONLY :   nn_ice_embd => nn_ice_embd  !: flag	   USE sbc_oce , ONLY :   nn_ice_embd => nn_ice_embd  !: flag
   USE traqsr  , ONLY :   rn_abs     =>    rn_abs     !: frac	   USE traqsr  , ONLY :   rn_abs     =>    rn_abs     !: frac
   USE traqsr  , ONLY :   rn_si0     =>    rn_si0     !: very	   USE traqsr  , ONLY :   rn_si0     =>    rn_si0     !: very
   USE traqsr  , ONLY :   ln_qsr_bio =>    ln_qsr_bio !: flag	   USE traqsr  , ONLY :   ln_qsr_bio =>    ln_qsr_bio !: flag
   USE sbcrnf  , ONLY :   rnfmsk     =>    rnfmsk     !: mixe	   USE sbcrnf  , ONLY :   rnfmsk     =>    rnfmsk     !: mixe
   USE sbcrnf  , ONLY :   rnfmsk_z   =>    rnfmsk_z   !: mixe	   USE sbcrnf  , ONLY :   rnfmsk_z   =>    rnfmsk_z   !: mixe
   USE sbcrnf  , ONLY :   h_rnf      =>    h_rnf      !: rive	   USE sbcrnf  , ONLY :   h_rnf      =>    h_rnf      !: rive
   USE sbcrnf  , ONLY :   nk_rnf     =>    nk_rnf     !: dept	   USE sbcrnf  , ONLY :   nk_rnf     =>    nk_rnf     !: dept

   USE trc_oce							   USE trc_oce

   !* lateral diffusivity (tracers) *				   !* lateral diffusivity (tracers) *
   USE ldftra_oce , ONLY :  rldf     =>   rldf        !: mult	   USE ldftra_oce , ONLY :  rldf     =>   rldf        !: mult
   USE ldftra_oce , ONLY :  rn_aht_0 =>   rn_aht_0    !: hori	   USE ldftra_oce , ONLY :  rn_aht_0 =>   rn_aht_0    !: hori
   USE ldftra_oce , ONLY :  aht0     =>   aht0        !: hori	   USE ldftra_oce , ONLY :  aht0     =>   aht0        !: hori
   USE ldftra_oce , ONLY :  ahtb0    =>   ahtb0       !: back	   USE ldftra_oce , ONLY :  ahtb0    =>   ahtb0       !: back
   USE ldftra_oce , ONLY :  ahtu     =>   ahtu        !: late	   USE ldftra_oce , ONLY :  ahtu     =>   ahtu        !: late
   USE ldftra_oce , ONLY :  ahtv     =>   ahtv        !: late	   USE ldftra_oce , ONLY :  ahtv     =>   ahtv        !: late
   USE ldftra_oce , ONLY :  ahtw     =>   ahtw        !: late	   USE ldftra_oce , ONLY :  ahtw     =>   ahtw        !: late
   USE ldftra_oce , ONLY :  ahtt     =>   ahtt        !: late	   USE ldftra_oce , ONLY :  ahtt     =>   ahtt        !: late
   USE ldftra_oce , ONLY :  aeiv0    =>   aeiv0       !: eddy	   USE ldftra_oce , ONLY :  aeiv0    =>   aeiv0       !: eddy
   USE ldftra_oce , ONLY :  aeiu     =>   aeiu        !: eddy	   USE ldftra_oce , ONLY :  aeiu     =>   aeiu        !: eddy
   USE ldftra_oce , ONLY :  aeiv     =>   aeiv        !: eddy	   USE ldftra_oce , ONLY :  aeiv     =>   aeiv        !: eddy
   USE ldftra_oce , ONLY :  aeiw     =>   aeiw        !: eddy	   USE ldftra_oce , ONLY :  aeiw     =>   aeiw        !: eddy
   USE ldftra_oce , ONLY :  lk_traldf_eiv  =>  lk_traldf_eiv 	   USE ldftra_oce , ONLY :  lk_traldf_eiv  =>  lk_traldf_eiv 
   USE ldftra_oce , ONLY :  r_fact_lap     =>  r_fact_lap     <

   !* vertical diffusion *					   !* vertical diffusion *
   USE zdf_oce , ONLY :   avt        =>   avt         !: vert	   USE zdf_oce , ONLY :   avt        =>   avt         !: vert
# if defined key_zdfddm						# if defined key_zdfddm
   USE zdfddm  , ONLY :   avs        =>   avs         !: sali	   USE zdfddm  , ONLY :   avs        =>   avs         !: sali
# endif								# endif

   !* mixing & mixed layer depth *				   !* mixing & mixed layer depth *
   USE zdfmxl , ONLY :   nmln        =>   nmln        !: numb	   USE zdfmxl , ONLY :   nmln        =>   nmln        !: numb
   USE zdfmxl , ONLY :   hmld        =>   hmld        !: mixi	   USE zdfmxl , ONLY :   hmld        =>   hmld        !: mixi
   USE zdfmxl , ONLY :   hmlp        =>   hmlp        !: mixe	   USE zdfmxl , ONLY :   hmlp        =>   hmlp        !: mixe
   USE zdfmxl , ONLY :   hmlpt       =>   hmlpt       !: mixe	   USE zdfmxl , ONLY :   hmlpt       =>   hmlpt       !: mixe

   !* direction of lateral diffusion *				   !* direction of lateral diffusion *
   USE ldfslp , ONLY :   lk_ldfslp  =>  lk_ldfslp     !: slop	   USE ldfslp , ONLY :   lk_ldfslp  =>  lk_ldfslp     !: slop
# if   defined key_ldfslp					# if   defined key_ldfslp
   USE ldfslp , ONLY :   uslp       =>   uslp         !: i-di	   USE ldfslp , ONLY :   uslp       =>   uslp         !: i-di
   USE ldfslp , ONLY :   vslp       =>   vslp         !: j-di	   USE ldfslp , ONLY :   vslp       =>   vslp         !: j-di
   USE ldfslp , ONLY :   wslpi      =>   wslpi        !: i-di	   USE ldfslp , ONLY :   wslpi      =>   wslpi        !: i-di
   USE ldfslp , ONLY :   wslpj      =>   wslpj        !: j-di	   USE ldfslp , ONLY :   wslpj      =>   wslpj        !: j-di
# endif								# endif

   USE diaar5 , ONLY :   lk_diaar5  =>   lk_diaar5		   USE diaar5 , ONLY :   lk_diaar5  =>   lk_diaar5
#else								#else
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!  Empty module :                                     No 	   !!  Empty module :                                     No 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#endif								#endif

   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/TOP 3.3 , NEMO Consortium (2010)			   !! NEMO/TOP 3.3 , NEMO Consortium (2010)
   !! $Id: oce_trc.F90 6312 2016-02-15 11:43:52Z cetlod $     |	   !! $Id: oce_trc.F90 5385 2015-06-09 13:50:42Z cetlod $
   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C	   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C
   !!========================================================	   !!========================================================
END MODULE oce_trc						END MODULE oce_trc
Only in /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC: out
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/par_trc.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/par_trc.F90
MODULE par_trc							MODULE par_trc
   !!========================================================	   !!========================================================
   !!                        ***  par_trc  ***			   !!                        ***  par_trc  ***
   !! TOP :   set the passive tracers parameters		   !! TOP :   set the passive tracers parameters
   !!========================================================	   !!========================================================
   !! History :    -   !  1996-01  (M. Levy)  original code	   !! History :    -   !  1996-01  (M. Levy)  original code
   !!              -   !  2000-04  (O. Aumont, M.A. Foujols) 	   !!              -   !  2000-04  (O. Aumont, M.A. Foujols) 
   !!             1.0  !  2004-03  (C. Ethe) Free form and mo	   !!             1.0  !  2004-03  (C. Ethe) Free form and mo
   !!             2.0  !  2007-12  (C. Ethe, G. Madec)  revis	   !!             2.0  !  2007-12  (C. Ethe, G. Madec)  revis
							      >	   !!                  !  2017-09  (A.Holdsworth)  added CMOC
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   USE par_kind          ! kind parameters			   USE par_kind          ! kind parameters
   !								   !
   USE par_pisces    ! PISCES  model				   USE par_pisces    ! PISCES  model
							      >	   USE par_canoe    ! PISCES  model
							      >	   USE par_cmoc    ! CMOC  model
   USE par_c14b      ! C14 bomb tracer				   USE par_c14b      ! C14 bomb tracer
   USE par_cfc       ! CFC 11 and 12 tracers			   USE par_cfc       ! CFC 11 and 12 tracers
   USE par_age       ! AGE  tracer			      <
   USE par_my_trc    ! user defined passive tracers		   USE par_my_trc    ! user defined passive tracers

   IMPLICIT NONE						   IMPLICIT NONE

   ! Passive tracers : Maximum number of tracers. Needed to d	   ! Passive tracers : Maximum number of tracers. Needed to d
   ! --------------- 						   ! --------------- 
   INTEGER, PUBLIC,  PARAMETER ::   jpmaxtrc = 100		   INTEGER, PUBLIC,  PARAMETER ::   jpmaxtrc = 100

   ! Passive tracers : Total size				   ! Passive tracers : Total size
   ! ---------------               ! total number of passive 	   ! ---------------               ! total number of passive 
   INTEGER, PUBLIC,  PARAMETER ::   jptra    =  jp_pisces     |	   INTEGER, PUBLIC,  PARAMETER ::   jptra    =  jp_canoe + jp
   INTEGER, PUBLIC,  PARAMETER ::   jpdia2d  =  jp_pisces_2d  |	   INTEGER, PUBLIC,  PARAMETER ::   jpdia2d  =  jp_canoe_2d +
   INTEGER, PUBLIC,  PARAMETER ::   jpdia3d  =  jp_pisces_3d  |	   INTEGER, PUBLIC,  PARAMETER ::   jpdia3d  =  jp_canoe_3d +
   !                     ! total number of sms diagnostic arr	   !                     ! total number of sms diagnostic arr
   INTEGER, PUBLIC,  PARAMETER ::   jpdiabio =  jp_pisces_trd |	   INTEGER, PUBLIC,  PARAMETER ::   jpdiabio =  jp_canoe_trd 
   								   
   !  1D configuration ("key_c1d")				   !  1D configuration ("key_c1d")
   ! -----------------						   ! -----------------
# if defined key_c1d						# if defined key_c1d
   LOGICAL, PUBLIC, PARAMETER ::   lk_trc_c1d   = .TRUE.   !:	   LOGICAL, PUBLIC, PARAMETER ::   lk_trc_c1d   = .TRUE.   !:
# else   							# else   
   LOGICAL, PUBLIC, PARAMETER ::   lk_trc_c1d   = .FALSE.  !:	   LOGICAL, PUBLIC, PARAMETER ::   lk_trc_c1d   = .FALSE.  !:
# endif								# endif

   REAL(wp), PUBLIC  :: rtrn  = 0.5 * EPSILON( 1.e0 )    !: t	   REAL(wp), PUBLIC  :: rtrn  = 0.5 * EPSILON( 1.e0 )    !: t

   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/TOP 3.3 , NEMO Consortium (2010)			   !! NEMO/TOP 3.3 , NEMO Consortium (2010)
   !! $Id: par_trc.F90 7494 2016-12-14 09:02:43Z timgraham $  |	   !! $Id: par_trc.F90 4529 2014-03-15 11:00:04Z cetlod $ 
   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C	   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C
   !!========================================================	   !!========================================================
END MODULE par_trc						END MODULE par_trc
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/prtctl_trc.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/prtctl_trc.F90
MODULE prtctl_trc						MODULE prtctl_trc
   !!========================================================	   !!========================================================
   !!                         ***  MODULE prtctl_trc  ***	   !!                         ***  MODULE prtctl_trc  ***
   !! TOP :   print all SUM trends for each processor domain	   !! TOP :   print all SUM trends for each processor domain
   !!========================================================	   !!========================================================
   !! History :    -   !  2005-07  (C. Talandier) original co	   !! History :    -   !  2005-07  (C. Talandier) original co
   !!             1.0  !  2005-10  (C. Ethe     ) adapted to 	   !!             1.0  !  2005-10  (C. Ethe     ) adapted to 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#if defined key_top						#if defined key_top
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   'key_top'                                            	   !!   'key_top'                                            
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   prt_ctl_trc      :   control print in mpp for passive	   !!   prt_ctl_trc      :   control print in mpp for passive
   !!   prt_ctl_trc_info :   ???				   !!   prt_ctl_trc_info :   ???
   !!   prt_ctl_trc_init :   ???				   !!   prt_ctl_trc_init :   ???
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   USE par_trc          ! TOP parameters			   USE par_trc          ! TOP parameters
   USE oce_trc          ! ocean space and time domain variabl	   USE oce_trc          ! ocean space and time domain variabl
   USE prtctl           ! print control for OPA			   USE prtctl           ! print control for OPA

   IMPLICIT NONE						   IMPLICIT NONE
   PRIVATE							   PRIVATE

   INTEGER , DIMENSION(:), ALLOCATABLE ::   numid_trc        	   INTEGER , DIMENSION(:), ALLOCATABLE ::   numid_trc        
   INTEGER , DIMENSION(:), ALLOCATABLE ::   nlditl , nldjtl  	   INTEGER , DIMENSION(:), ALLOCATABLE ::   nlditl , nldjtl  
   INTEGER , DIMENSION(:), ALLOCATABLE ::   nleitl , nlejtl  	   INTEGER , DIMENSION(:), ALLOCATABLE ::   nleitl , nlejtl  
   INTEGER , DIMENSION(:), ALLOCATABLE ::   nimpptl, njmpptl 	   INTEGER , DIMENSION(:), ALLOCATABLE ::   nimpptl, njmpptl 
   INTEGER , DIMENSION(:), ALLOCATABLE ::   nlcitl , nlcjtl  	   INTEGER , DIMENSION(:), ALLOCATABLE ::   nlcitl , nlcjtl  
   INTEGER , DIMENSION(:), ALLOCATABLE ::   ibonitl, ibonjtl	   INTEGER , DIMENSION(:), ALLOCATABLE ::   ibonitl, ibonjtl

   REAL(wp), DIMENSION(:,:), ALLOCATABLE ::   tra_ctl        	   REAL(wp), DIMENSION(:,:), ALLOCATABLE ::   tra_ctl        

   PUBLIC prt_ctl_trc         ! called by all subroutines	   PUBLIC prt_ctl_trc         ! called by all subroutines
   PUBLIC prt_ctl_trc_info    !					   PUBLIC prt_ctl_trc_info    !
   PUBLIC prt_ctl_trc_init    ! called by opa.F90		   PUBLIC prt_ctl_trc_init    ! called by opa.F90

CONTAINS							CONTAINS

   SUBROUTINE prt_ctl_trc( tab4d, mask, clinfo, ovlap, kdim, 	   SUBROUTINE prt_ctl_trc( tab4d, mask, clinfo, ovlap, kdim, 
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE prt_ctl  ***		      !!                     ***  ROUTINE prt_ctl  ***
      !!							      !!
      !! ** Purpose : - print sum control 3D arrays over the 	      !! ** Purpose : - print sum control 3D arrays over the 
      !!                in mono and mpp case. This way can be	      !!                in mono and mpp case. This way can be
      !!                debugging a new parametrization in mo	      !!                debugging a new parametrization in mo
      !!							      !!
      !! ** Method  : 2 possibilities exist when setting the 	      !! ** Method  : 2 possibilities exist when setting the 
      !!                .true. in the ocean namelist:		      !!                .true. in the ocean namelist:
      !!              - to debug a MPI run .vs. a mono-proces	      !!              - to debug a MPI run .vs. a mono-proces
      !!                the control print will be done over e	      !!                the control print will be done over e
      !!                The nictl[se] and njctl[se] parameter	      !!                The nictl[se] and njctl[se] parameter
      !!                be set to zero and [ij]splt to the co	      !!                be set to zero and [ij]splt to the co
      !!                domain in MPI along respectively i-, 	      !!                domain in MPI along respectively i-, 
      !!              - to debug a mono-processor run over th	      !!              - to debug a mono-processor run over th
      !!                in the first case the nictl[se] and n	      !!                in the first case the nictl[se] and n
      !!                to zero else to the indices of the ar	      !!                to zero else to the indices of the ar
      !!                isplt and jsplt must be set to 1.	      !!                isplt and jsplt must be set to 1.
      !!              - All arguments of the above calling se	      !!              - All arguments of the above calling se
      !!                name must be explicitly typed if used	      !!                name must be explicitly typed if used
      !!                array tmask(:,:,:) must be passed thr	      !!                array tmask(:,:,:) must be passed thr
      !!                it must looks like: CALL prt_ctl( mas	      !!                it must looks like: CALL prt_ctl( mas
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      REAL(wp)         , DIMENSION(:,:,:,:), INTENT(in), OPTI	      REAL(wp)         , DIMENSION(:,:,:,:), INTENT(in), OPTI
      REAL(wp)         , DIMENSION(:,:,:)  , INTENT(in), OPTI	      REAL(wp)         , DIMENSION(:,:,:)  , INTENT(in), OPTI
      CHARACTER (len=*), DIMENSION(:)      , INTENT(in), OPTI	      CHARACTER (len=*), DIMENSION(:)      , INTENT(in), OPTI
      CHARACTER (len=*)                    , INTENT(in), OPTI	      CHARACTER (len=*)                    , INTENT(in), OPTI
      INTEGER                              , INTENT(in), OPTI	      INTEGER                              , INTENT(in), OPTI
      INTEGER                              , INTENT(in), OPTI	      INTEGER                              , INTENT(in), OPTI
      !!							      !!
      INTEGER  ::   overlap, jn, js, sind, eind, kdir, j_id	      INTEGER  ::   overlap, jn, js, sind, eind, kdir, j_id
      REAL(wp) ::   zsum, zvctl					      REAL(wp) ::   zsum, zvctl
      CHARACTER (len=20), DIMENSION(jptra) ::   cl		      CHARACTER (len=20), DIMENSION(jptra) ::   cl
      CHARACTER (len=10) ::   cl2				      CHARACTER (len=10) ::   cl2
      REAL(wp), POINTER, DIMENSION(:,:,:)  :: zmask, ztab3d 	      REAL(wp), POINTER, DIMENSION(:,:,:)  :: zmask, ztab3d 
      !!-----------------------------------------------------	      !!-----------------------------------------------------

      CALL wrk_alloc( jpi, jpj, jpk, zmask, ztab3d )		      CALL wrk_alloc( jpi, jpj, jpk, zmask, ztab3d )
      !                                      ! Arrays, scalar	      !                                      ! Arrays, scalar
      overlap       = 0						      overlap       = 0
      kdir          = jpkm1					      kdir          = jpkm1
      zsum          = 0.e0					      zsum          = 0.e0
      zvctl         = 0.e0					      zvctl         = 0.e0
      cl(:)         = ''					      cl(:)         = ''
      cl2           = ''					      cl2           = ''
      ztab3d(:,:,:) = 0.e0					      ztab3d(:,:,:) = 0.e0
      zmask (:,:,:) = 1.e0					      zmask (:,:,:) = 1.e0

      !                                      ! Control of opt	      !                                      ! Control of opt
      IF( PRESENT(ovlap)   )   overlap       = ovlap		      IF( PRESENT(ovlap)   )   overlap       = ovlap
      IF( PRESENT(kdim)    )   kdir          = kdim		      IF( PRESENT(kdim)    )   kdir          = kdim
      IF( PRESENT(clinfo ) )   cl(:)         = clinfo(:)	      IF( PRESENT(clinfo ) )   cl(:)         = clinfo(:)
      IF( PRESENT(clinfo2) )   cl2           = clinfo2		      IF( PRESENT(clinfo2) )   cl2           = clinfo2
      IF( PRESENT(mask)    )   zmask (:,:,:) = mask(:,:,:)	      IF( PRESENT(mask)    )   zmask (:,:,:) = mask(:,:,:)

      IF( lk_mpp )   THEN      ! processor number		      IF( lk_mpp )   THEN      ! processor number
         sind = narea						         sind = narea
         eind = narea						         eind = narea
      ELSE                     ! processors total number	      ELSE                     ! processors total number
         sind = 1						         sind = 1
         eind = ijsplt						         eind = ijsplt
      ENDIF							      ENDIF

      ! Loop over each sub-domain, i.e. the total number of p	      ! Loop over each sub-domain, i.e. the total number of p
      DO js = sind, eind					      DO js = sind, eind
         !							         !
         ! Set logical unit					         ! Set logical unit
         j_id = numid_trc( js - narea + 1 )			         j_id = numid_trc( js - narea + 1 )
         ! Set indices for the SUM control			         ! Set indices for the SUM control
         IF( .NOT. lsp_area ) THEN				         IF( .NOT. lsp_area ) THEN
            IF (lk_mpp )   THEN					            IF (lk_mpp )   THEN
               nictls = MAX( 1, nlditl(js) - overlap )		               nictls = MAX( 1, nlditl(js) - overlap )
               nictle = nleitl(js) + overlap * MIN( 1, nlcitl	               nictle = nleitl(js) + overlap * MIN( 1, nlcitl
               njctls = MAX( 1, nldjtl(js) - overlap )		               njctls = MAX( 1, nldjtl(js) - overlap )
               njctle = nlejtl(js) + overlap * MIN( 1, nlcjtl	               njctle = nlejtl(js) + overlap * MIN( 1, nlcjtl
               ! Do not take into account the bound of the do	               ! Do not take into account the bound of the do
               IF( ibonitl(js) == -1 .OR. ibonitl(js) == 2 ) 	               IF( ibonitl(js) == -1 .OR. ibonitl(js) == 2 ) 
               IF( ibonitl(js) ==  1 .OR. ibonitl(js) == 2 ) 	               IF( ibonitl(js) ==  1 .OR. ibonitl(js) == 2 ) 
               IF( ibonjtl(js) == -1 .OR. ibonjtl(js) == 2 ) 	               IF( ibonjtl(js) == -1 .OR. ibonjtl(js) == 2 ) 
               IF( ibonjtl(js) ==  1 .OR. ibonjtl(js) == 2 ) 	               IF( ibonjtl(js) ==  1 .OR. ibonjtl(js) == 2 ) 
            ELSE						            ELSE
               nictls = MAX( 1, nimpptl(js) + nlditl(js) - 1 	               nictls = MAX( 1, nimpptl(js) + nlditl(js) - 1 
               nictle = nimpptl(js) + nleitl(js) - 1 + overla	               nictle = nimpptl(js) + nleitl(js) - 1 + overla
               njctls = MAX( 1, njmpptl(js) + nldjtl(js) - 1 	               njctls = MAX( 1, njmpptl(js) + nldjtl(js) - 1 
               njctle = njmpptl(js) + nlejtl(js) - 1 + overla	               njctle = njmpptl(js) + nlejtl(js) - 1 + overla
               ! Do not take into account the bound of the do	               ! Do not take into account the bound of the do
               IF( ibonitl(js) == -1 .OR. ibonitl(js) == 2 ) 	               IF( ibonitl(js) == -1 .OR. ibonitl(js) == 2 ) 
               IF( ibonjtl(js) == -1 .OR. ibonjtl(js) == 2 ) 	               IF( ibonjtl(js) == -1 .OR. ibonjtl(js) == 2 ) 
               IF( ibonitl(js) ==  1 .OR. ibonitl(js) == 2 ) 	               IF( ibonitl(js) ==  1 .OR. ibonitl(js) == 2 ) 
               IF( ibonjtl(js) ==  1 .OR. ibonjtl(js) == 2 ) 	               IF( ibonjtl(js) ==  1 .OR. ibonjtl(js) == 2 ) 
            ENDIF						            ENDIF
         ENDIF							         ENDIF
         !							         !
         IF( PRESENT(clinfo2) ) THEN				         IF( PRESENT(clinfo2) ) THEN
            DO jn = 1, jptra					            DO jn = 1, jptra
               zvctl  = tra_ctl(jn,js)				               zvctl  = tra_ctl(jn,js)
               ztab3d(:,:,:) = tab4d(:,:,:,jn)			               ztab3d(:,:,:) = tab4d(:,:,:,jn)
               zsum          = SUM( ztab3d(nictls:nictle,njct	               zsum          = SUM( ztab3d(nictls:nictle,njct
                  &                * zmask(nictls:nictle,njct	                  &                * zmask(nictls:nictle,njct
               WRITE(j_id,FMT="(3x,a,' : ',D23.16)") cl(jn), 	               WRITE(j_id,FMT="(3x,a,' : ',D23.16)") cl(jn), 
               tra_ctl(jn,js) = zsum				               tra_ctl(jn,js) = zsum
            END DO						            END DO
         ELSE							         ELSE
            DO jn = 1, jptra					            DO jn = 1, jptra
               ztab3d(:,:,:) = tab4d(:,:,:,jn)			               ztab3d(:,:,:) = tab4d(:,:,:,jn)
               zsum          = SUM( ztab3d(nictls:nictle,njct	               zsum          = SUM( ztab3d(nictls:nictle,njct
                  &               *  zmask(nictls:nictle,njct	                  &               *  zmask(nictls:nictle,njct
               WRITE(j_id,FMT="(3x,a,' : ',D23.16)") cl(jn), 	               WRITE(j_id,FMT="(3x,a,' : ',D23.16)") cl(jn), 
            END DO						            END DO
         ENDIF							         ENDIF
         !							         !
      END DO							      END DO
      !								      !
      CALL wrk_dealloc( jpi, jpj, jpk, zmask, ztab3d )		      CALL wrk_dealloc( jpi, jpj, jpk, zmask, ztab3d )
      !								      !
   END SUBROUTINE prt_ctl_trc					   END SUBROUTINE prt_ctl_trc


   SUBROUTINE prt_ctl_trc_info( clinfo )			   SUBROUTINE prt_ctl_trc_info( clinfo )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE prt_ctl_trc_info  *	      !!                     ***  ROUTINE prt_ctl_trc_info  *
      !!							      !!
      !! ** Purpose : - print information without any computa	      !! ** Purpose : - print information without any computa
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      CHARACTER (len=*), INTENT(in) ::   clinfo      ! inform	      CHARACTER (len=*), INTENT(in) ::   clinfo      ! inform
      !! 							      !! 
      INTEGER ::   js, sind, eind, j_id				      INTEGER ::   js, sind, eind, j_id
      !!-----------------------------------------------------	      !!-----------------------------------------------------

      IF( lk_mpp ) THEN      ! processor number			      IF( lk_mpp ) THEN      ! processor number
         sind = narea						         sind = narea
         eind = narea						         eind = narea
      ELSE                   ! total number of processors	      ELSE                   ! total number of processors
         sind = 1						         sind = 1
         eind = ijsplt						         eind = ijsplt
      ENDIF							      ENDIF

      ! Loop over each sub-domain, i.e. number of processors 	      ! Loop over each sub-domain, i.e. number of processors 
      DO js = sind, eind					      DO js = sind, eind
         j_id = numid_trc(js - narea + 1)			         j_id = numid_trc(js - narea + 1)
         WRITE(j_id,*) clinfo					         WRITE(j_id,*) clinfo
      END DO							      END DO
      !								      !
   END SUBROUTINE prt_ctl_trc_info				   END SUBROUTINE prt_ctl_trc_info


   SUBROUTINE prt_ctl_trc_init					   SUBROUTINE prt_ctl_trc_init
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE prt_ctl_trc_init  *	      !!                     ***  ROUTINE prt_ctl_trc_init  *
      !!							      !!
      !! ** Purpose :   open ASCII files & compute indices	      !! ** Purpose :   open ASCII files & compute indices
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER            ::   js, sind, eind, j_id		      INTEGER            ::   js, sind, eind, j_id
      CHARACTER (len=31) :: clfile_out				      CHARACTER (len=31) :: clfile_out
      CHARACTER (len=27) :: clb_name				      CHARACTER (len=27) :: clb_name
      CHARACTER (len=19) :: cl_run				      CHARACTER (len=19) :: cl_run
      !!-----------------------------------------------------	      !!-----------------------------------------------------

      !                             ! Allocate arrays		      !                             ! Allocate arrays
      ALLOCATE( nlditl (ijsplt) )				      ALLOCATE( nlditl (ijsplt) )
      ALLOCATE( nldjtl (ijsplt) )				      ALLOCATE( nldjtl (ijsplt) )
      ALLOCATE( nleitl (ijsplt) )				      ALLOCATE( nleitl (ijsplt) )
      ALLOCATE( nlejtl (ijsplt) )				      ALLOCATE( nlejtl (ijsplt) )
      ALLOCATE( nimpptl(ijsplt) )				      ALLOCATE( nimpptl(ijsplt) )
      ALLOCATE( njmpptl(ijsplt) )				      ALLOCATE( njmpptl(ijsplt) )
      ALLOCATE( nlcitl (ijsplt) )				      ALLOCATE( nlcitl (ijsplt) )
      ALLOCATE( nlcjtl (ijsplt) )				      ALLOCATE( nlcjtl (ijsplt) )
      ALLOCATE( tra_ctl(jptra,ijsplt) )				      ALLOCATE( tra_ctl(jptra,ijsplt) )
      ALLOCATE( ibonitl(ijsplt) )				      ALLOCATE( ibonitl(ijsplt) )
      ALLOCATE( ibonjtl(ijsplt) )				      ALLOCATE( ibonjtl(ijsplt) )

      tra_ctl(:,:) = 0.e0           ! Initialization to zero	      tra_ctl(:,:) = 0.e0           ! Initialization to zero

      IF( lk_mpp ) THEN						      IF( lk_mpp ) THEN
         sind = narea						         sind = narea
         eind = narea						         eind = narea
         clb_name = "('mpp.top.output_',I3.3)"			         clb_name = "('mpp.top.output_',I3.3)"
         cl_run = 'MULTI processor run'				         cl_run = 'MULTI processor run'
         ! use indices for each area computed by mpp_init sub	         ! use indices for each area computed by mpp_init sub
         nlditl(1:jpnij) = nldit(:) 				         nlditl(1:jpnij) = nldit(:) 
         nleitl(1:jpnij) = nleit(:) 				         nleitl(1:jpnij) = nleit(:) 
         nldjtl(1:jpnij) = nldjt(:) 				         nldjtl(1:jpnij) = nldjt(:) 
         nlejtl(1:jpnij) = nlejt(:) 				         nlejtl(1:jpnij) = nlejt(:) 
         !							         !
         nimpptl(1:jpnij) = nimppt(:)				         nimpptl(1:jpnij) = nimppt(:)
         njmpptl(1:jpnij) = njmppt(:)				         njmpptl(1:jpnij) = njmppt(:)
         !							         !
         nlcitl(1:jpnij) = nlcit(:)				         nlcitl(1:jpnij) = nlcit(:)
         nlcjtl(1:jpnij) = nlcjt(:)				         nlcjtl(1:jpnij) = nlcjt(:)
         !							         !
         ibonitl(1:jpnij) = ibonit(:)				         ibonitl(1:jpnij) = ibonit(:)
         ibonjtl(1:jpnij) = ibonjt(:)				         ibonjtl(1:jpnij) = ibonjt(:)
      ELSE							      ELSE
         sind = 1						         sind = 1
         eind = ijsplt						         eind = ijsplt
         clb_name = "('mono.top.output_',I3.3)"			         clb_name = "('mono.top.output_',I3.3)"
         cl_run   = 'MONO processor run '			         cl_run   = 'MONO processor run '
         ! compute indices for each area as done in mpp_init 	         ! compute indices for each area as done in mpp_init 
         CALL sub_dom						         CALL sub_dom
      ENDIF							      ENDIF

      ALLOCATE( numid_trc(eind-sind+1) )			      ALLOCATE( numid_trc(eind-sind+1) )

      DO js = sind, eind					      DO js = sind, eind
         WRITE(clfile_out,FMT=clb_name) js-1			         WRITE(clfile_out,FMT=clb_name) js-1
         CALL ctl_opn( numid_trc(js -narea + 1), clfile_out, 	         CALL ctl_opn( numid_trc(js -narea + 1), clfile_out, 
         j_id = numid_trc(js -narea + 1)			         j_id = numid_trc(js -narea + 1)
         WRITE(j_id,*)						         WRITE(j_id,*)
         WRITE(j_id,*) '                 L O D Y C - I P S L'	         WRITE(j_id,*) '                 L O D Y C - I P S L'
         WRITE(j_id,*) '                       N E M 0 '	         WRITE(j_id,*) '                       N E M 0 '
         WRITE(j_id,*) '            Ocean General Circulation	         WRITE(j_id,*) '            Ocean General Circulation
         WRITE(j_id,*) '               version TOP 1.0  (2005	         WRITE(j_id,*) '               version TOP 1.0  (2005
         WRITE(j_id,*)						         WRITE(j_id,*)
         WRITE(j_id,*) '                   PROC number: ', js	         WRITE(j_id,*) '                   PROC number: ', js
         WRITE(j_id,*)						         WRITE(j_id,*)
         WRITE(j_id,FMT="(19x,a20)") cl_run			         WRITE(j_id,FMT="(19x,a20)") cl_run

         ! Print the SUM control indices			         ! Print the SUM control indices
         IF( .NOT. lsp_area )   THEN				         IF( .NOT. lsp_area )   THEN
            IF ( lk_mpp )   THEN				            IF ( lk_mpp )   THEN
               nictls = nlditl(js) 				               nictls = nlditl(js) 
               nictle = nleitl(js)				               nictle = nleitl(js)
               njctls = nldjtl(js)				               njctls = nldjtl(js)
               njctle = nlejtl(js)				               njctle = nlejtl(js)
            ELSE						            ELSE
               nictls = nimpptl(js) + nlditl(js) - 1		               nictls = nimpptl(js) + nlditl(js) - 1
               nictle = nimpptl(js) + nleitl(js) - 1		               nictle = nimpptl(js) + nleitl(js) - 1
               njctls = njmpptl(js) + nldjtl(js) - 1		               njctls = njmpptl(js) + nldjtl(js) - 1
               njctle = njmpptl(js) + nlejtl(js) - 1		               njctle = njmpptl(js) + nlejtl(js) - 1
            ENDIF						            ENDIF
         ENDIF							         ENDIF
         WRITE(j_id,*) 						         WRITE(j_id,*) 
         WRITE(j_id,*) 'prt_tra_ctl :  Sum control indices'	         WRITE(j_id,*) 'prt_tra_ctl :  Sum control indices'
         WRITE(j_id,*) '~~~~~~~'				         WRITE(j_id,*) '~~~~~~~'
         WRITE(j_id,*)						         WRITE(j_id,*)
         WRITE(j_id,9000)'                                nle	         WRITE(j_id,9000)'                                nle
         WRITE(j_id,9000)'                  ------------- njc	         WRITE(j_id,9000)'                  ------------- njc
         WRITE(j_id,9001)'                  |                	         WRITE(j_id,9001)'                  |                
         WRITE(j_id,9001)'                  |                	         WRITE(j_id,9001)'                  |                
         WRITE(j_id,9001)'                  |                	         WRITE(j_id,9001)'                  |                
         WRITE(j_id,9002)'           nictls = ', nictls,  '  	         WRITE(j_id,9002)'           nictls = ', nictls,  '  
         WRITE(j_id,9002)'           nldi   = ', nlditl(js), 	         WRITE(j_id,9002)'           nldi   = ', nlditl(js), 
         WRITE(j_id,9001)'                  |                	         WRITE(j_id,9001)'                  |                
         WRITE(j_id,9001)'                  |                	         WRITE(j_id,9001)'                  |                
         WRITE(j_id,9001)'                  |                	         WRITE(j_id,9001)'                  |                
         WRITE(j_id,9004)'  njmpp  = ',njmpptl(js),'   ------	         WRITE(j_id,9004)'  njmpp  = ',njmpptl(js),'   ------
         WRITE(j_id,9003)'           nimpp  = ', nimpptl(js),	         WRITE(j_id,9003)'           nimpp  = ', nimpptl(js),
         WRITE(j_id,*)						         WRITE(j_id,*)
         WRITE(j_id,*)						         WRITE(j_id,*)

9000     FORMAT(a41,i4.4,a14)					9000     FORMAT(a41,i4.4,a14)
9001     FORMAT(a59)						9001     FORMAT(a59)
9002     FORMAT(a20,i4.4,a36,i3.3)				9002     FORMAT(a20,i4.4,a36,i3.3)
9003     FORMAT(a20,i4.4,a17,i4.4)				9003     FORMAT(a20,i4.4,a17,i4.4)
9004     FORMAT(a11,i4.4,a26,i4.4,a14)				9004     FORMAT(a11,i4.4,a26,i4.4,a14)
      END DO							      END DO
      !								      !
   END SUBROUTINE prt_ctl_trc_init				   END SUBROUTINE prt_ctl_trc_init

#else								#else
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   Dummy module :                                    NO 	   !!   Dummy module :                                    NO 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#endif								#endif
 								 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/TOP 3.3 , NEMO Consortium (2010)			   !! NEMO/TOP 3.3 , NEMO Consortium (2010)
   !! $Id: prtctl_trc.F90 4520 2014-02-28 11:44:02Z acc $ 	   !! $Id: prtctl_trc.F90 4520 2014-02-28 11:44:02Z acc $ 
   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C	   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C
   !!========================================================	   !!========================================================
END MODULE prtctl_trc						END MODULE prtctl_trc
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/top_substitute.h90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/top_substitute.h90
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!                    ***  top_substitute.h90   ***		   !!                    ***  top_substitute.h90   ***
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! ** purpose : Statement function file: to be include in 	   !! ** purpose : Statement function file: to be include in 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! History :   1.0  !  2004-03 (C. Ethe) Original code	   !! History :   1.0  !  2004-03 (C. Ethe) Original code
   !!             2.0  !  2007-12 (C. Ethe, G. Madec) new arc	   !!             2.0  !  2007-12 (C. Ethe, G. Madec) new arc
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#  include "domzgr_substitute.h90"				#  include "domzgr_substitute.h90"
#  include "ldfeiv_substitute.h90"				#  include "ldfeiv_substitute.h90"
#  include "ldftra_substitute.h90"				#  include "ldftra_substitute.h90"
#  include "vectopt_loop_substitute.h90"			#  include "vectopt_loop_substitute.h90"
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/TOP 3.3 , NEMO Consortium (2010)			   !! NEMO/TOP 3.3 , NEMO Consortium (2010)
   !! $Id: top_substitute.h90 2528 2010-12-27 17:33:53Z rblod	   !! $Id: top_substitute.h90 2528 2010-12-27 17:33:53Z rblod
   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C	   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C
   !!--------------------------------------------------------	   !!--------------------------------------------------------
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/trc.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/trc.F90
MODULE trc							MODULE trc
   !!========================================================	   !!========================================================
   !!                      ***  MODULE  trc  ***		   !!                      ***  MODULE  trc  ***
   !! Passive tracers   :  module for tracers defined		   !! Passive tracers   :  module for tracers defined
   !!========================================================	   !!========================================================
   !! History :   OPA  !  1996-01  (M. Levy)  Original code	   !! History :   OPA  !  1996-01  (M. Levy)  Original code
   !!              -   !  2000-04  (O. Aumont, M.A. Foujols) 	   !!              -   !  2000-04  (O. Aumont, M.A. Foujols) 
   !!   NEMO      1.0  !  2004-03  (C. Ethe)  Free form and m	   !!   NEMO      1.0  !  2004-03  (C. Ethe)  Free form and m
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#if defined key_top						#if defined key_top
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   'key_top'                                            	   !!   'key_top'                                            
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   USE par_oce							   USE par_oce
   USE par_trc							   USE par_trc
							      >	 !! From Elise 20170316 ---written by xiaofan Luo
							      >	 #if defined key_bdy
							      >	   USE bdy_oce, only: nb_bdy, OBC_DATA
							      >	 #endif  
							      >	 !! ----------------------written by xiaofan Luo
   
   IMPLICIT NONE						   IMPLICIT NONE
   PUBLIC							   PUBLIC

   PUBLIC   trc_alloc   ! called by nemogcm.F90			   PUBLIC   trc_alloc   ! called by nemogcm.F90

   !! parameters for the control of passive tracers		   !! parameters for the control of passive tracers
   !! ---------------------------------------------   		   !! ---------------------------------------------   
   INTEGER, PUBLIC                                           	   INTEGER, PUBLIC                                           
   INTEGER, PUBLIC                                           	   INTEGER, PUBLIC                                           
   INTEGER, PUBLIC                                           	   INTEGER, PUBLIC                                           
   INTEGER, PUBLIC                                           	   INTEGER, PUBLIC                                           
   INTEGER, PUBLIC                                           	   INTEGER, PUBLIC                                           
   INTEGER, PUBLIC                                           	   INTEGER, PUBLIC                                           

   !! passive tracers fields (before,now,after)			   !! passive tracers fields (before,now,after)
   !! --------------------------------------------------	   !! --------------------------------------------------
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:)         	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:)         
   REAL(wp), PUBLIC                                          	   REAL(wp), PUBLIC                                          
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:  )   	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:  )   
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:,:)   	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:,:)   
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:,:)   	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:,:)   
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:,:)   	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:,:)   
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:  )   	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:  )   
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:  )   	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:  )   

   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:  )   	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:  )   
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:  )   	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:  )   
   INTEGER             , PUBLIC                              	   INTEGER             , PUBLIC                              

   !! interpolated gradient					   !! interpolated gradient
   !!--------------------------------------------------  	   !!--------------------------------------------------  
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)     	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)     
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)     	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)     
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)     	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)     
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)     	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)     
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)       	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)       
   								   
   !! passive tracers  (input and output)			   !! passive tracers  (input and output)
   !! ------------------------------------------  		   !! ------------------------------------------  
   LOGICAL             , PUBLIC                              	   LOGICAL             , PUBLIC                              
   LOGICAL             , PUBLIC                              	   LOGICAL             , PUBLIC                              
   INTEGER             , PUBLIC                              	   INTEGER             , PUBLIC                              
   INTEGER             , PUBLIC                              	   INTEGER             , PUBLIC                              
   INTEGER             , PUBLIC                              	   INTEGER             , PUBLIC                              
   INTEGER             , PUBLIC                              	   INTEGER             , PUBLIC                              
   CHARACTER(len = 80) , PUBLIC                              	   CHARACTER(len = 80) , PUBLIC                              
   CHARACTER(len = 256), PUBLIC                              	   CHARACTER(len = 256), PUBLIC                              
   CHARACTER(len = 80) , PUBLIC                              	   CHARACTER(len = 80) , PUBLIC                              
   CHARACTER(len = 256), PUBLIC                              	   CHARACTER(len = 256), PUBLIC                              
   REAL(wp)            , PUBLIC, ALLOCATABLE, SAVE, DIMENSION	   REAL(wp)            , PUBLIC, ALLOCATABLE, SAVE, DIMENSION
   LOGICAL             , PUBLIC                              	   LOGICAL             , PUBLIC                              
   LOGICAL             , PUBLIC                              	   LOGICAL             , PUBLIC                              
   LOGICAL             , PUBLIC                              	   LOGICAL             , PUBLIC                              
   LOGICAL             , PUBLIC                              	   LOGICAL             , PUBLIC                              
   INTEGER             , PUBLIC                              	   INTEGER             , PUBLIC                              
   LOGICAL             , PUBLIC                              	   LOGICAL             , PUBLIC                              

   !! Information for the ice module for tracers		   !! Information for the ice module for tracers
   !! ------------------------------------------		   !! ------------------------------------------
   TYPE TRC_I_NML                    !--- Ice tracer namelist	   TYPE TRC_I_NML                    !--- Ice tracer namelist
         REAL(wp)         :: trc_ratio  ! ice-ocean trc ratio	         REAL(wp)         :: trc_ratio  ! ice-ocean trc ratio
         REAL(wp)         :: trc_prescr ! prescribed ice trc 	         REAL(wp)         :: trc_prescr ! prescribed ice trc 
         CHARACTER(len=2) :: ctrc_o     ! choice of ocean trc	         CHARACTER(len=2) :: ctrc_o     ! choice of ocean trc
   END TYPE							   END TYPE

   REAL(wp), DIMENSION(jptra), PUBLIC         :: trc_ice_rati	   REAL(wp), DIMENSION(jptra), PUBLIC         :: trc_ice_rati
                                                 trc_ice_pres	                                                 trc_ice_pres
   CHARACTER(len=2), DIMENSION(jptra), PUBLIC :: cn_trc_o ! c	   CHARACTER(len=2), DIMENSION(jptra), PUBLIC :: cn_trc_o ! c

   !! information for outputs					   !! information for outputs
   !! --------------------------------------------------	   !! --------------------------------------------------
   TYPE, PUBLIC :: PTRACER                                   	   TYPE, PUBLIC :: PTRACER                                   
       CHARACTER(len = 20)  :: clsname  !: short name		       CHARACTER(len = 20)  :: clsname  !: short name
       CHARACTER(len = 80)  :: cllname  !: long name		       CHARACTER(len = 80)  :: cllname  !: long name
       CHARACTER(len = 20)  :: clunit   !: unit			       CHARACTER(len = 20)  :: clunit   !: unit
       LOGICAL              :: llinit   !: read in a file or 	       LOGICAL              :: llinit   !: read in a file or 
							      >	!! From Elise 20170316------------------written by xiaofanLUO
							      >	     !#if defined  key_bdy
							      >	       LOGICAL              :: llobc   !: read in a file or n
							      >	       LOGICAL              :: llsbc   !: read in a file or n
							      >	       LOGICAL              :: llcbc   !: read in a file or n
							      >	 !#endi
							      >
       LOGICAL              :: llsave   !: save the tracer or	       LOGICAL              :: llsave   !: save the tracer or
							      >	 
							      >	!!------------------------------------xiaofanLuo
   END TYPE PTRACER						   END TYPE PTRACER
   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   CHARACTER(len = 80), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   CHARACTER(len = 80), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   LOGICAL            , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   LOGICAL            , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(

   TYPE, PUBLIC :: DIAG                                      	   TYPE, PUBLIC :: DIAG                                      
      CHARACTER(len = 20)  :: sname    !: short name		      CHARACTER(len = 20)  :: sname    !: short name
      CHARACTER(len = 80)  :: lname    !: long name		      CHARACTER(len = 80)  :: lname    !: long name
      CHARACTER(len = 20)  :: units    !: unit			      CHARACTER(len = 20)  :: units    !: unit
   END TYPE DIAG						   END TYPE DIAG

   !! information for inputs					   !! information for inputs
   !! --------------------------------------------------	   !! --------------------------------------------------
   LOGICAL            , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   LOGICAL            , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   LOGICAL            , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   LOGICAL            , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   LOGICAL            , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   LOGICAL            , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   LOGICAL            , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   LOGICAL            , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(

   !! additional 2D/3D outputs namelist				   !! additional 2D/3D outputs namelist
   !! --------------------------------------------------	   !! --------------------------------------------------
   REAL(wp)           , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   REAL(wp)           , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   REAL(wp)           , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   REAL(wp)           , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   CHARACTER(len = 80), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   CHARACTER(len = 80), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   CHARACTER(len = 80), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   CHARACTER(len = 80), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   LOGICAL            , PUBLIC                               	   LOGICAL            , PUBLIC                               
   INTEGER            , PUBLIC                               	   INTEGER            , PUBLIC                               

   !! Biological trends						   !! Biological trends
   !! -----------------						   !! -----------------
   LOGICAL            , PUBLIC                               	   LOGICAL            , PUBLIC                               
   INTEGER            , PUBLIC                               	   INTEGER            , PUBLIC                               
   REAL(wp)           , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   REAL(wp)           , PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   CHARACTER(len = 80), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   CHARACTER(len = 80), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(
   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(	   CHARACTER(len = 20), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(

   !! variables to average over physics over passive tracer s	   !! variables to average over physics over passive tracer s
   !! -------------------------------------------------------	   !! -------------------------------------------------------
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:,:) ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:,:) ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
# if defined key_zdfddm						# if defined key_zdfddm
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
# endif								# endif
#if defined key_ldfslp						#if defined key_ldfslp
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
#endif								#endif
#if defined key_trabbl						#if defined key_trabbl
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
#endif								#endif
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::

   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   !								   !

   ! Temporary physical arrays for sub_stepping			   ! Temporary physical arrays for sub_stepping
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:,:) ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:,:) ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
   !								   !
#if defined key_trabbl						#if defined key_trabbl
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:)     ::
#endif								#endif
   !								   !
#if defined key_ldfslp						#if defined key_ldfslp
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
#endif								#endif
   ! 								   ! 
# if defined key_zdfddm						# if defined key_zdfddm
   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::	   REAL(wp), PUBLIC, ALLOCATABLE, SAVE, DIMENSION(:,:,:)   ::
# endif								# endif
   !								   !
							      |	!! From ELise ------written by xiaofan Luo
							      >	#if defined key_bdy
							      >	    CHARACTER(len=20), PUBLIC, ALLOCATABLE,  SAVE,  DIMENSION
							      >	    CHARACTER(len=20), PUBLIC, ALLOCATABLE,  SAVE,  DIMENSION
							      >	    INTEGER,           PUBLIC, ALLOCATABLE,  SAVE,  DIMENSION
							      >	    ! External data structure of BDY for TOP. Available eleme
							      >	    TYPE(OBC_DATA),    PUBLIC, ALLOCATABLE, DIMENSION(:,:), T
							      >	#endif
							      >	!! ----------------written by xiaofan Luo
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/TOP 3.3.1 , NEMO Consortium (2010)			   !! NEMO/TOP 3.3.1 , NEMO Consortium (2010)
   !! $Id: trc.F90 5385 2015-06-09 13:50:42Z cetlod $		   !! $Id: trc.F90 5385 2015-06-09 13:50:42Z cetlod $
   !! Software governed by the CeCILL licence     (NEMOGCM/NE	   !! Software governed by the CeCILL licence     (NEMOGCM/NE
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS

   INTEGER FUNCTION trc_alloc()					   INTEGER FUNCTION trc_alloc()
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                    *** ROUTINE trc_alloc ***		      !!                    *** ROUTINE trc_alloc ***
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      USE lib_mpp, ONLY: ctl_warn				      USE lib_mpp, ONLY: ctl_warn
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      ALLOCATE( trn(jpi,jpj,jpk,jptra), trb(jpi,jpj,jpk,jptra	      ALLOCATE( trn(jpi,jpj,jpk,jptra), trb(jpi,jpj,jpk,jptra
         &      trc_i(jpi,jpj,jptra)  , trc_o(jpi,jpj,jptra) 	         &      trc_i(jpi,jpj,jptra)  , trc_o(jpi,jpj,jptra) 
         &      gtru (jpi,jpj,jptra)  , gtrv (jpi,jpj,jptra) 	         &      gtru (jpi,jpj,jptra)  , gtrv (jpi,jpj,jptra) 
         &      gtrui(jpi,jpj,jptra)  , gtrvi(jpi,jpj,jptra) 	         &      gtrui(jpi,jpj,jptra)  , gtrvi(jpi,jpj,jptra) 
         &      sbc_trc_b(jpi,jpj,jptra), sbc_trc(jpi,jpj,jpt	         &      sbc_trc_b(jpi,jpj,jptra), sbc_trc(jpi,jpj,jpt
         &      cvol(jpi,jpj,jpk)     , rdttrc(jpk)          	         &      cvol(jpi,jpj,jpk)     , rdttrc(jpk)          
         &      ctrcnm(jptra)         , ctrcln(jptra)        	         &      ctrcnm(jptra)         , ctrcln(jptra)        
         &      ln_trc_ini(jptra)     , ln_trc_wri(jptra)     |	         &      ln_trc_ini(jptra)     , ln_trc_wri(jptra)    
							      |	         &      ln_trc_sbc(jptra)     , ln_trc_cbc(jptra)    
							      >	#if defined key_bdy
							      >	         &      cn_trc_dflt(nb_bdy)   , cn_trc(nb_bdy)       
							      >	         &      trcdta_bdy(jptra,nb_bdy)                     
							      >	#endif
							      >	         &      STAT = trc_alloc  )
							      >	         ! from elise 20170316 --------xiaofanLuo (l235-l241)
      IF( trc_alloc /= 0 )   CALL ctl_warn('trc_alloc: failed	      IF( trc_alloc /= 0 )   CALL ctl_warn('trc_alloc: failed
      !								      !
   END FUNCTION trc_alloc					   END FUNCTION trc_alloc

#else								#else
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!  Empty module :                                     No 	   !!  Empty module :                                     No 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#endif								#endif

   !!========================================================	   !!========================================================
END MODULE trc							END MODULE trc
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/trcbc.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/trcbc.F90
MODULE trcbc							MODULE trcbc
   !!========================================================	   !!========================================================
   !!                     ***  MODULE  trcdta  ***		   !!                     ***  MODULE  trcdta  ***
   !! TOP :  module for passive tracer boundary conditions	   !! TOP :  module for passive tracer boundary conditions
   !!========================================================	   !!========================================================
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#if  defined key_top 						#if  defined key_top 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   'key_top'                                            	   !!   'key_top'                                            
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   trc_dta    : read and time interpolated passive trace	   !!   trc_dta    : read and time interpolated passive trace
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   USE par_trc       !  passive tracers parameters		   USE par_trc       !  passive tracers parameters
   USE oce_trc       !  shared variables between ocean and pa	   USE oce_trc       !  shared variables between ocean and pa
   USE trc           !  passive tracers common variables	   USE trc           !  passive tracers common variables
   USE iom           !  I/O manager				   USE iom           !  I/O manager
   USE lib_mpp       !  MPP library				   USE lib_mpp       !  MPP library
   USE fldread       !  read input fields			   USE fldread       !  read input fields
							      |	#if defined key_bdy
							      >	   USE bdy_oce, only: nb_bdy , idx_bdy, ln_coords_file, rn_ti
							      >	#endif
   IMPLICIT NONE						   IMPLICIT NONE
   PRIVATE							   PRIVATE

   PUBLIC   trc_bc_init    ! called in trcini.F90 		   PUBLIC   trc_bc_init    ! called in trcini.F90 
   PUBLIC   trc_bc_read    ! called in trcstp.F90 or within	   PUBLIC   trc_bc_read    ! called in trcstp.F90 or within

   INTEGER  , SAVE, PUBLIC                             :: nb_	   INTEGER  , SAVE, PUBLIC                             :: nb_
   INTEGER  , SAVE, PUBLIC                             :: nb_	   INTEGER  , SAVE, PUBLIC                             :: nb_
   INTEGER  , SAVE, PUBLIC                             :: nb_	   INTEGER  , SAVE, PUBLIC                             :: nb_
   INTEGER  , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: n_t	   INTEGER  , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: n_t
   INTEGER  , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: n_t	   INTEGER  , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: n_t
   INTEGER  , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: n_t	   INTEGER  , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: n_t
   INTEGER  , SAVE, PUBLIC                             :: ntr |	   !INTEGER  , SAVE, PUBLIC                             :: nt
   INTEGER  , SAVE, PUBLIC                             :: ntr |	   !INTEGER  , SAVE, PUBLIC                             :: nt
   INTEGER  , SAVE, PUBLIC                             :: ntr |	   !INTEGER  , SAVE, PUBLIC                             :: nt
   REAL(wp) , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: rf_	   REAL(wp) , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: rf_
   TYPE(FLD), SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: sf_ |	   TYPE(FLD), SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:), TARGET
   REAL(wp) , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: rf_	   REAL(wp) , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: rf_
   TYPE(FLD), SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: sf_	   TYPE(FLD), SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: sf_
   REAL(wp) , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: rf_	   REAL(wp) , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: rf_
   TYPE(FLD), SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: sf_	   TYPE(FLD), SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: sf_
							      >	   TYPE(MAP_POINTER), ALLOCATABLE, DIMENSION(:) :: nbmap_ptr 
								   
   !! * Substitutions						   !! * Substitutions
#  include "domzgr_substitute.h90"				#  include "domzgr_substitute.h90"
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/OPA 3.3 , NEMO Consortium (2010)			   !! NEMO/OPA 3.3 , NEMO Consortium (2010)
   !! $Id: trcbc.F90 8511 2017-09-07 15:53:42Z lovato $       |	   !! $Id: trcbc.F90 5215 2015-04-15 16:11:56Z nicolasmartin 
   !! Software governed by the CeCILL licence     (NEMOGCM/NE	   !! Software governed by the CeCILL licence     (NEMOGCM/NE
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS

   SUBROUTINE trc_bc_init(ntrc)					   SUBROUTINE trc_bc_init(ntrc)
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                   ***  ROUTINE trc_bc_init  ***	      !!                   ***  ROUTINE trc_bc_init  ***
      !!                    					      !!                    
      !! ** Purpose :   initialisation of passive tracer BC d	      !! ** Purpose :   initialisation of passive tracer BC d
      !! 							      !! 
      !! ** Method  : - Read namtsd namelist			      !! ** Method  : - Read namtsd namelist
      !!              - allocates passive tracer BC data stru	      !!              - allocates passive tracer BC data stru
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      INTEGER,INTENT(IN) :: ntrc                           ! 	      INTEGER,INTENT(IN) :: ntrc                           ! 
      INTEGER            :: jl, jn                         !  |	      INTEGER            :: jl, jn, ib, ibd, ii, ij, ik    ! 
      INTEGER            :: ierr0, ierr1, ierr2, ierr3     ! 	      INTEGER            :: ierr0, ierr1, ierr2, ierr3     ! 
      INTEGER            ::  ios                           ! 	      INTEGER            ::  ios                           ! 
							      >	      INTEGER            :: nblen, igrd                    ! 
      CHARACTER(len=100) :: clndta, clntrc			      CHARACTER(len=100) :: clndta, clntrc
      !								      !
      CHARACTER(len=100) :: cn_dir			      |	      CHARACTER(len=100) :: cn_dir_sbc, cn_dir_cbc, cn_dir_ob
      TYPE(FLD_N), ALLOCATABLE, DIMENSION(:) :: slf_i  ! loca	      TYPE(FLD_N), ALLOCATABLE, DIMENSION(:) :: slf_i  ! loca
      TYPE(FLD_N), DIMENSION(jpmaxtrc) :: sn_trcobc    ! open	      TYPE(FLD_N), DIMENSION(jpmaxtrc) :: sn_trcobc    ! open
      TYPE(FLD_N), DIMENSION(jpmaxtrc) :: sn_trcsbc    ! surf	      TYPE(FLD_N), DIMENSION(jpmaxtrc) :: sn_trcsbc    ! surf
      TYPE(FLD_N), DIMENSION(jpmaxtrc) :: sn_trccbc    ! coas	      TYPE(FLD_N), DIMENSION(jpmaxtrc) :: sn_trccbc    ! coas
      REAL(wp)   , DIMENSION(jpmaxtrc) :: rn_trofac    ! mult	      REAL(wp)   , DIMENSION(jpmaxtrc) :: rn_trofac    ! mult
      REAL(wp)   , DIMENSION(jpmaxtrc) :: rn_trsfac    ! mult	      REAL(wp)   , DIMENSION(jpmaxtrc) :: rn_trsfac    ! mult
      REAL(wp)   , DIMENSION(jpmaxtrc) :: rn_trcfac    ! mult	      REAL(wp)   , DIMENSION(jpmaxtrc) :: rn_trcfac    ! mult
      !!							      !!
      NAMELIST/namtrc_bc/ cn_dir, sn_trcobc, rn_trofac, sn_tr |	      NAMELIST/namtrc_bc/ cn_dir_sbc, cn_dir_cbc, sn_trcsbc, 
							      >	#if defined key_bdy
							      >	      NAMELIST/namtrc_bdy/ cn_trc_dflt, cn_trc, nn_trcdmp_bdy
							      >	      NAMELIST/nambdy_bc/ cn_dir_obc, sn_trcobc, rn_trofac
							      >	#endif
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      IF( nn_timing == 1 )  CALL timing_start('trc_bc_init')	      IF( nn_timing == 1 )  CALL timing_start('trc_bc_init')
      !								      !
							      >	      IF( lwp ) THEN
							      >	         WRITE(numout,*) ' '
							      >	         WRITE(numout,*) 'trc_bc_init : Tracers Boundary Cond
							      >	         WRITE(numout,*) '~~~~~~~~~~~ '
							      >	         
							      >	         !WRITE(numout,*) "In trc_bc_init at A: nstop=", nsto
							      >	      ENDIF
							      >	      !
      !  Initialisation and local array allocation		      !  Initialisation and local array allocation
      ierr0 = 0  ;  ierr1 = 0  ;  ierr2 = 0  ;  ierr3 = 0  	      ierr0 = 0  ;  ierr1 = 0  ;  ierr2 = 0  ;  ierr3 = 0  
      ALLOCATE( slf_i(ntrc), STAT=ierr0 )			      ALLOCATE( slf_i(ntrc), STAT=ierr0 )
      IF( ierr0 > 0 ) THEN					      IF( ierr0 > 0 ) THEN
         CALL ctl_stop( 'trc_bc_init: unable to allocate loca	         CALL ctl_stop( 'trc_bc_init: unable to allocate loca
      ENDIF							      ENDIF

      ! Compute the number of tracers to be initialised with 	      ! Compute the number of tracers to be initialised with 
      ALLOCATE( n_trc_indobc(ntrc), STAT=ierr0 )		      ALLOCATE( n_trc_indobc(ntrc), STAT=ierr0 )
      IF( ierr0 > 0 ) THEN					      IF( ierr0 > 0 ) THEN
         CALL ctl_stop( 'trc_bc_init: unable to allocate n_tr	         CALL ctl_stop( 'trc_bc_init: unable to allocate n_tr
      ENDIF							     ENDIF
      nb_trcobc      = 0					      nb_trcobc      = 0
      n_trc_indobc(:) = 0					      n_trc_indobc(:) = 0
      !								      !
      ALLOCATE( n_trc_indsbc(ntrc), STAT=ierr0 )		      ALLOCATE( n_trc_indsbc(ntrc), STAT=ierr0 )
      IF( ierr0 > 0 ) THEN					      IF( ierr0 > 0 ) THEN
         CALL ctl_stop( 'trc_bc_init: unable to allocate n_tr	         CALL ctl_stop( 'trc_bc_init: unable to allocate n_tr
      ENDIF							      ENDIF
      nb_trcsbc      = 0					      nb_trcsbc      = 0
      n_trc_indsbc(:) = 0					      n_trc_indsbc(:) = 0
      !								      !
      ALLOCATE( n_trc_indcbc(ntrc), STAT=ierr0 )		      ALLOCATE( n_trc_indcbc(ntrc), STAT=ierr0 )
      IF( ierr0 > 0 ) THEN					      IF( ierr0 > 0 ) THEN
         CALL ctl_stop( 'trc_bc_init: unable to allocate n_tr	         CALL ctl_stop( 'trc_bc_init: unable to allocate n_tr
      ENDIF							      ENDIF
      nb_trccbc      = 0					      nb_trccbc      = 0
      n_trc_indcbc(:) = 0					      n_trc_indcbc(:) = 0
      !								      !
      DO jn = 1, ntrc					      |	      !DO jn = 1, ntrc
         IF( ln_trc_obc(jn) ) THEN			      |	      !   IF( ln_trc_obc(jn) ) THEN
             nb_trcobc       = nb_trcobc + 1 		      |	      !       nb_trcobc       = nb_trcobc + 1 
             n_trc_indobc(jn) = nb_trcobc 		      |	      !       n_trc_indobc(jn) = nb_trcobc 
         ENDIF						      |	      !   ENDIF
         IF( ln_trc_sbc(jn) ) THEN			      |	      !   IF( ln_trc_sbc(jn) ) THEN
             nb_trcsbc       = nb_trcsbc + 1		      |	      !       nb_trcsbc       = nb_trcsbc + 1
             n_trc_indsbc(jn) = nb_trcsbc		      |	      !       n_trc_indsbc(jn) = nb_trcsbc
         ENDIF						      |	      !   ENDIF
         IF( ln_trc_cbc(jn) ) THEN			      |	      !   IF( ln_trc_cbc(jn) ) THEN
             nb_trccbc       = nb_trccbc + 1		      |	      !       nb_trccbc       = nb_trccbc + 1
             n_trc_indcbc(jn) = nb_trccbc		      |	      !       n_trc_indcbc(jn) = nb_trccbc
         ENDIF						      |	      !   ENDIF
      ENDDO						      |	      !ENDDO
      ntra_obc = MAX( 1, nb_trcobc )   ! To avoid compilation |	      !ntra_obc = MAX( 1, nb_trcobc )   ! To avoid compilatio
      IF( lwp ) WRITE(numout,*) ' '			      |	      !IF( lwp ) WRITE(numout,*) ' '
      IF( lwp ) WRITE(numout,*) ' Number of passive tracers t |	      !IF( lwp ) WRITE(numout,*) ' Number of passive tracers 
      IF( lwp ) WRITE(numout,*) ' '			      |	      !IF( lwp ) WRITE(numout,*) ' '
      ntra_sbc = MAX( 1, nb_trcsbc )   ! To avoid compilation |	      !ntra_sbc = MAX( 1, nb_trcsbc )   ! To avoid compilatio
      IF( lwp ) WRITE(numout,*) ' '			      |	      !IF( lwp ) WRITE(numout,*) ' '
      IF( lwp ) WRITE(numout,*) ' Number of passive tracers t |	      !IF( lwp ) WRITE(numout,*) ' Number of passive tracers 
      IF( lwp ) WRITE(numout,*) ' '			      |	      !IF( lwp ) WRITE(numout,*) ' '
      ntra_cbc = MAX( 1, nb_trccbc )   ! To avoid compilation |	      !ntra_cbc = MAX( 1, nb_trccbc )   ! To avoid compilatio
      IF( lwp ) WRITE(numout,*) ' '			      |	      !IF( lwp ) WRITE(numout,*) ' '
      IF( lwp ) WRITE(numout,*) ' Number of passive tracers t |	      !IF( lwp ) WRITE(numout,*) ' Number of passive tracers 
      IF( lwp ) WRITE(numout,*) ' '			      |	      !IF( lwp ) WRITE(numout,*) ' '

							      >	      ! Read Boundary Conditions Namelists
      REWIND( numnat_ref )              ! Namelist namtrc_bc 	      REWIND( numnat_ref )              ! Namelist namtrc_bc 
      READ  ( numnat_ref, namtrc_bc, IOSTAT = ios, ERR = 901)	      READ  ( numnat_ref, namtrc_bc, IOSTAT = ios, ERR = 901)
901   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_bc in refer	901   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_bc in refer

      REWIND( numnat_cfg )              ! Namelist namtrc_bc 	      REWIND( numnat_cfg )              ! Namelist namtrc_bc 
      READ  ( numnat_cfg, namtrc_bc, IOSTAT = ios, ERR = 902 	      READ  ( numnat_cfg, namtrc_bc, IOSTAT = ios, ERR = 902 
902   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_bc in confi	902   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_bc in confi
      IF(lwm) WRITE ( numont, namtrc_bc )			      IF(lwm) WRITE ( numont, namtrc_bc )

      ! print some information for each 		      |	#if defined key_bdy
							      >	      REWIND( numnat_ref )              ! Namelist namtrc_bc 
							      >	      READ  ( numnat_ref, namtrc_bdy, IOSTAT = ios, ERR = 903
							      >	903   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_bdy in refe
							      >
							      >	      REWIND( numnat_cfg )              ! Namelist namtrc_bc 
							      >	      READ  ( numnat_cfg, namtrc_bdy, IOSTAT = ios, ERR = 904
							      >	904   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_bdy in conf
							      >	      IF(lwm) WRITE ( numont, namtrc_bdy )
							      >	      ! setup up preliminary informations for BDY structure
							      >	      REWIND( numnat_ref )
							      >	      REWIND( numnat_cfg )
							      >	      DO ib = 1, nb_bdy
							      >	         DO jn = 1, ntrc
							      >	            ! Set type of obc in BDY data structure (around h
							      >	           ! WRITE(numout,*) "ln_trc_obc(jn)=", ln_trc_obc(jn
							      >	           ! WRITE(numout,*) "jn=", jn, " ib=", ib, "cn_trc(i
							      >	           ! WRITE(numout,*) "jn=", jn, " ib=", ib, "cn_trc_d
							      >	            IF ( ln_trc_obc(jn)) THEN
							      >	               trcdta_bdy(jn,ib)%cn_obc = TRIM( cn_trc(ib) )
							      >	            ELSE
							      >	               trcdta_bdy(jn,ib)%cn_obc = TRIM( cn_trc_dflt(i
							      >	            ENDIF
							      >	            ! set damping use in BDY data structure
							      >	            trcdta_bdy(jn,ib)%dmp = .false.
							      >	            IF(nn_trcdmp_bdy(ib) .EQ. 1 .AND. ln_trc_obc(jn) 
							      >	            IF(nn_trcdmp_bdy(ib) .EQ. 2 ) trcdta_bdy(jn,ib)%d
							      >	            IF(trcdta_bdy(jn,ib)%cn_obc == 'frs' .AND. nn_trc
							      >	                & CALL ctl_stop( 'Use FRS OR relaxation' )
							      >	            IF (nn_trcdmp_bdy(ib) .LT. 0 .OR. nn_trcdmp_bdy(i
							      >	                 WRITE(numout,*) "nn_trcdmp_bdy=", nn_trcdmp_
							      >	                 CALL ctl_stop( 'Not a valid option for nn_tr
							      >	            ENDIF
							      >	         ENDDO
							      >	      ENDDO
							      >
							      >	#else
							      >	      ! Force all tracers OBC to false if bdy not used
							      >	      ln_trc_obc = .false.
							      >	#endif
							      >	      ! compose BC data indexes
							      >	      DO jn = 1, ntrc
							      >	         IF( ln_trc_obc(jn) ) THEN
							      >	             nb_trcobc       = nb_trcobc + 1  ; n_trc_indobc(
							      >	         ENDIF
							      >	         IF( ln_trc_sbc(jn) ) THEN
							      >	             nb_trcsbc       = nb_trcsbc + 1  ; n_trc_indsbc(
							      >	         ENDIF
							      >	         IF( ln_trc_cbc(jn) ) THEN
							      >	             nb_trccbc       = nb_trccbc + 1  ; n_trc_indcbc(
							      >	         ENDIF
							      >	      ENDDO
							      >	       !print some information for each 
      IF( lwp ) THEN						      IF( lwp ) THEN
         DO jn = 1, ntrc					         DO jn = 1, ntrc
            IF( ln_trc_obc(jn) )  THEN    			            IF( ln_trc_obc(jn) )  THEN    
               clndta = TRIM( sn_trcobc(jn)%clvar ) 		               clndta = TRIM( sn_trcobc(jn)%clvar ) 
               IF(lwp) WRITE(numout,*) 'Preparing to read OBC	               IF(lwp) WRITE(numout,*) 'Preparing to read OBC
               &               ' multiplicative factor : ', r	               &               ' multiplicative factor : ', r
            ENDIF						            ENDIF
            IF( ln_trc_sbc(jn) )  THEN    			            IF( ln_trc_sbc(jn) )  THEN    
               clndta = TRIM( sn_trcsbc(jn)%clvar ) 		               clndta = TRIM( sn_trcsbc(jn)%clvar ) 
               IF(lwp) WRITE(numout,*) 'Preparing to read SBC	               IF(lwp) WRITE(numout,*) 'Preparing to read SBC
               &               ' multiplicative factor : ', r	               &               ' multiplicative factor : ', r
            ENDIF						            ENDIF
            IF( ln_trc_cbc(jn) )  THEN    			            IF( ln_trc_cbc(jn) )  THEN    
               clndta = TRIM( sn_trccbc(jn)%clvar ) 		               clndta = TRIM( sn_trccbc(jn)%clvar ) 
               IF(lwp) WRITE(numout,*) 'Preparing to read CBC	               IF(lwp) WRITE(numout,*) 'Preparing to read CBC
               &               ' multiplicative factor : ', r	               &               ' multiplicative factor : ', r
            ENDIF						            ENDIF
         END DO							         END DO
      ENDIF							      ENDIF
      !								      !
      ! The following code is written this way to reduce memo	      ! The following code is written this way to reduce memo
      ! MAV: note that this is just a placeholder and the dim	      ! MAV: note that this is just a placeholder and the dim
      !      what will be done with BDY. A new structure will	      !      what will be done with BDY. A new structure will
      !								      !
      ! OPEN Lateral boundary conditions			      ! OPEN Lateral boundary conditions
      IF( nb_trcobc > 0 ) THEN       !  allocate only if the  |	            ! Print summmary of Boundary Conditions
         ALLOCATE( sf_trcobc(nb_trcobc), rf_trofac(nb_trcobc) |	      IF( lwp ) THEN
							      >	         WRITE(numout,*) ' '
							      >	         WRITE(numout,'(a,i3)') '   Total tracers to be initi
							      >	         IF ( nb_trcsbc > 0 ) THEN
							      >	            WRITE(numout,*) '   #trc        NAME        Bound
							      >	            DO jn = 1, ntrc
							      >	               IF ( ln_trc_sbc(jn) ) WRITE(numout,9001) jn, T
							      >	            ENDDO
							      >	         ENDIF
							      >	         WRITE(numout,'(2a)') '   SURFACE BC data repository 
							      >
							      >	         WRITE(numout,*) ' '
							      >	         WRITE(numout,'(a,i3)') '   Total tracers to be initi
							      >	         IF ( nb_trccbc > 0 ) THEN
							      >	            WRITE(numout,*) '   #trc        NAME        Bound
							      >	            DO jn = 1, ntrc
							      >	               IF ( ln_trc_cbc(jn) ) WRITE(numout, 9001) jn, 
							      >	            ENDDO
							      >	         ENDIF
							      >	         WRITE(numout,'(2a)') '   COASTAL BC data repository 
							      >
							      >	         WRITE(numout,*) ' '
							      >	         WRITE(numout,'(a,i3)') '   Total tracers to be initi
							      >	#if defined key_bdy
							      >	         IF ( nb_trcobc > 0 ) THEN
							      >	            WRITE(numout,*) '   #trc        NAME        Bound
							      >	            DO jn = 1, ntrc
							      >	               IF ( ln_trc_obc(jn) )  WRITE(numout, 9001) jn,
							      >	               IF ( .NOT. ln_trc_obc(jn) )  WRITE(numout, 900
							      >	            ENDDO
							      >	            WRITE(numout,*) ' '
							      >	            DO ib = 1, nb_bdy
							      >	                IF (nn_trcdmp_bdy(ib) .EQ. 0) WRITE(numout,90
							      >	                IF (nn_trcdmp_bdy(ib) .EQ. 1) WRITE(numout,90
							      >	                IF (nn_trcdmp_bdy(ib) .EQ. 2) WRITE(numout,90
							      >	                IF (nn_trcdmp_bdy(ib) .GT. 0) THEN
							      >	                   WRITE(numout,9003) '     USE damping param
							      >	                   WRITE(numout,'(a,f10.2,a)') '     - Inflow
							      >	                   WRITE(numout,'(a,f10.2,a)') '     - Outflo
							      >	                ENDIF
							      >	            ENDDO
							      >	         ENDIF
							      >	#endif
							      >	         WRITE(numout,'(2a)') '   OPEN BC data repository : '
							      >	      ENDIF
							      >	9001  FORMAT(2x,i5, 3x, a15, 3x, a5, 6x, e11.3, 4x, 10a13)
							      >	9002  FORMAT(2x,i5, 3x, a41, 3x, 10a13)
							      >	9003  FORMAT(a, i5, a)
							      >	#if defined key_bdy
							      >	      ! OPEN Lateral boundary conditions
							      >	      IF( nb_trcobc > 0 ) THEN 
							      >	         ALLOCATE ( sf_trcobc(nb_trcobc*nb_bdy), rf_trofac(nb
         IF( ierr1 > 0 ) THEN					         IF( ierr1 > 0 ) THEN
            CALL ctl_stop( 'trc_bc_init: unable to allocate  	            CALL ctl_stop( 'trc_bc_init: unable to allocate s
         ENDIF							         ENDIF
         !						      |
							      >	         igrd = 1                       ! Everything is at T-
							      >
							      >	         DO ib = 1, nb_bdy
							      >	            READ  ( numnat_ref, nambdy_bc, IOSTAT = ios, ERR 
							      >	905         IF( ios /= 0 ) CALL ctl_nam ( ios , 'nambdy_bc in
							      >
							      >	            READ  ( numnat_cfg, nambdy_bc, IOSTAT = ios, ERR 
							      >	906         IF( ios /= 0 ) CALL ctl_nam ( ios , 'nambdy_bc in
							      >	            IF(lwm) WRITE ( numont, nambdy_bc )
							      >
							      >	            nblen = idx_bdy(ib)%nblen(igrd)
							      >	            !WRITE(numout,*) 'nblen=', nblen
							      >	            
         DO jn = 1, ntrc					            DO jn = 1, ntrc
            IF( ln_trc_obc(jn) ) THEN      ! update passive t |	               IF ( ln_trc_obc(jn)) THEN
							      >	               ! Initialise from external data
               jl = n_trc_indobc(jn)				                  jl = n_trc_indobc(jn)
               slf_i(jl)    = sn_trcobc(jn)			                  slf_i(jl)    = sn_trcobc(jn)
               rf_trofac(jl) = rn_trofac(jn)		      |	                  rf_trofac(jl+(ib-1)*nb_trcobc) = rn_trofac(
                                            ALLOCATE( sf_trco |	                                               ALLOCATE( sf_t
               IF( sn_trcobc(jn)%ln_tint )  ALLOCATE( sf_trco |	                  IF( sn_trcobc(jn)%ln_tint )  ALLOCATE( sf_t
               IF( ierr2 + ierr3 > 0 ) THEN			                  IF( ierr2 + ierr3 > 0 ) THEN
                 CALL ctl_stop( 'trc_bc_init : unable to allo	                    CALL ctl_stop( 'trc_bc_init : unable to a
               ENDIF						                  ENDIF
							      >	                  trcdta_bdy(jn,ib)%trc => sf_trcobc(jl+(ib-1
							      >	                  trcdta_bdy(jn,ib)%rn_fac = rf_trofac(jl+(ib
							      >	                  ! create OBC mapping array
							      >	                  nbmap_ptr(jl+(ib-1)*nb_trcobc)%ptr => idx_b
							      >	                  nbmap_ptr(jl+(ib-1)*nb_trcobc)%ll_unstruc =
							      >	               ELSE
							      >	               ! Initialise obc arrays from initial condition
							      >	                  ALLOCATE ( trcdta_bdy(jn,ib)%trc(nblen,jpk)
							      >	                  DO ibd = 1, nblen
							      >	                     DO ik = 1, jpkm1
							      >	                        ii = idx_bdy(ib)%nbi(ibd,igrd)
							      >	                        ij = idx_bdy(ib)%nbj(ibd,igrd)
							      >	                        trcdta_bdy(jn,ib)%trc(ibd,ik) = trn(i
							      >	                     END DO
							      >	                  END DO
							      >	                  trcdta_bdy(jn,ib)%rn_fac = 1._wp
            ENDIF						               ENDIF
            !   					      <
         ENDDO							            ENDDO
         !                         ! fill sf_trcdta with slf_ |	            CALL fld_fill( sf_trcobc((1+(ib-1)*nb_trcobc):(nb
         CALL fld_fill( sf_trcobc, slf_i, cn_dir, 'trc_bc_ini |	            &             'trc_bc_init', 'Passive tracer OBC 
         !						      |	         ENDDO
							      >	          
							      >
      ENDIF							         ENDIF
							      >	#endif
							      >	      !IF( nb_trcobc > 0 ) THEN       !  allocate only if the
							      >	      !   ALLOCATE( sf_trcobc(nb_trcobc), rf_trofac(nb_trcobc
							      >	      !   IF( ierr1 > 0 ) THEN
							      >	      !      CALL ctl_stop( 'trc_bc_init: unable to allocate 
							      >	      !   ENDIF
							      >	      !   !
							      >	      !   DO jn = 1, ntrc
							      >	      !      IF( ln_trc_obc(jn) ) THEN      ! update passive 
							      >	      !         jl = n_trc_indobc(jn)
							      >	      !         slf_i(jl)    = sn_trcobc(jn)
							      >	      !         rf_trofac(jl) = rn_trofac(jn)
							      >	      !                                      ALLOCATE( sf_trc
							      >	      !         IF( sn_trcobc(jn)%ln_tint )  ALLOCATE( sf_trc
							      >	      !         IF( ierr2 + ierr3 > 0 ) THEN
							      >	      !           CALL ctl_stop( 'trc_bc_init : unable to all
							      >	      !         ENDIF
							      >	      !      ENDIF
							      >	      !      !   
							      >	      !   ENDDO
							      >	      !   !                         ! fill sf_trcdta with slf
							      >	      !   CALL fld_fill( sf_trcobc, slf_i, cn_dir, 'trc_bc_in
							      >	      !   !
							      >	      !ENDIF
      !								      !
      ! SURFACE Boundary conditions				      ! SURFACE Boundary conditions
      IF( nb_trcsbc > 0 ) THEN       !  allocate only if the 	      IF( nb_trcsbc > 0 ) THEN       !  allocate only if the 
         ALLOCATE( sf_trcsbc(nb_trcsbc), rf_trsfac(nb_trcsbc)	         ALLOCATE( sf_trcsbc(nb_trcsbc), rf_trsfac(nb_trcsbc)
         IF( ierr1 > 0 ) THEN					         IF( ierr1 > 0 ) THEN
            CALL ctl_stop( 'trc_bc_init: unable to allocate  	            CALL ctl_stop( 'trc_bc_init: unable to allocate  
         ENDIF							         ENDIF
         !							         !
         DO jn = 1, ntrc					         DO jn = 1, ntrc
            IF( ln_trc_sbc(jn) ) THEN      ! update passive t	            IF( ln_trc_sbc(jn) ) THEN      ! update passive t
               jl = n_trc_indsbc(jn)				               jl = n_trc_indsbc(jn)
               slf_i(jl)    = sn_trcsbc(jn)			               slf_i(jl)    = sn_trcsbc(jn)
               rf_trsfac(jl) = rn_trsfac(jn)			               rf_trsfac(jl) = rn_trsfac(jn)
                                            ALLOCATE( sf_trcs	                                            ALLOCATE( sf_trcs
               IF( sn_trcsbc(jn)%ln_tint )  ALLOCATE( sf_trcs	               IF( sn_trcsbc(jn)%ln_tint )  ALLOCATE( sf_trcs
               IF( ierr2 + ierr3 > 0 ) THEN			               IF( ierr2 + ierr3 > 0 ) THEN
                 CALL ctl_stop( 'trc_bc_init : unable to allo	                 CALL ctl_stop( 'trc_bc_init : unable to allo
               ENDIF						               ENDIF
            ENDIF						            ENDIF
            !   						            !   
         ENDDO							         ENDDO
         !                         ! fill sf_trcsbc with slf_	         !                         ! fill sf_trcsbc with slf_
         CALL fld_fill( sf_trcsbc, slf_i, cn_dir, 'trc_bc_ini |	         CALL fld_fill( sf_trcsbc, slf_i, cn_dir_sbc, 'trc_bc
         !							         !
      ENDIF							      ENDIF
      !							      |	      
      ! COSTAL Boundary conditions			      |	      !COASTAL Boundary conditions
      IF( nb_trccbc > 0 ) THEN       !  allocate only if the 	      IF( nb_trccbc > 0 ) THEN       !  allocate only if the 
         ALLOCATE( sf_trccbc(nb_trccbc), rf_trcfac(nb_trccbc)	         ALLOCATE( sf_trccbc(nb_trccbc), rf_trcfac(nb_trccbc)
         IF( ierr1 > 0 ) THEN					         IF( ierr1 > 0 ) THEN
            CALL ctl_stop( 'trc_bc_ini: unable to allocate  s	            CALL ctl_stop( 'trc_bc_ini: unable to allocate  s
         ENDIF							         ENDIF
         !							         !
         DO jn = 1, ntrc					         DO jn = 1, ntrc
            IF( ln_trc_cbc(jn) ) THEN      ! update passive t	            IF( ln_trc_cbc(jn) ) THEN      ! update passive t
               jl = n_trc_indcbc(jn)				               jl = n_trc_indcbc(jn)
               slf_i(jl)    = sn_trccbc(jn)			               slf_i(jl)    = sn_trccbc(jn)
               rf_trcfac(jl) = rn_trcfac(jn)			               rf_trcfac(jl) = rn_trcfac(jn)
                                            ALLOCATE( sf_trcc	                                            ALLOCATE( sf_trcc
               IF( sn_trccbc(jn)%ln_tint )  ALLOCATE( sf_trcc	               IF( sn_trccbc(jn)%ln_tint )  ALLOCATE( sf_trcc
               IF( ierr2 + ierr3 > 0 ) THEN			               IF( ierr2 + ierr3 > 0 ) THEN
                 CALL ctl_stop( 'trc_bc_ini : unable to alloc	                 CALL ctl_stop( 'trc_bc_ini : unable to alloc
               ENDIF						               ENDIF
            ENDIF						            ENDIF
            !   						            !   
         ENDDO							         ENDDO
         !                         ! fill sf_trccbc with slf_	         !                         ! fill sf_trccbc with slf_
         CALL fld_fill( sf_trccbc, slf_i, cn_dir, 'trc_bc_ini |	         CALL fld_fill( sf_trccbc, slf_i, cn_dir_cbc, 'trc_bc
         !							         !
      ENDIF							      ENDIF
 								 
      DEALLOCATE( slf_i )          ! deallocate local field s	      DEALLOCATE( slf_i )          ! deallocate local field s
							      >	      
							      >	      !WRITE(numout,*) "In trc_bc_init at B: nstop=", nstop
      IF( nn_timing == 1 )  CALL timing_stop('trc_bc_init')	      IF( nn_timing == 1 )  CALL timing_stop('trc_bc_init')

   END SUBROUTINE trc_bc_init					   END SUBROUTINE trc_bc_init


   SUBROUTINE trc_bc_read(kt)				      |	   SUBROUTINE trc_bc_read(kt, jit)
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                   ***  ROUTINE trc_bc_init  ***	      !!                   ***  ROUTINE trc_bc_init  ***
      !!							      !!
      !! ** Purpose :  Read passive tracer Boundary Condition	      !! ** Purpose :  Read passive tracer Boundary Condition
      !!							      !!
      !! ** Method  :  Read BC inputs and update data structu	      !! ** Method  :  Read BC inputs and update data structu
      !!              						      !!              
      !!-----------------------------------------------------	      !!-----------------------------------------------------
   								   
      ! NEMO							      ! NEMO
      USE fldread						      USE fldread
      								      
      !! * Arguments						      !! * Arguments
      INTEGER, INTENT( in ) ::   kt      ! ocean time-step in	      INTEGER, INTENT( in ) ::   kt      ! ocean time-step in
							      |	      INTEGER, INTENT( in ), OPTIONAL ::   jit   ! subcycle t
							      >	      INTEGER            ::  ib
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      IF( nn_timing == 1 )  CALL timing_start('trc_bc_read')	      IF( nn_timing == 1 )  CALL timing_start('trc_bc_read')

      IF( kt == nit000 ) THEN					      IF( kt == nit000 ) THEN
         IF(lwp) WRITE(numout,*)				         IF(lwp) WRITE(numout,*)
         IF(lwp) WRITE(numout,*) 'trc_bc_read : Surface bound	         IF(lwp) WRITE(numout,*) 'trc_bc_read : Surface bound
         IF(lwp) WRITE(numout,*) '~~~~~~~ '			         IF(lwp) WRITE(numout,*) '~~~~~~~ '
      ENDIF							      ENDIF
							      >	      !WRITE(numout,*) "In trc_bc_read at A1: nstop=", nstop
							      >	      IF ( PRESENT(jit) ) THEN 
								      
      ! OPEN boundary conditions: DOES NOT WORK. Waiting for  |	#if defined key_bdy
							      >	         ! OPEN boundary conditions (use time_offset=+1 as th
      IF( nb_trcobc > 0 ) THEN					         IF( nb_trcobc > 0 ) THEN
        if (lwp) write(numout,'(a,i5,a,i12)') '   reading OBC |	           if (lwp) write(numout,'(a,i5,a,i10)') '   reading 
        CALL fld_read(kt,1,sf_trcobc)			      |	           DO ib = 1, nb_bdy
        ! vertical interpolation on s-grid and partial step t |	             CALL fld_read(kt=kt, kn_fsbc=1, sd=sf_trcobc((1+
							      >	             &             map=nbmap_ptr((1+(ib-1)*nb_trcobc)
							      >	           END DO
      ENDIF							         ENDIF
							      >	#endif

      ! SURFACE boundary conditions       			         ! SURFACE boundary conditions
      IF( nb_trcsbc > 0 ) THEN					         IF( nb_trcsbc > 0 ) THEN
        if (lwp) write(numout,'(a,i5,a,i12)') '   reading SBC |	           if (lwp) write(numout,'(a,i5,a,i10)') '   reading 
        CALL fld_read(kt,1,sf_trcsbc)			      |	           CALL fld_read(kt=kt, kn_fsbc=1, sd=sf_trcsbc, kit=
      ENDIF							         ENDIF

      ! COASTAL boundary conditions       			         ! COASTAL boundary conditions
      IF( nb_trccbc > 0 ) THEN					         IF( nb_trccbc > 0 ) THEN
        if (lwp) write(numout,'(a,i5,a,i12)') '   reading CBC |	           if (lwp) write(numout,'(a,i5,a,i10)') '   reading 
        CALL fld_read(kt,1,sf_trccbc)			      |	           CALL fld_read(kt=kt, kn_fsbc=1, sd=sf_trccbc, kit=
							      >	         ENDIF
							      >
							      >	      ELSE
							      >	      
							      >	#if defined key_bdy
							      >	         ! OPEN boundary conditions (use time_offset=+1 as th
							      >	         IF( nb_trcobc > 0 ) THEN
							      >	           if (lwp) write(numout,'(a,i5,a,i10)') '   reading 
							      >	           DO ib = 1, nb_bdy
							      >	             CALL fld_read(kt=kt, kn_fsbc=1, sd=sf_trcobc((1+
							      >	             &             map=nbmap_ptr((1+(ib-1)*nb_trcobc)
							      >	           END DO
							      >	         ENDIF
							      >	#endif
							      >
							      >	         ! SURFACE boundary conditions
							      >	         IF( nb_trcsbc > 0 ) THEN
							      >	           if (lwp) write(numout,'(a,i5,a,i10)') '   reading 
							      >	           CALL fld_read(kt=kt, kn_fsbc=1, sd=sf_trcsbc)
							      >	         ENDIF
							      >
							      >	         ! COASTAL boundary conditions
							      >	         IF( nb_trccbc > 0 ) THEN
							      >	           if (lwp) write(numout,'(a,i5,a,i10)') '   reading 
							      >	           CALL fld_read(kt=kt, kn_fsbc=1, sd=sf_trccbc)
							      >	         ENDIF
							      >
      ENDIF   							      ENDIF 
      !								      !
							      >	     !IF(lwp) THEN
							      >	     !    WRITE(numout,*) 'LuoXIAOFAN TEST dic BOUNDDARY in t
							      >	     !ENDIF
							      >	      !WRITE(numout,*) "In trc_bc_read at A: nstop=", nstop
      IF( nn_timing == 1 )  CALL timing_stop('trc_bc_read')	      IF( nn_timing == 1 )  CALL timing_stop('trc_bc_read')
      !       							      !       

   END SUBROUTINE trc_bc_read					   END SUBROUTINE trc_bc_read
#else								#else
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   Dummy module                              NO 3D passi	   !!   Dummy module                              NO 3D passi
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS
   SUBROUTINE trc_bc_read( kt )        ! Empty routine		   SUBROUTINE trc_bc_read( kt )        ! Empty routine
      WRITE(*,*) 'trc_bc_read: You should not have seen this 	      WRITE(*,*) 'trc_bc_read: You should not have seen this 
   END SUBROUTINE trc_bc_read					   END SUBROUTINE trc_bc_read
#endif								#endif

   !!========================================================	   !!========================================================
							      >
							      >	      
							      >	    
							      >	  
							      >
							      >
							      >
END MODULE trcbc						END MODULE trcbc
							      )
Only in /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC: trcbdy.F90
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/trcdia.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/trcdia.F90
MODULE trcdia							MODULE trcdia
   !!========================================================	   !!========================================================
   !!                       *** MODULE trcdia ***		   !!                       *** MODULE trcdia ***
   !! TOP :   Output of passive tracers				   !! TOP :   Output of passive tracers
   !!========================================================	   !!========================================================
   !! History :   OPA  !  1995-01 (M. Levy)  Original code	   !! History :   OPA  !  1995-01 (M. Levy)  Original code
   !!              -   !  1998-01 (C. Levy) NETCDF format usi	   !!              -   !  1998-01 (C. Levy) NETCDF format usi
   !!              -   !  1999-01 (M.A. Foujols) adapted for 	   !!              -   !  1999-01 (M.A. Foujols) adapted for 
   !!              -   !  1999-09 (M.A. Foujols) split into t	   !!              -   !  1999-09 (M.A. Foujols) split into t
   !!   NEMO      1.0  !  2005-03 (O. Aumont, A. El Moussaoui	   !!   NEMO      1.0  !  2005-03 (O. Aumont, A. El Moussaoui
   !!                  !  2008-05 (C. Ethe re-organization)	   !!                  !  2008-05 (C. Ethe re-organization)
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#if defined key_top 						#if defined key_top 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   'key_top'                                            	   !!   'key_top'                                            
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! trc_dia     : main routine of output passive tracer	   !! trc_dia     : main routine of output passive tracer
   !! trcdit_wr   : outputs of concentration fields		   !! trcdit_wr   : outputs of concentration fields
   !! trcdii_wr   : outputs of additional 2D/3D diagnostics	   !! trcdii_wr   : outputs of additional 2D/3D diagnostics
   !! trcdib_wr   : outputs of biological fields		   !! trcdib_wr   : outputs of biological fields
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   USE dom_oce         ! ocean space and time domain variable	   USE dom_oce         ! ocean space and time domain variable
   USE oce_trc							   USE oce_trc
   USE trc							   USE trc
   USE par_trc							   USE par_trc
   USE dianam    ! build name of file (routine)			   USE dianam    ! build name of file (routine)
   USE ioipsl    ! I/O manager					   USE ioipsl    ! I/O manager
   USE iom       ! I/O manager					   USE iom       ! I/O manager
   USE lib_mpp   ! MPP library					   USE lib_mpp   ! MPP library

   IMPLICIT NONE						   IMPLICIT NONE
   PRIVATE							   PRIVATE

   PUBLIC   trc_dia        ! called by XXX module 		   PUBLIC   trc_dia        ! called by XXX module 

   INTEGER  ::   nit5      !: id for tracer output file		   INTEGER  ::   nit5      !: id for tracer output file
   INTEGER  ::   ndepit5   !: id for depth mesh			   INTEGER  ::   ndepit5   !: id for depth mesh
   INTEGER  ::   nhorit5   !: id for horizontal mesh		   INTEGER  ::   nhorit5   !: id for horizontal mesh
   INTEGER  ::   ndimt50   !: number of ocean points in index	   INTEGER  ::   ndimt50   !: number of ocean points in index
   INTEGER  ::   ndimt51   !: number of ocean points in index	   INTEGER  ::   ndimt51   !: number of ocean points in index
   REAL(wp) ::   zjulian   !: ????   not DOCTOR !		   REAL(wp) ::   zjulian   !: ????   not DOCTOR !
   INTEGER , ALLOCATABLE, SAVE, DIMENSION (:) ::   ndext50   	   INTEGER , ALLOCATABLE, SAVE, DIMENSION (:) ::   ndext50   
   INTEGER , ALLOCATABLE, SAVE, DIMENSION (:) ::   ndext51   	   INTEGER , ALLOCATABLE, SAVE, DIMENSION (:) ::   ndext51   

   INTEGER  ::   nitd      !: id for additional array output 	   INTEGER  ::   nitd      !: id for additional array output 
   INTEGER  ::   ndepitd   !: id for depth mesh			   INTEGER  ::   ndepitd   !: id for depth mesh
   INTEGER  ::   nhoritd   !: id for horizontal mesh		   INTEGER  ::   nhoritd   !: id for horizontal mesh

   INTEGER  ::   nitb        !:         id.         for addit	   INTEGER  ::   nitb        !:         id.         for addit
   INTEGER  ::   ndepitb   !:  id for depth mesh		   INTEGER  ::   ndepitb   !:  id for depth mesh
   INTEGER  ::   nhoritb   !:  id for horizontal mesh		   INTEGER  ::   nhoritb   !:  id for horizontal mesh

   !! * Substitutions						   !! * Substitutions
#  include "top_substitute.h90"					#  include "top_substitute.h90"
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/TOP 3.3 , NEMO Consortium (2010)			   !! NEMO/TOP 3.3 , NEMO Consortium (2010)
   !! $Id: trcdia.F90 4292 2013-11-20 16:28:04Z cetlod $ 	   !! $Id: trcdia.F90 4292 2013-11-20 16:28:04Z cetlod $ 
   !! Software governed by the CeCILL licence     (NEMOGCM/NE	   !! Software governed by the CeCILL licence     (NEMOGCM/NE
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS

   SUBROUTINE trc_dia( kt )  					   SUBROUTINE trc_dia( kt )  
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trc_dia  ***		      !!                     ***  ROUTINE trc_dia  ***
      !!							      !!
      !! ** Purpose :   output passive tracers fields 		      !! ** Purpose :   output passive tracers fields 
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER, INTENT(in) ::   kt    ! ocean time-step		      INTEGER, INTENT(in) ::   kt    ! ocean time-step
      !								      !
      INTEGER             ::  ierr   ! local integer		      INTEGER             ::  ierr   ! local integer
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      IF( kt == nittrc000 )  THEN				      IF( kt == nittrc000 )  THEN
         ALLOCATE( ndext50(jpij*jpk), ndext51(jpij), STAT=ier	         ALLOCATE( ndext50(jpij*jpk), ndext51(jpij), STAT=ier
         IF( ierr > 0 ) THEN					         IF( ierr > 0 ) THEN
            CALL ctl_stop( 'STOP', 'trc_diat: unable to alloc	            CALL ctl_stop( 'STOP', 'trc_diat: unable to alloc
         ENDIF							         ENDIF
      ENDIF							      ENDIF
      !								      !
      IF( .NOT.lk_iomput ) THEN					      IF( .NOT.lk_iomput ) THEN
                          CALL trcdit_wr( kt )      ! outputs	                          CALL trcdit_wr( kt )      ! outputs
         IF( ln_diatrc )  CALL trcdii_wr( kt )      ! outputs	         IF( ln_diatrc )  CALL trcdii_wr( kt )      ! outputs
         IF( ln_diabio )  CALL trcdib_wr( kt )      ! outputs	         IF( ln_diabio )  CALL trcdib_wr( kt )      ! outputs
      ENDIF							      ENDIF
      !								      !
   END SUBROUTINE trc_dia					   END SUBROUTINE trc_dia


   SUBROUTINE trcdit_wr( kt )					   SUBROUTINE trcdit_wr( kt )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trcdit_wr  ***	      !!                     ***  ROUTINE trcdit_wr  ***
      !!							      !!
      !! ** Purpose :   Standard output of passive tracer : c	      !! ** Purpose :   Standard output of passive tracer : c
      !!							      !!
      !! ** Method  :   At the beginning of the first time st	      !! ** Method  :   At the beginning of the first time st
      !!             the NETCDF files and fields for concentr	      !!             the NETCDF files and fields for concentr
      !!							      !!
      !!        At each time step call histdef to compute the	      !!        At each time step call histdef to compute the
      !!        Each nwritetrc time step, output the instanta	      !!        Each nwritetrc time step, output the instanta
      !!							      !!
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER, INTENT(in) ::   kt       ! ocean time-step	      INTEGER, INTENT(in) ::   kt       ! ocean time-step
      !								      !
      INTEGER ::   jn						      INTEGER ::   jn
      LOGICAL ::   ll_print = .FALSE.				      LOGICAL ::   ll_print = .FALSE.
      CHARACTER (len=40) :: clhstnam, clop			      CHARACTER (len=40) :: clhstnam, clop
      INTEGER ::   inum = 11             ! temporary logical 	      INTEGER ::   inum = 11             ! temporary logical 
      CHARACTER (len=20) :: cltra, cltrau			      CHARACTER (len=20) :: cltra, cltrau
      CHARACTER (len=80) :: cltral				      CHARACTER (len=80) :: cltral
      REAL(wp) :: zsto, zout, zdt				      REAL(wp) :: zsto, zout, zdt
      INTEGER  :: iimi, iima, ijmi, ijma, ipk, it, itmod, iit	      INTEGER  :: iimi, iima, ijmi, ijma, ipk, it, itmod, iit
      !!-----------------------------------------------------	      !!-----------------------------------------------------

      ! Initialisation						      ! Initialisation
      ! --------------						      ! --------------

      ! local variable for debugging				      ! local variable for debugging
      ll_print = .FALSE.                  ! change it to true	      ll_print = .FALSE.                  ! change it to true
      ll_print = ll_print .AND. lwp				      ll_print = ll_print .AND. lwp

      ! Define frequency of output and means			      ! Define frequency of output and means
      zdt = rdt							      zdt = rdt
      IF( ln_mskland )   THEN   ;   clop = "only(x)"   ! put 	      IF( ln_mskland )   THEN   ;   clop = "only(x)"   ! put 
      ELSE                      ;   clop = "x"         ! no u	      ELSE                      ;   clop = "x"         ! no u
      ENDIF							      ENDIF
# if defined key_diainstant					# if defined key_diainstant
      zsto = nn_writetrc * rdt					      zsto = nn_writetrc * rdt
      clop = "inst("//TRIM(clop)//")"				      clop = "inst("//TRIM(clop)//")"
# else								# else
      zsto = zdt						      zsto = zdt
      clop = "ave("//TRIM(clop)//")"				      clop = "ave("//TRIM(clop)//")"
# endif								# endif
      zout = nn_writetrc * zdt					      zout = nn_writetrc * zdt

      ! Define indices of the horizontal output zoom and vert	      ! Define indices of the horizontal output zoom and vert
      iimi = 1      ;      iima = jpi				      iimi = 1      ;      iima = jpi
      ijmi = 1      ;      ijma = jpj				      ijmi = 1      ;      ijma = jpj
      ipk = jpk							      ipk = jpk

      ! define time axis					      ! define time axis
      itmod = kt - nittrc000 + 1				      itmod = kt - nittrc000 + 1
      it    = kt						      it    = kt
      iiter = ( nittrc000 - 1 ) / nn_dttrc			      iiter = ( nittrc000 - 1 ) / nn_dttrc

      ! Define NETCDF files and fields at beginning of first 	      ! Define NETCDF files and fields at beginning of first 
      ! -----------------------------------------------------	      ! -----------------------------------------------------

      IF(ll_print)WRITE(numout,*)'trcdit_wr kt=',kt		      IF(ll_print)WRITE(numout,*)'trcdit_wr kt=',kt
      								      
      IF( kt == nittrc000 ) THEN				      IF( kt == nittrc000 ) THEN

         IF(lwp) THEN                   ! control print		         IF(lwp) THEN                   ! control print
            WRITE(numout,*)					            WRITE(numout,*)
            WRITE(numout,*) '    frequency of outputs for pas	            WRITE(numout,*) '    frequency of outputs for pas
            DO jn = 1, jptra					            DO jn = 1, jptra
               IF( ln_trc_wri(jn) )  WRITE(numout,*) ' ouput 	               IF( ln_trc_wri(jn) )  WRITE(numout,*) ' ouput 
            END DO						            END DO
            WRITE(numout,*) ' '					            WRITE(numout,*) ' '
         ENDIF							         ENDIF

         ! Compute julian date from starting date of the run	         ! Compute julian date from starting date of the run
         CALL ymds2ju( nyear, nmonth, nday, rdt, zjulian )	         CALL ymds2ju( nyear, nmonth, nday, rdt, zjulian )
         zjulian = zjulian - adatrj   !   set calendar origin	         zjulian = zjulian - adatrj   !   set calendar origin
         IF(lwp)WRITE(numout,*)' '  				         IF(lwp)WRITE(numout,*)' '  
         IF(lwp)WRITE(numout,*)' Date 0 used :', nittrc000   	         IF(lwp)WRITE(numout,*)' Date 0 used :', nittrc000   
            &                 ,' YEAR ', nyear, ' MONTH ', nm	            &                 ,' YEAR ', nyear, ' MONTH ', nm
            &                 ,'Julian day : ', zjulian  	            &                 ,'Julian day : ', zjulian  
  								  
         IF(lwp) WRITE(numout,*) ' indexes of zoom = ', iimi,	         IF(lwp) WRITE(numout,*) ' indexes of zoom = ', iimi,
            &                    ' limit storage in depth = '	            &                    ' limit storage in depth = '

         IF( lk_offline .AND. lwp ) THEN			         IF( lk_offline .AND. lwp ) THEN
            CALL dia_nam( clhstnam, nn_writetrc,' ' )		            CALL dia_nam( clhstnam, nn_writetrc,' ' )
            CALL ctl_opn( inum, 'date.file', 'REPLACE', 'FORM	            CALL ctl_opn( inum, 'date.file', 'REPLACE', 'FORM
            WRITE(inum,*) clhstnam				            WRITE(inum,*) clhstnam
            CLOSE(inum)						            CLOSE(inum)
         ENDIF							         ENDIF

         ! Define the NETCDF files for passive tracer concent	         ! Define the NETCDF files for passive tracer concent
         CALL dia_nam( clhstnam, nn_writetrc, 'ptrc_T' )	         CALL dia_nam( clhstnam, nn_writetrc, 'ptrc_T' )
         IF(lwp)WRITE(numout,*)" Name of NETCDF file ", clhst	         IF(lwp)WRITE(numout,*)" Name of NETCDF file ", clhst

         ! Horizontal grid : glamt and gphit			         ! Horizontal grid : glamt and gphit
         CALL histbeg( clhstnam, jpi, glamt, jpj, gphit,     	         CALL histbeg( clhstnam, jpi, glamt, jpj, gphit,     
            &          iimi, iima-iimi+1, ijmi, ijma-ijmi+1, 	            &          iimi, iima-iimi+1, ijmi, ijma-ijmi+1, 
            &          iiter, zjulian, zdt, nhorit5, nit5 , d	            &          iiter, zjulian, zdt, nhorit5, nit5 , d

         ! Vertical grid for tracer : gdept			         ! Vertical grid for tracer : gdept
         CALL histvert( nit5, 'deptht', 'Vertical T levels', 	         CALL histvert( nit5, 'deptht', 'Vertical T levels', 

         ! Index of ocean points in 3D and 2D (surface)		         ! Index of ocean points in 3D and 2D (surface)
         CALL wheneq( jpi*jpj*ipk, tmask, 1, 1., ndext50, ndi	         CALL wheneq( jpi*jpj*ipk, tmask, 1, 1., ndext50, ndi
         CALL wheneq( jpi*jpj    , tmask, 1, 1., ndext51, ndi	         CALL wheneq( jpi*jpj    , tmask, 1, 1., ndext51, ndi

         ! Declare all the output fields as NETCDF variables	         ! Declare all the output fields as NETCDF variables
         DO jn = 1, jptra					         DO jn = 1, jptra
            IF( ln_trc_wri(jn) ) THEN				            IF( ln_trc_wri(jn) ) THEN
               cltra  = TRIM( ctrcnm(jn) )   ! short title fo	               cltra  = TRIM( ctrcnm(jn) )   ! short title fo
               cltral = TRIM( ctrcln(jn) )   ! long title for	               cltral = TRIM( ctrcln(jn) )   ! long title for
               cltrau = TRIM( ctrcun(jn) )   ! UNIT for trace	               cltrau = TRIM( ctrcun(jn) )   ! UNIT for trace
               CALL histdef( nit5, cltra, cltral, cltrau, jpi	               CALL histdef( nit5, cltra, cltral, cltrau, jpi
                  &          ipk, 1, ipk,  ndepit5, 32, clop,	                  &          ipk, 1, ipk,  ndepit5, 32, clop,
            ENDIF						            ENDIF
         END DO							         END DO

         ! end netcdf files header				         ! end netcdf files header
         CALL histend( nit5, snc4set )				         CALL histend( nit5, snc4set )
         IF(lwp) WRITE(numout,*)				         IF(lwp) WRITE(numout,*)
         IF(lwp) WRITE(numout,*) 'End of NetCDF Initializatio	         IF(lwp) WRITE(numout,*) 'End of NetCDF Initializatio
         IF( ll_print )   CALL FLUSH(numout )			         IF( ll_print )   CALL FLUSH(numout )

      ENDIF							      ENDIF

      ! Start writing the tracer concentrations			      ! Start writing the tracer concentrations
      ! ---------------------------------------			      ! ---------------------------------------

      IF( lwp .AND. MOD( itmod, nn_writetrc ) == 0 ) THEN	      IF( lwp .AND. MOD( itmod, nn_writetrc ) == 0 ) THEN
         WRITE(numout,*) 'trcdit_wr : write NetCDF passive tr	         WRITE(numout,*) 'trcdit_wr : write NetCDF passive tr
         WRITE(numout,*) '~~~~~~~~~ '				         WRITE(numout,*) '~~~~~~~~~ '
      ENDIF							      ENDIF

      DO jn = 1, jptra						      DO jn = 1, jptra
         cltra  = TRIM( ctrcnm(jn) )   ! short title for trac	         cltra  = TRIM( ctrcnm(jn) )   ! short title for trac
         IF( ln_trc_wri(jn) ) CALL histwrite( nit5, cltra, it	         IF( ln_trc_wri(jn) ) CALL histwrite( nit5, cltra, it
      END DO							      END DO

      ! close the file 						      ! close the file 
      ! --------------						      ! --------------
      IF( kt == nitend )   CALL histclo( nit5 )			      IF( kt == nitend )   CALL histclo( nit5 )
      !								      !
   END SUBROUTINE trcdit_wr					   END SUBROUTINE trcdit_wr

   SUBROUTINE trcdii_wr( kt )					   SUBROUTINE trcdii_wr( kt )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trcdii_wr  ***	      !!                     ***  ROUTINE trcdii_wr  ***
      !!							      !!
      !! ** Purpose :   output of passive tracer : additional	      !! ** Purpose :   output of passive tracer : additional
      !!							      !!
      !! ** Method  :   At the beginning of the first time st	      !! ** Method  :   At the beginning of the first time st
      !!             the NETCDF files and fields for concentr	      !!             the NETCDF files and fields for concentr
      !!							      !!
      !!        At each time step call histdef to compute the	      !!        At each time step call histdef to compute the
      !!        Each nn_writedia time step, output the instan	      !!        Each nn_writedia time step, output the instan
      !!							      !!
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER, INTENT(in) ::   kt       ! ocean time-step	      INTEGER, INTENT(in) ::   kt       ! ocean time-step
      !!							      !!
      LOGICAL ::   ll_print = .FALSE.				      LOGICAL ::   ll_print = .FALSE.
      CHARACTER (len=40) ::   clhstnam, clop			      CHARACTER (len=40) ::   clhstnam, clop
      CHARACTER (len=20) ::   cltra, cltrau			      CHARACTER (len=20) ::   cltra, cltrau
      CHARACTER (len=80) ::   cltral				      CHARACTER (len=80) ::   cltral
      INTEGER  ::   jl						      INTEGER  ::   jl
      INTEGER  ::   iimi, iima, ijmi, ijma, ipk, it, itmod, i	      INTEGER  ::   iimi, iima, ijmi, ijma, ipk, it, itmod, i
      REAL(wp) ::   zsto, zout, zdt				      REAL(wp) ::   zsto, zout, zdt
      !!-----------------------------------------------------	      !!-----------------------------------------------------

      ! Initialisation						      ! Initialisation
      ! --------------						      ! --------------
      								      
      ! local variable for debugging				      ! local variable for debugging
      ll_print = .FALSE.					      ll_print = .FALSE.
      ll_print = ll_print .AND. lwp				      ll_print = ll_print .AND. lwp
      !								      !
      ! Define frequency of output and means			      ! Define frequency of output and means
      zdt = rdt							      zdt = rdt
      IF( ln_mskland )   THEN   ;   clop = "only(x)"   ! put 	      IF( ln_mskland )   THEN   ;   clop = "only(x)"   ! put 
      ELSE                      ;   clop = "x"         ! no u	      ELSE                      ;   clop = "x"         ! no u
      ENDIF							      ENDIF
#  if defined key_diainstant					#  if defined key_diainstant
      zsto = nn_writedia * zdt					      zsto = nn_writedia * zdt
      clop = "inst("//TRIM(clop)//")"				      clop = "inst("//TRIM(clop)//")"
#  else								#  else
      zsto = zdt						      zsto = zdt
      clop = "ave("//TRIM(clop)//")"				      clop = "ave("//TRIM(clop)//")"
#  endif							#  endif
      zout = nn_writedia * zdt					      zout = nn_writedia * zdt

      ! Define indices of the horizontal output zoom and vert	      ! Define indices of the horizontal output zoom and vert
      iimi = 1      ;      iima = jpi				      iimi = 1      ;      iima = jpi
      ijmi = 1      ;      ijma = jpj				      ijmi = 1      ;      ijma = jpj
      ipk = jpk							      ipk = jpk

      ! define time axis					      ! define time axis
      itmod = kt - nittrc000 + 1				      itmod = kt - nittrc000 + 1
      it    = kt						      it    = kt
      iiter = ( nittrc000 - 1 ) / nn_dttrc			      iiter = ( nittrc000 - 1 ) / nn_dttrc

      ! 1. Define NETCDF files and fields at beginning of fir	      ! 1. Define NETCDF files and fields at beginning of fir
      ! -----------------------------------------------------	      ! -----------------------------------------------------

      IF( ll_print ) WRITE(numout,*) 'trcdii_wr kt=', kt	      IF( ll_print ) WRITE(numout,*) 'trcdii_wr kt=', kt

      IF( kt == nittrc000 ) THEN				      IF( kt == nittrc000 ) THEN

         ! Define the NETCDF files for additional arrays : 2D	         ! Define the NETCDF files for additional arrays : 2D

         ! Define the T grid file for tracer auxiliary files	         ! Define the T grid file for tracer auxiliary files

         CALL dia_nam( clhstnam, nn_writedia, 'diad_T' )	         CALL dia_nam( clhstnam, nn_writedia, 'diad_T' )
         IF(lwp) WRITE(numout,*) " Name of NETCDF file ", clh	         IF(lwp) WRITE(numout,*) " Name of NETCDF file ", clh

         ! Define a netcdf FILE for 2d and 3d arrays		         ! Define a netcdf FILE for 2d and 3d arrays

         CALL histbeg( clhstnam, jpi, glamt, jpj, gphit,     	         CALL histbeg( clhstnam, jpi, glamt, jpj, gphit,     
            &          iimi, iima-iimi+1, ijmi, ijma-ijmi+1, 	            &          iimi, iima-iimi+1, ijmi, ijma-ijmi+1, 
            &          iiter, zjulian, zdt, nhoritd, nitd , d	            &          iiter, zjulian, zdt, nhoritd, nitd , d

         ! Vertical grid for 2d and 3d arrays			         ! Vertical grid for 2d and 3d arrays

         CALL histvert( nitd, 'deptht', 'Vertical T levels','	         CALL histvert( nitd, 'deptht', 'Vertical T levels','

         ! Declare all the output fields as NETCDF variables	         ! Declare all the output fields as NETCDF variables

         ! more 3D horizontal arrays				         ! more 3D horizontal arrays
         DO jl = 1, jpdia3d					         DO jl = 1, jpdia3d
            cltra  = TRIM( ctrc3d(jl) )   ! short title for 3	            cltra  = TRIM( ctrc3d(jl) )   ! short title for 3
            cltral = TRIM( ctrc3l(jl) )  ! long title for 3D 	            cltral = TRIM( ctrc3l(jl) )  ! long title for 3D 
            cltrau = TRIM( ctrc3u(jl) )  ! UNIT for 3D diagno	            cltrau = TRIM( ctrc3u(jl) )  ! UNIT for 3D diagno
            CALL histdef( nitd, cltra, cltral, cltrau, jpi, j	            CALL histdef( nitd, cltra, cltral, cltrau, jpi, j
               &          ipk, 1, ipk,  ndepitd, 32, clop, zs	               &          ipk, 1, ipk,  ndepitd, 32, clop, zs
         END DO							         END DO

         ! more 2D horizontal arrays				         ! more 2D horizontal arrays
         DO jl = 1, jpdia2d					         DO jl = 1, jpdia2d
            cltra  = TRIM( ctrc2d(jl) )   ! short title for 2	            cltra  = TRIM( ctrc2d(jl) )   ! short title for 2
            cltral = TRIM( ctrc2l(jl) )  ! long title for 2D 	            cltral = TRIM( ctrc2l(jl) )  ! long title for 2D 
            cltrau = TRIM( ctrc2u(jl) )  ! UNIT for 2D diagno	            cltrau = TRIM( ctrc2u(jl) )  ! UNIT for 2D diagno
            CALL histdef( nitd, cltra, cltral, cltrau, jpi, j	            CALL histdef( nitd, cltra, cltral, cltrau, jpi, j
               &          1, 1, 1,  -99, 32, clop, zsto, zout	               &          1, 1, 1,  -99, 32, clop, zsto, zout
         END DO							         END DO

         ! TODO: more 2D vertical sections arrays : I or J in	         ! TODO: more 2D vertical sections arrays : I or J in

         ! CLOSE netcdf Files					         ! CLOSE netcdf Files
         CALL histend( nitd, snc4set )				         CALL histend( nitd, snc4set )

         IF(lwp) WRITE(numout,*)				         IF(lwp) WRITE(numout,*)
         IF(lwp) WRITE(numout,*) 'End of NetCDF Initializatio	         IF(lwp) WRITE(numout,*) 'End of NetCDF Initializatio
         IF( ll_print )   CALL FLUSH(numout )			         IF( ll_print )   CALL FLUSH(numout )
         !							         !
      ENDIF							      ENDIF

      ! 2. Start writing data					      ! 2. Start writing data
      ! ---------------------					      ! ---------------------

      IF( lwp .AND. MOD( itmod, nn_writedia ) == 0 ) THEN	      IF( lwp .AND. MOD( itmod, nn_writedia ) == 0 ) THEN
         WRITE(numout,*) 'trcdii_wr : write NetCDF additional	         WRITE(numout,*) 'trcdii_wr : write NetCDF additional
         WRITE(numout,*) '~~~~~~ '				         WRITE(numout,*) '~~~~~~ '
      ENDIF							      ENDIF

      ! more 3D horizontal arrays				      ! more 3D horizontal arrays
      DO jl = 1, jpdia3d					      DO jl = 1, jpdia3d
         cltra  = TRIM( ctrc3d(jl) )   ! short title for 3D d	         cltra  = TRIM( ctrc3d(jl) )   ! short title for 3D d
         CALL histwrite( nitd, cltra, it, trc3d(:,:,:,jl), nd	         CALL histwrite( nitd, cltra, it, trc3d(:,:,:,jl), nd
      END DO							      END DO

      ! more 2D horizontal arrays				      ! more 2D horizontal arrays
      DO jl = 1, jpdia2d					      DO jl = 1, jpdia2d
         cltra  = TRIM( ctrc2d(jl) )   ! short title for 2D d	         cltra  = TRIM( ctrc2d(jl) )   ! short title for 2D d
         CALL histwrite(nitd, cltra, it, trc2d(:,:,jl), ndimt	         CALL histwrite(nitd, cltra, it, trc2d(:,:,jl), ndimt
      END DO							      END DO

      ! Closing all files					      ! Closing all files
      ! -----------------					      ! -----------------
      IF( kt == nitend )   CALL histclo(nitd)			      IF( kt == nitend )   CALL histclo(nitd)
      !								      !

   END SUBROUTINE trcdii_wr					   END SUBROUTINE trcdii_wr

   SUBROUTINE trcdib_wr( kt )					   SUBROUTINE trcdib_wr( kt )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trcdib_wr  ***	      !!                     ***  ROUTINE trcdib_wr  ***
      !!							      !!
      !! ** Purpose :   output of passive tracer : biological	      !! ** Purpose :   output of passive tracer : biological
      !!							      !!
      !! ** Method  :   At the beginning of the first time st	      !! ** Method  :   At the beginning of the first time st
      !!             the NETCDF files and fields for concentr	      !!             the NETCDF files and fields for concentr
      !!							      !!
      !!        At each time step call histdef to compute the	      !!        At each time step call histdef to compute the
      !!        Each nn_writebio time step, output the instan	      !!        Each nn_writebio time step, output the instan
      !!							      !!
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER, INTENT( in ) ::   kt          ! ocean time-ste	      INTEGER, INTENT( in ) ::   kt          ! ocean time-ste
      !!							      !!
      LOGICAL ::   ll_print = .FALSE.				      LOGICAL ::   ll_print = .FALSE.
      CHARACTER (len=40) ::   clhstnam, clop			      CHARACTER (len=40) ::   clhstnam, clop
      CHARACTER (len=20) ::   cltra, cltrau			      CHARACTER (len=20) ::   cltra, cltrau
      CHARACTER (len=80) ::   cltral				      CHARACTER (len=80) ::   cltral
      INTEGER  ::   ji, jj, jk, jl				      INTEGER  ::   ji, jj, jk, jl
      INTEGER  ::   iimi, iima, ijmi, ijma, ipk, it, itmod, i	      INTEGER  ::   iimi, iima, ijmi, ijma, ipk, it, itmod, i
      REAL(wp) ::   zsto, zout, zdt				      REAL(wp) ::   zsto, zout, zdt
      !!-----------------------------------------------------	      !!-----------------------------------------------------

      ! Initialisation						      ! Initialisation
      ! --------------						      ! --------------
      								      
      ! local variable for debugging				      ! local variable for debugging
      ll_print = .FALSE.					      ll_print = .FALSE.
      ll_print = ll_print .AND. lwp				      ll_print = ll_print .AND. lwp

      ! Define frequency of output and means			      ! Define frequency of output and means
      zdt = rdt							      zdt = rdt
      IF( ln_mskland )   THEN   ;   clop = "only(x)"   ! put 	      IF( ln_mskland )   THEN   ;   clop = "only(x)"   ! put 
      ELSE                      ;   clop = "x"         ! no u	      ELSE                      ;   clop = "x"         ! no u
      ENDIF							      ENDIF
#        if defined key_diainstant				#        if defined key_diainstant
      zsto = nn_writebio * zdt					      zsto = nn_writebio * zdt
      clop = "inst("//TRIM(clop)//")"				      clop = "inst("//TRIM(clop)//")"
#        else							#        else
      zsto = zdt						      zsto = zdt
      clop = "ave("//TRIM(clop)//")"				      clop = "ave("//TRIM(clop)//")"
#        endif							#        endif
      zout = nn_writebio * zdt					      zout = nn_writebio * zdt

      ! Define indices of the horizontal output zoom and vert	      ! Define indices of the horizontal output zoom and vert
      iimi = 1      ;      iima = jpi				      iimi = 1      ;      iima = jpi
      ijmi = 1      ;      ijma = jpj				      ijmi = 1      ;      ijma = jpj
      ipk = jpk							      ipk = jpk

      ! define time axis					      ! define time axis
      itmod = kt - nittrc000 + 1				      itmod = kt - nittrc000 + 1
      it    = kt						      it    = kt
      iiter = ( nittrc000 - 1 ) / nn_dttrc			      iiter = ( nittrc000 - 1 ) / nn_dttrc

      ! Define NETCDF files and fields at beginning of first 	      ! Define NETCDF files and fields at beginning of first 
      ! -----------------------------------------------------	      ! -----------------------------------------------------

      IF(ll_print) WRITE(numout,*)'trcdib_wr kt=',kt		      IF(ll_print) WRITE(numout,*)'trcdib_wr kt=',kt

      IF( kt == nittrc000 ) THEN				      IF( kt == nittrc000 ) THEN

         ! Define the NETCDF files for biological trends	         ! Define the NETCDF files for biological trends

         CALL dia_nam(clhstnam,nn_writebio,'biolog')		         CALL dia_nam(clhstnam,nn_writebio,'biolog')
         IF(lwp)WRITE(numout,*) " Name of NETCDF file for bio	         IF(lwp)WRITE(numout,*) " Name of NETCDF file for bio
         ! Horizontal grid : glamt and gphit			         ! Horizontal grid : glamt and gphit
         CALL histbeg( clhstnam, jpi, glamt, jpj, gphit,     	         CALL histbeg( clhstnam, jpi, glamt, jpj, gphit,     
            &    iimi, iima-iimi+1, ijmi, ijma-ijmi+1,       	            &    iimi, iima-iimi+1, ijmi, ijma-ijmi+1,       
            &    iiter, zjulian, zdt, nhoritb, nitb , domain_	            &    iiter, zjulian, zdt, nhoritb, nitb , domain_
         ! Vertical grid for biological trends			         ! Vertical grid for biological trends
         CALL histvert(nitb, 'deptht', 'Vertical T levels', '	         CALL histvert(nitb, 'deptht', 'Vertical T levels', '

         ! Declare all the output fields as NETCDF variables	         ! Declare all the output fields as NETCDF variables
         ! biological trends					         ! biological trends
         DO jl = 1, jpdiabio					         DO jl = 1, jpdiabio
            cltra  = TRIM( ctrbio(jl) )   ! short title for b	            cltra  = TRIM( ctrbio(jl) )   ! short title for b
            cltral = TRIM( ctrbil(jl) )  ! long title for bio	            cltral = TRIM( ctrbil(jl) )  ! long title for bio
            cltrau = TRIM( ctrbiu(jl) )  ! UNIT for biologica	            cltrau = TRIM( ctrbiu(jl) )  ! UNIT for biologica
            CALL histdef( nitb, cltra, cltral, cltrau, jpi, j	            CALL histdef( nitb, cltra, cltral, cltrau, jpi, j
               &         ipk, 1, ipk,  ndepitb, 32, clop, zst	               &         ipk, 1, ipk,  ndepitb, 32, clop, zst
         END DO							         END DO

         ! CLOSE netcdf Files					         ! CLOSE netcdf Files
          CALL histend( nitb, snc4set )				          CALL histend( nitb, snc4set )

         IF(lwp) WRITE(numout,*)				         IF(lwp) WRITE(numout,*)
         IF(lwp) WRITE(numout,*) 'End of NetCDF Initializatio	         IF(lwp) WRITE(numout,*) 'End of NetCDF Initializatio
         IF(ll_print) CALL FLUSH(numout )			         IF(ll_print) CALL FLUSH(numout )
         !							         !
      ENDIF							      ENDIF

      ! Start writing data					      ! Start writing data
      ! ------------------					      ! ------------------

      ! biological trends					      ! biological trends
      IF( lwp .AND. MOD( itmod, nn_writebio ) == 0 ) THEN	      IF( lwp .AND. MOD( itmod, nn_writebio ) == 0 ) THEN
         WRITE(numout,*) 'trcdit_wr : write NetCDF biological	         WRITE(numout,*) 'trcdit_wr : write NetCDF biological
         WRITE(numout,*) '~~~~~~ '				         WRITE(numout,*) '~~~~~~ '
      ENDIF							      ENDIF

      DO jl = 1, jpdiabio					      DO jl = 1, jpdiabio
         cltra  = TRIM( ctrbio(jl) )   ! short title for biol	         cltra  = TRIM( ctrbio(jl) )   ! short title for biol
         CALL histwrite(nitb, cltra, it, trbio(:,:,:,jl), ndi	         CALL histwrite(nitb, cltra, it, trbio(:,:,:,jl), ndi
      END DO							      END DO

      ! Closing all files					      ! Closing all files
      ! -----------------					      ! -----------------
      IF( kt == nitend )   CALL histclo( nitb )			      IF( kt == nitend )   CALL histclo( nitb )
      !								      !
   END SUBROUTINE trcdib_wr					   END SUBROUTINE trcdib_wr

#else								#else
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!  Dummy module :                                     No 	   !!  Dummy module :                                     No 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS
   SUBROUTINE trc_dia( kt )                      ! Empty rout	   SUBROUTINE trc_dia( kt )                      ! Empty rout
      INTEGER, INTENT(in) :: kt					      INTEGER, INTENT(in) :: kt
   END SUBROUTINE trc_dia   					   END SUBROUTINE trc_dia   
#endif								#endif

   !!========================================================	   !!========================================================
END MODULE trcdia						END MODULE trcdia
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/trcdta.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/trcdta.F90
MODULE trcdta							MODULE trcdta
   !!========================================================	   !!========================================================
   !!                     ***  MODULE  trcdta  ***		   !!                     ***  MODULE  trcdta  ***
   !! TOP :  reads passive tracer data 				   !! TOP :  reads passive tracer data 
   !!========================================================	   !!========================================================
   !! History :   1.0  !  2002-04  (O. Aumont)  original code	   !! History :   1.0  !  2002-04  (O. Aumont)  original code
   !!              -   !  2004-03  (C. Ethe)  module		   !!              -   !  2004-03  (C. Ethe)  module
   !!              -   !  2005-03  (O. Aumont, A. El Moussaou	   !!              -   !  2005-03  (O. Aumont, A. El Moussaou
   !!            3.4   !  2010-11  (C. Ethe, G. Madec)  use o	   !!            3.4   !  2010-11  (C. Ethe, G. Madec)  use o
   !!            3.5   !  2013-08  (M. Vichi)  generalization	   !!            3.5   !  2013-08  (M. Vichi)  generalization
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#if  defined key_top 						#if  defined key_top 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   'key_top'                                            	   !!   'key_top'                                            
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   trc_dta    : read and time interpolated passive trace	   !!   trc_dta    : read and time interpolated passive trace
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   USE par_trc       !  passive tracers parameters		   USE par_trc       !  passive tracers parameters
   USE oce_trc       !  shared variables between ocean and pa	   USE oce_trc       !  shared variables between ocean and pa
   USE trc           !  passive tracers common variables	   USE trc           !  passive tracers common variables
   USE iom           !  I/O manager				   USE iom           !  I/O manager
   USE lib_mpp       !  MPP library				   USE lib_mpp       !  MPP library
   USE fldread       !  read input fields			   USE fldread       !  read input fields

   IMPLICIT NONE						   IMPLICIT NONE
   PRIVATE							   PRIVATE

   PUBLIC   trc_dta         ! called in trcini.F90 and trcdmp	   PUBLIC   trc_dta         ! called in trcini.F90 and trcdmp
   PUBLIC   trc_dta_init    ! called in trcini.F90 		   PUBLIC   trc_dta_init    ! called in trcini.F90 

   INTEGER  , SAVE, PUBLIC                             :: nb_	   INTEGER  , SAVE, PUBLIC                             :: nb_
   INTEGER  , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: n_t	   INTEGER  , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: n_t
   INTEGER  , SAVE, PUBLIC                             :: ntr	   INTEGER  , SAVE, PUBLIC                             :: ntr
   REAL(wp) , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: rf_	   REAL(wp) , SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: rf_
!$AGRIF_DO_NOT_TREAT						!$AGRIF_DO_NOT_TREAT
   TYPE(FLD), SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: sf_	   TYPE(FLD), SAVE, PUBLIC, ALLOCATABLE, DIMENSION(:)  :: sf_
!$AGRIF_END_DO_NOT_TREAT					!$AGRIF_END_DO_NOT_TREAT
   !! * Substitutions						   !! * Substitutions
#  include "domzgr_substitute.h90"				#  include "domzgr_substitute.h90"
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/OPA 3.3 , NEMO Consortium (2010)			   !! NEMO/OPA 3.3 , NEMO Consortium (2010)
   !! $Id: trcdta.F90 8543 2017-09-19 10:27:07Z cetlod $      |	   !! $Id: trcdta.F90 5385 2015-06-09 13:50:42Z cetlod $ 
   !! Software governed by the CeCILL licence     (NEMOGCM/NE	   !! Software governed by the CeCILL licence     (NEMOGCM/NE
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS

   SUBROUTINE trc_dta_init(ntrc)				   SUBROUTINE trc_dta_init(ntrc)
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                   ***  ROUTINE trc_dta_init  ***	      !!                   ***  ROUTINE trc_dta_init  ***
      !!                    					      !!                    
      !! ** Purpose :   initialisation of passive tracer inpu	      !! ** Purpose :   initialisation of passive tracer inpu
      !! 							      !! 
      !! ** Method  : - Read namtsd namelist			      !! ** Method  : - Read namtsd namelist
      !!              - allocates passive tracer data structu	      !!              - allocates passive tracer data structu
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      INTEGER,INTENT(IN) :: ntrc                             	      INTEGER,INTENT(IN) :: ntrc                             
      INTEGER            :: jl, jn                           	      INTEGER            :: jl, jn                           
      INTEGER            :: ierr0, ierr1, ierr2, ierr3       	      INTEGER            :: ierr0, ierr1, ierr2, ierr3       
      INTEGER            :: ios                              	      INTEGER            :: ios                              
      CHARACTER(len=100) :: clndta, clntrc			      CHARACTER(len=100) :: clndta, clntrc
      REAL(wp)           :: zfact				      REAL(wp)           :: zfact
      !								      !
      CHARACTER(len=100)            :: cn_dir			      CHARACTER(len=100)            :: cn_dir
      TYPE(FLD_N), ALLOCATABLE, DIMENSION(:) :: slf_i ! array	      TYPE(FLD_N), ALLOCATABLE, DIMENSION(:) :: slf_i ! array
      TYPE(FLD_N), DIMENSION(jpmaxtrc) :: sn_trcdta		      TYPE(FLD_N), DIMENSION(jpmaxtrc) :: sn_trcdta
      REAL(wp)   , DIMENSION(jpmaxtrc) :: rn_trfac    ! multi	      REAL(wp)   , DIMENSION(jpmaxtrc) :: rn_trfac    ! multi
      !!							      !!
      NAMELIST/namtrc_dta/ sn_trcdta, cn_dir, rn_trfac 		      NAMELIST/namtrc_dta/ sn_trcdta, cn_dir, rn_trfac 
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      IF( nn_timing == 1 )  CALL timing_start('trc_dta_init')	      IF( nn_timing == 1 )  CALL timing_start('trc_dta_init')
      !								      !
      !  Initialisation						      !  Initialisation
      ierr0 = 0  ;  ierr1 = 0  ;  ierr2 = 0  ;  ierr3 = 0  	      ierr0 = 0  ;  ierr1 = 0  ;  ierr2 = 0  ;  ierr3 = 0  
      ! Compute the number of tracers to be initialised with 	      ! Compute the number of tracers to be initialised with 
      ALLOCATE( n_trc_index(ntrc), slf_i(ntrc), STAT=ierr0 )	      ALLOCATE( n_trc_index(ntrc), slf_i(ntrc), STAT=ierr0 )
      IF( ierr0 > 0 ) THEN					      IF( ierr0 > 0 ) THEN
         CALL ctl_stop( 'trc_dta_init: unable to allocate n_t |	         CALL ctl_stop( 'trc_nam: unable to allocate n_trc_in
      ENDIF							      ENDIF
      nb_trcdta      = 0					      nb_trcdta      = 0
      n_trc_index(:) = 0					      n_trc_index(:) = 0
      DO jn = 1, ntrc						      DO jn = 1, ntrc
         IF( ln_trc_ini(jn) ) THEN				         IF( ln_trc_ini(jn) ) THEN
             nb_trcdta       = nb_trcdta + 1 			             nb_trcdta       = nb_trcdta + 1 
             n_trc_index(jn) = nb_trcdta 			             n_trc_index(jn) = nb_trcdta 
         ENDIF							         ENDIF
      ENDDO							      ENDDO
      !								      !
      ntra = MAX( 1, nb_trcdta )   ! To avoid compilation err	      ntra = MAX( 1, nb_trcdta )   ! To avoid compilation err
      IF(lwp) THEN						      IF(lwp) THEN
         WRITE(numout,*) ' '					         WRITE(numout,*) ' '
         WRITE(numout,*) 'trc_dta_init : Passive tracers Init <
         WRITE(numout,*) '~~~~~~~~~~~~~~ '		      <
         WRITE(numout,*) ' number of passive tracers to be in	         WRITE(numout,*) ' number of passive tracers to be in
         WRITE(numout,*) ' '					         WRITE(numout,*) ' '
      ENDIF							      ENDIF
      !								      !
      REWIND( numnat_ref )              ! Namelist namtrc_dta	      REWIND( numnat_ref )              ! Namelist namtrc_dta
      READ  ( numnat_ref, namtrc_dta, IOSTAT = ios, ERR = 901	      READ  ( numnat_ref, namtrc_dta, IOSTAT = ios, ERR = 901
901   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_dta in refe	901   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_dta in refe

      REWIND( numnat_cfg )              ! Namelist namtrc_dta	      REWIND( numnat_cfg )              ! Namelist namtrc_dta
      READ  ( numnat_cfg, namtrc_dta, IOSTAT = ios, ERR = 902	      READ  ( numnat_cfg, namtrc_dta, IOSTAT = ios, ERR = 902
902   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_dta in conf	902   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_dta in conf
      IF(lwm) WRITE ( numont, namtrc_dta )			      IF(lwm) WRITE ( numont, namtrc_dta )

      IF( lwp ) THEN						      IF( lwp ) THEN
         DO jn = 1, ntrc					         DO jn = 1, ntrc
            IF( ln_trc_ini(jn) )  THEN    ! open input file o	            IF( ln_trc_ini(jn) )  THEN    ! open input file o
               clndta = TRIM( sn_trcdta(jn)%clvar )		               clndta = TRIM( sn_trcdta(jn)%clvar ) 
               if (jn > jptra) then			      <
                  clntrc='Dummy' ! By pass weird formats in o <
               else					      <
                  clntrc = TRIM( ctrcnm   (jn)       )		               clntrc = TRIM( ctrcnm   (jn)       ) 
               endif					      <
               zfact  = rn_trfac(jn)				               zfact  = rn_trfac(jn)
               IF( clndta /=  clntrc ) THEN			               IF( clndta /=  clntrc ) THEN 
                  CALL ctl_warn( 'trc_dta_init: passive trace |	                  CALL ctl_warn( 'trc_dta_init: passive trace
                  &              'Input name of data file : ' |	                  &              'the variable name in the da
                  &              ' differs from that of trace |	                  &              '  must be the same than the
               ENDIF						               ENDIF
               WRITE(numout,'(a, i4,3a,e11.3)') ' Read IC fil |	               WRITE(numout,*) ' read an initial file for pas
               &            jn, ', name : ', TRIM(clndta), ', |	               &               ' multiplicative factor : ', z
            ENDIF						            ENDIF
         END DO							         END DO
      ENDIF							      ENDIF
      !								      !
      IF( nb_trcdta > 0 ) THEN       !  allocate only if the 	      IF( nb_trcdta > 0 ) THEN       !  allocate only if the 
         ALLOCATE( sf_trcdta(nb_trcdta), rf_trfac(nb_trcdta),	         ALLOCATE( sf_trcdta(nb_trcdta), rf_trfac(nb_trcdta),
         IF( ierr1 > 0 ) THEN					         IF( ierr1 > 0 ) THEN
            CALL ctl_stop( 'trc_dta_init: unable to allocate  |	            CALL ctl_stop( 'trc_dta_ini: unable to allocate  
         ENDIF							         ENDIF
         !							         !
         DO jn = 1, ntrc					         DO jn = 1, ntrc
            IF( ln_trc_ini(jn) ) THEN      ! update passive t	            IF( ln_trc_ini(jn) ) THEN      ! update passive t
               jl = n_trc_index(jn)				               jl = n_trc_index(jn)
               slf_i(jl)    = sn_trcdta(jn)			               slf_i(jl)    = sn_trcdta(jn)
               rf_trfac(jl) = rn_trfac(jn)			               rf_trfac(jl) = rn_trfac(jn)
                                            ALLOCATE( sf_trcd	                                            ALLOCATE( sf_trcd
               IF( sn_trcdta(jn)%ln_tint )  ALLOCATE( sf_trcd	               IF( sn_trcdta(jn)%ln_tint )  ALLOCATE( sf_trcd
               IF( ierr2 + ierr3 > 0 ) THEN			               IF( ierr2 + ierr3 > 0 ) THEN
                 CALL ctl_stop( 'trc_dta_init : unable to all |	                 CALL ctl_stop( 'trc_dta : unable to allocate
               ENDIF						               ENDIF
            ENDIF						            ENDIF
            !   						            !   
         ENDDO							         ENDDO
         !                         ! fill sf_trcdta with slf_	         !                         ! fill sf_trcdta with slf_
         CALL fld_fill( sf_trcdta, slf_i, cn_dir, 'trc_dta_in |	         CALL fld_fill( sf_trcdta, slf_i, cn_dir, 'trc_dta', 
         !							         !
      ENDIF							      ENDIF
      !								      !
      DEALLOCATE( slf_i )          ! deallocate local field s	      DEALLOCATE( slf_i )          ! deallocate local field s
      IF( nn_timing == 1 )  CALL timing_stop('trc_dta_init')	      IF( nn_timing == 1 )  CALL timing_stop('trc_dta_init')
      !								      !
   END SUBROUTINE trc_dta_init					   END SUBROUTINE trc_dta_init


   SUBROUTINE trc_dta( kt, sf_dta, ptrfac, ptrc)	      |	   SUBROUTINE trc_dta( kt, sf_dta, zrf_trfac )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                   ***  ROUTINE trc_dta  ***		      !!                   ***  ROUTINE trc_dta  ***
      !!                    					      !!                    
      !! ** Purpose :   provides passive tracer data at kt	      !! ** Purpose :   provides passive tracer data at kt
      !! 							      !! 
      !! ** Method  : - call fldread routine			      !! ** Method  : - call fldread routine
      !!              - s- or mixed z-s coordinate: vertical 	      !!              - s- or mixed z-s coordinate: vertical 
      !!              - ln_trcdmp=F: deallocates the data str	      !!              - ln_trcdmp=F: deallocates the data str
      !!							      !!
      !! ** Action  :   sf_dta   passive tracer data on medl 	      !! ** Action  :   sf_dta   passive tracer data on medl 
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER                     , INTENT(in   ) ::   kt    	      INTEGER                     , INTENT(in   ) ::   kt    
      TYPE(FLD), DIMENSION(1)     , INTENT(inout) ::   sf_dta	      TYPE(FLD), DIMENSION(1)   , INTENT(inout) ::   sf_dta  
      REAL(wp)                    , INTENT(in   ) ::   ptrfac |	      REAL(wp)                  , INTENT(in   ) ::   zrf_trfa
      REAL(wp), DIMENSION(jpi,jpj,jpk), OPTIONAL  , INTENT(ou <
      !								      !
      INTEGER ::   ji, jj, jk, jl, jkk, ik    ! dummy loop in	      INTEGER ::   ji, jj, jk, jl, jkk, ik    ! dummy loop in
      REAL(wp)::   zl, zi					      REAL(wp)::   zl, zi
      REAL(wp), DIMENSION(jpk) ::  ztp                ! 1D wo	      REAL(wp), DIMENSION(jpk) ::  ztp                ! 1D wo
      REAL(wp), POINTER, DIMENSION(:,:,:) ::  ztrcdta   ! 3D  <
      CHARACTER(len=100) :: clndta				      CHARACTER(len=100) :: clndta
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      IF( nn_timing == 1 )  CALL timing_start('trc_dta')	      IF( nn_timing == 1 )  CALL timing_start('trc_dta')
      !								      !
      IF( nb_trcdta > 0 ) THEN					      IF( nb_trcdta > 0 ) THEN
         !							         !
         CALL wrk_alloc( jpi, jpj, jpk, ztrcdta )    ! Memory <
         !						      <
         CALL fld_read( kt, 1, sf_dta )      !==   read data 	         CALL fld_read( kt, 1, sf_dta )      !==   read data 
         ztrcdta(:,:,:) = sf_dta(1)%fnow(:,:,:) * tmask(:,:,: <
         !							         !
         IF( ln_sco ) THEN                   !==   s- or mixe	         IF( ln_sco ) THEN                   !==   s- or mixe
            !							            !
            IF( kt == nit000 .AND. lwp )THEN			            IF( kt == nit000 .AND. lwp )THEN
               WRITE(numout,*)					               WRITE(numout,*)
               WRITE(numout,*) 'trc_dta: interpolates passive	               WRITE(numout,*) 'trc_dta: interpolates passive
            ENDIF						            ENDIF
            !							            !
            DO jj = 1, jpj                         ! vertical	               DO jj = 1, jpj                         ! verti
               DO ji = 1, jpi					                  DO ji = 1, jpi
                  DO jk = 1, jpk                        ! det	                     DO jk = 1, jpk                        ! 
                     zl = gdept_0(ji,jj,jk)		      |	                        zl = fsdept_n(ji,jj,jk)
                     IF(     zl < gdept_1d(1  ) ) THEN       	                        IF(     zl < gdept_1d(1  ) ) THEN    
                        ztp(jk) = ztrcdta(ji,jj,1)	      |	                           ztp(jk) =  sf_dta(1)%fnow(ji,jj,1)
                     ELSEIF( zl > gdept_1d(jpk) ) THEN       	                        ELSEIF( zl > gdept_1d(jpk) ) THEN    
                        ztp(jk) =  ztrcdta(ji,jj,jpkm1)	      |	                           ztp(jk) =  sf_dta(1)%fnow(ji,jj,jp
                     ELSE                                    	                        ELSE                                 
                        DO jkk = 1, jpkm1                    	                           DO jkk = 1, jpkm1                 
                           IF( (zl-gdept_1d(jkk)) * (zl-gdept	                              IF( (zl-gdept_1d(jkk)) * (zl-gd
                              zi = ( zl - gdept_1d(jkk) ) / (	                                 zi = ( zl - gdept_1d(jkk) ) 
                              ztp(jk) = ztrcdta(ji,jj,jkk) +  |	                                 ztp(jk) = sf_dta(1)%fnow(ji,
                                        ztrcdta(ji,jj,jkk) )  |	                                           sf_dta(1)%fnow(ji,
                           ENDIF				                              ENDIF
                        END DO					                           END DO
                     ENDIF					                        ENDIF
                  END DO					                     END DO
                  DO jk = 1, jpkm1				                     DO jk = 1, jpkm1
                    ztrcdta(ji,jj,jk) = ztp(jk) * tmask(ji,jj |	                        sf_dta(1)%fnow(ji,jj,jk) = ztp(jk) * 
                  END DO					                     END DO
                  ztrcdta(ji,jj,jpk) = 0._wp		      |	                     sf_dta(1)%fnow(ji,jj,jpk) = 0._wp
                END DO						                  END DO
            END DO						               END DO
            ! 							            ! 
         ELSE                                !==   z- or zps-	         ELSE                                !==   z- or zps-
            !							            !                             
							      >	               sf_dta(1)%fnow(:,:,:) = sf_dta(1)%fnow(:,:,:) 
							      >	               !
            IF( ln_zps ) THEN                      ! zps-coor	               IF( ln_zps ) THEN                      ! zps-c
               DO jj = 1, jpj					                  DO jj = 1, jpj
                  DO ji = 1, jpi				                     DO ji = 1, jpi
                     ik = mbkt(ji,jj) 				                        ik = mbkt(ji,jj) 
                     IF( ik > 1 ) THEN				                        IF( ik > 1 ) THEN
                        zl = ( gdept_1d(ik) - gdept_0(ji,jj,i |	                           zl = ( gdept_1d(ik) - fsdept_n(ji,
                        ztrcdta(ji,jj,ik) = (1.-zl) * ztrcdta |	                           sf_dta(1)%fnow(ji,jj,ik) = (1.-zl)
                     ENDIF					                        ENDIF
                     ik = mikt(ji,jj)				                        ik = mikt(ji,jj)
                     IF( ik > 1 ) THEN				                        IF( ik > 1 ) THEN
                        zl = ( gdept_0(ji,jj,ik) - gdept_1d(i	                           zl = ( gdept_0(ji,jj,ik) - gdept_1
                        ztrcdta(ji,jj,ik) = (1.-zl) * ztrcdta |	                           sf_dta(1)%fnow(ji,jj,ik) = (1.-zl)
                     ENDIF					                        ENDIF
                  END DO					                     END DO
               END DO						                  END DO
            ENDIF						               ENDIF
            !							            !
         ENDIF							         ENDIF
         !							         !
         ! Add multiplicative factor			      |	         sf_dta(1)%fnow(:,:,:) = sf_dta(1)%fnow(:,:,:) * zrf_
         ztrcdta(:,:,:) = ztrcdta(:,:,:) * ptrfac	      <
         !						      <
         ! Data structure for trc_ini (and BFMv5.1 coupling)  <
         IF( .NOT. PRESENT(ptrc) ) sf_dta(1)%fnow(:,:,:) = zt <
         !						      <
         ! Data structure for trc_dmp			      <
         IF( PRESENT(ptrc) )  ptrc(:,:,:) = ztrcdta(:,:,:)    <
         !							         !
         IF( lwp .AND. kt == nit000 ) THEN			         IF( lwp .AND. kt == nit000 ) THEN
               clndta = TRIM( sf_dta(1)%clvar ) 		               clndta = TRIM( sf_dta(1)%clvar ) 
               WRITE(numout,*) ''//clndta//' data '		               WRITE(numout,*) ''//clndta//' data '
               WRITE(numout,*)					               WRITE(numout,*)
               WRITE(numout,*)'  level = 1'			               WRITE(numout,*)'  level = 1'
               CALL prihre( ztrcdta(:,:,1), jpi, jpj, 1, jpi, |	               CALL prihre( sf_dta(1)%fnow(:,:,1), jpi, jpj, 
               WRITE(numout,*)'  level = ', jpk/2		               WRITE(numout,*)'  level = ', jpk/2
               CALL prihre( ztrcdta(:,:,jpk/2), jpi, jpj, 1,  |	               CALL prihre( sf_dta(1)%fnow(:,:,jpk/2), jpi, j
               WRITE(numout,*)'  level = ', jpkm1		               WRITE(numout,*)'  level = ', jpkm1
               CALL prihre( ztrcdta(:,:,jpkm1), jpi, jpj, 1,  |	               CALL prihre( sf_dta(1)%fnow(:,:,jpkm1), jpi, j
               WRITE(numout,*)					               WRITE(numout,*)
         ENDIF							         ENDIF
         !						      <
         CALL wrk_dealloc( jpi, jpj, jpk, ztrcdta )	      <
         !						      <
      ENDIF							      ENDIF
      !								      !
      IF( nn_timing == 1 )  CALL timing_stop('trc_dta')		      IF( nn_timing == 1 )  CALL timing_stop('trc_dta')
      !								      !
   END SUBROUTINE trc_dta					   END SUBROUTINE trc_dta
#else								#else
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   Dummy module                              NO 3D passi	   !!   Dummy module                              NO 3D passi
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS
   SUBROUTINE trc_dta( kt, sf_dta, ptrfac, ptrc)        ! Emp |	   SUBROUTINE trc_dta( kt, sf_dta, zrf_trfac )        ! Empty
      WRITE(*,*) 'trc_dta: You should not have seen this prin	      WRITE(*,*) 'trc_dta: You should not have seen this prin
   END SUBROUTINE trc_dta					   END SUBROUTINE trc_dta
#endif								#endif
   !!========================================================	   !!========================================================
END MODULE trcdta						END MODULE trcdta
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/trcice.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/trcice.F90
MODULE trcice							MODULE trcice
   !!========================================================	   !!========================================================
   !!                         ***  MODULE trcice  ***		   !!                         ***  MODULE trcice  ***
   !! TOP :   Manage the communication between TOP and sea ic	   !! TOP :   Manage the communication between TOP and sea ic
   !!========================================================	   !!========================================================
   !! History :  3.5  ! 2013    (M. Vancoppenolle, O. Aumont,	   !! History :  3.5  ! 2013    (M. Vancoppenolle, O. Aumont,
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#if defined key_top						#if defined key_top
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   'key_top'                                            	   !!   'key_top'                                            
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   trc_ice   :  Call the appropriate sea ice tracer subr	   !!   trc_ice   :  Call the appropriate sea ice tracer subr
   !!--------------------------------------------------------	   !!--------------------------------------------------------

   USE oce_trc         ! shared variables between ocean and p	   USE oce_trc         ! shared variables between ocean and p
   USE trc             ! passive tracers common variables	   USE trc             ! passive tracers common variables
   USE trcice_cfc      ! CFC      initialisation		   USE trcice_cfc      ! CFC      initialisation
   USE trcice_pisces   ! PISCES   initialisation		   USE trcice_pisces   ! PISCES   initialisation
   USE trcice_c14b     ! C14 bomb initialisation		   USE trcice_c14b     ! C14 bomb initialisation
   USE trcice_my_trc   ! MY_TRC   initialisation		   USE trcice_my_trc   ! MY_TRC   initialisation
   								   
   IMPLICIT NONE						   IMPLICIT NONE
   PRIVATE							   PRIVATE
   								   
   PUBLIC   trc_ice_ini ! called by trc_nam			   PUBLIC   trc_ice_ini ! called by trc_nam

CONTAINS							CONTAINS
   								   
   SUBROUTINE trc_ice_ini					   SUBROUTINE trc_ice_ini
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trc_ice_ini ***	      !!                     ***  ROUTINE trc_ice_ini ***
      !!							      !!
      !! ** Purpose :   Initialization of the ice module for 	      !! ** Purpose :   Initialization of the ice module for 
      !!							      !!
      !! ** Method  : - 					      !! ** Method  : - 
      !!            						      !!            
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      ! --- Variable declarations --- !				      ! --- Variable declarations --- !

      IF(lwp) THEN						      IF(lwp) THEN
         WRITE(numout,*)					         WRITE(numout,*)
         WRITE(numout,*) 'trc_ice_ini : Initialize sea ice tr	         WRITE(numout,*) 'trc_ice_ini : Initialize sea ice tr
         WRITE(numout,*) '~~~~~~~~~~~~~'			         WRITE(numout,*) '~~~~~~~~~~~~~'
      ENDIF							      ENDIF

      IF( nn_timing == 1 )  CALL timing_start('trc_ice_ini')	      IF( nn_timing == 1 )  CALL timing_start('trc_ice_ini')

      !								      !
      trc_i(:,:,:) = 0.0d0 ! by default				      trc_i(:,:,:) = 0.0d0 ! by default
      trc_o(:,:,:) = 0.0d0 ! by default				      trc_o(:,:,:) = 0.0d0 ! by default

      IF ( nn_ice_tr == 1 ) THEN				      IF ( nn_ice_tr == 1 ) THEN
         IF( lk_pisces  )    CALL trc_ice_ini_pisces       ! 	         IF( lk_pisces  )    CALL trc_ice_ini_pisces       ! 
         IF( lk_my_trc  )    CALL trc_ice_ini_my_trc       !  <
         IF( lk_cfc     )    CALL trc_ice_ini_cfc          ! 	         IF( lk_cfc     )    CALL trc_ice_ini_cfc          ! 
         IF( lk_c14b    )    CALL trc_ice_ini_c14b         ! 	         IF( lk_c14b    )    CALL trc_ice_ini_c14b         ! 
							      >	         IF( lk_my_trc  )    CALL trc_ice_ini_my_trc       ! 
      ENDIF							      ENDIF

      IF( nn_timing == 1 )   CALL timing_stop('trc_ice_ini')	      IF( nn_timing == 1 )   CALL timing_stop('trc_ice_ini')
      !								      !
   END SUBROUTINE trc_ice_ini					   END SUBROUTINE trc_ice_ini

#else								#else
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!  Empty module :                                     No 	   !!  Empty module :                                     No 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS
   SUBROUTINE trc_ice_ini                   ! Dummy routine  	   SUBROUTINE trc_ice_ini                   ! Dummy routine  
   END SUBROUTINE trc_ice_ini					   END SUBROUTINE trc_ice_ini
#endif								#endif

   !!========================================================	   !!========================================================
END MODULE trcice						END MODULE trcice
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/trcini.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/trcini.F90
MODULE trcini							MODULE trcini
   !!========================================================	   !!========================================================
   !!                         ***  MODULE trcini  ***		   !!                         ***  MODULE trcini  ***
   !! TOP :   Manage the passive tracer initialization		   !! TOP :   Manage the passive tracer initialization
   !!========================================================	   !!========================================================
   !! History :   -   ! 1991-03 (O. Marti)  original code	   !! History :   -   ! 1991-03 (O. Marti)  original code
   !!            1.0  ! 2005-03 (O. Aumont, A. El Moussaoui) 	   !!            1.0  ! 2005-03 (O. Aumont, A. El Moussaoui) 
   !!            2.0  ! 2005-10 (C. Ethe, G. Madec) revised a	   !!            2.0  ! 2005-10 (C. Ethe, G. Madec) revised a
   !!            4.0  ! 2011-01 (A. R. Porter, STFC Daresbury	   !!            4.0  ! 2011-01 (A. R. Porter, STFC Daresbury
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#if defined key_top						#if defined key_top
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   'key_top'                                            	   !!   'key_top'                                            
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   trc_init  :   Initialization for passive tracer		   !!   trc_init  :   Initialization for passive tracer
   !!   top_alloc :   allocate the TOP arrays			   !!   top_alloc :   allocate the TOP arrays
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   USE oce_trc         ! shared variables between ocean and p	   USE oce_trc         ! shared variables between ocean and p
   USE trc             ! passive tracers common variables	   USE trc             ! passive tracers common variables
   USE trcrst          ! passive tracers restart		   USE trcrst          ! passive tracers restart
   USE trcnam          ! Namelist read				   USE trcnam          ! Namelist read
   USE trcini_cfc      ! CFC      initialisation		   USE trcini_cfc      ! CFC      initialisation
   USE trcini_pisces   ! PISCES   initialisation		   USE trcini_pisces   ! PISCES   initialisation
							      >	   USE trcini_cmoc   ! CMOC   initialisation
							      >	   USE trcini_canoe   ! canoe   initialisation
   USE trcini_c14b     ! C14 bomb initialisation		   USE trcini_c14b     ! C14 bomb initialisation
   USE trcini_age      ! AGE      initialisation	      <
   USE trcini_my_trc   ! MY_TRC   initialisation		   USE trcini_my_trc   ! MY_TRC   initialisation
   USE trcdta          ! initialisation from files		   USE trcdta          ! initialisation from files
   USE daymod          ! calendar manager			   USE daymod          ! calendar manager
							      >	   USE zpshde          ! partial step: hor. derivative   (zps
   USE prtctl_trc      ! Print control passive tracers (prt_c	   USE prtctl_trc      ! Print control passive tracers (prt_c
   USE trcsub          ! variables to substep passive tracers	   USE trcsub          ! variables to substep passive tracers
   USE lib_mpp         ! distribued memory computing library	   USE lib_mpp         ! distribued memory computing library
   USE sbc_oce							   USE sbc_oce
   USE trcice          ! tracers in sea ice			   USE trcice          ! tracers in sea ice
 							      |	 !! From Elise 20170316-------------------------written by xi
							      >	 USE trcbc,   only : trc_bc_init ! generalized Boundary Condi
							      >	 !!---------------------------------XIAOFANLuo
   IMPLICIT NONE						   IMPLICIT NONE
   PRIVATE							   PRIVATE
   								   
   PUBLIC   trc_init   ! called by opa				   PUBLIC   trc_init   ! called by opa

    !! * Substitutions						    !! * Substitutions
#  include "domzgr_substitute.h90"				#  include "domzgr_substitute.h90"
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/TOP 4.0 , NEMO Consortium (2011)			   !! NEMO/TOP 4.0 , NEMO Consortium (2011)
   !! $Id: trcini.F90 8353 2017-07-19 14:41:00Z lovato $      |	   !! $Id: trcini.F90 5407 2015-06-11 19:13:22Z smasson $ 
   !! Software governed by the CeCILL licence     (NEMOGCM/NE	   !! Software governed by the CeCILL licence     (NEMOGCM/NE
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS
   								   
   SUBROUTINE trc_init						   SUBROUTINE trc_init
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trc_init  ***		      !!                     ***  ROUTINE trc_init  ***
      !!							      !!
      !! ** Purpose :   Initialization of the passive tracer 	      !! ** Purpose :   Initialization of the passive tracer 
      !!							      !!
      !! ** Method  : - read namelist				      !! ** Method  : - read namelist
      !!              - control the consistancy 		      !!              - control the consistancy 
      !!              - compute specific initialisations	      !!              - compute specific initialisations
      !!              - set initial tracer fields (either rea	      !!              - set initial tracer fields (either rea
      !!                or read data or analytical formulatio	      !!                or read data or analytical formulatio
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER ::   jk, jn, jl    ! dummy loop indices		      INTEGER ::   jk, jn, jl    ! dummy loop indices
      CHARACTER (len=25) :: charout				      CHARACTER (len=25) :: charout
							      >	      REAL(wp), POINTER, DIMENSION(:,:,:) ::  ztrcdta   ! 4D 
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      IF( nn_timing == 1 )   CALL timing_start('trc_init')	      IF( nn_timing == 1 )   CALL timing_start('trc_init')
      !								      !
      IF(lwp) WRITE(numout,*)					      IF(lwp) WRITE(numout,*)
      IF(lwp) WRITE(numout,*) 'trc_init : initial set up of t	      IF(lwp) WRITE(numout,*) 'trc_init : initial set up of t
      IF(lwp) WRITE(numout,*) '~~~~~~~'				      IF(lwp) WRITE(numout,*) '~~~~~~~'

      CALL top_alloc()              ! allocate TOP arrays	      CALL top_alloc()              ! allocate TOP arrays

      l_trcdm2dc = ln_dm2dc .OR. ( ln_cpl .AND. ncpl_qsr_freq	      l_trcdm2dc = ln_dm2dc .OR. ( ln_cpl .AND. ncpl_qsr_freq
      l_trcdm2dc = l_trcdm2dc  .AND. .NOT. lk_offline		      l_trcdm2dc = l_trcdm2dc  .AND. .NOT. lk_offline
      IF( l_trcdm2dc .AND. lwp ) &				      IF( l_trcdm2dc .AND. lwp ) &
         &   CALL ctl_warn(' Coupling with passive tracers an	         &   CALL ctl_warn(' Coupling with passive tracers an
         & Computation of a daily mean shortwave for some bio	         & Computation of a daily mean shortwave for some bio

      IF( nn_cla == 1 )   &					      IF( nn_cla == 1 )   &
         &  CALL ctl_stop( ' Cross Land Advection not yet imp	         &  CALL ctl_stop( ' Cross Land Advection not yet imp

      CALL trc_nam      ! read passive tracers namelists	      CALL trc_nam      ! read passive tracers namelists
      !								      !
      IF(lwp) WRITE(numout,*)					      IF(lwp) WRITE(numout,*)
      !								      !
      IF( ln_rsttr .AND. .NOT. lk_offline ) CALL trc_rst_cal(	      IF( ln_rsttr .AND. .NOT. lk_offline ) CALL trc_rst_cal(
      !								      !
      IF(lwp) WRITE(numout,*)					      IF(lwp) WRITE(numout,*)
                                                             	                                                             
      !                                                      	      !                                                      
      DO jk = 1, jpk						      DO jk = 1, jpk
         cvol(:,:,jk) = e1e2t(:,:) * fse3t(:,:,jk) * tmask(:,	         cvol(:,:,jk) = e1e2t(:,:) * fse3t(:,:,jk) * tmask(:,
      END DO							      END DO
      IF( lk_degrad ) cvol(:,:,:) = cvol(:,:,:) * facvol(:,:,	      IF( lk_degrad ) cvol(:,:,:) = cvol(:,:,:) * facvol(:,:,
      !                                                      	      !                                                      
      areatot = glob_sum( cvol(:,:,:) )				      areatot = glob_sum( cvol(:,:,:) )

      IF( lk_pisces  )       CALL trc_ini_pisces       ! PISC	      IF( lk_pisces  )       CALL trc_ini_pisces       ! PISC
      IF( lk_my_trc  )       CALL trc_ini_my_trc       ! MY_T |	      IF( lk_canoe  )       CALL trc_ini_canoe       ! CanOE 
							      >	      IF( lk_cmoc  )         CALL trc_ini_cmoc       ! CMOC  
      IF( lk_cfc     )       CALL trc_ini_cfc          ! CFC 	      IF( lk_cfc     )       CALL trc_ini_cfc          ! CFC 
      IF( lk_c14b    )       CALL trc_ini_c14b         ! C14 	      IF( lk_c14b    )       CALL trc_ini_c14b         ! C14 
      IF( lk_age     )       CALL trc_ini_age          ! AGE  |	      IF( lk_my_trc  )       CALL trc_ini_my_trc       ! MY_T

      CALL trc_ice_ini                                 ! Trac	      CALL trc_ice_ini                                 ! Trac

      IF( lwp ) THEN						      IF( lwp ) THEN
         !							         !
         CALL ctl_opn( numstr, 'tracer.stat', 'REPLACE', 'FOR	         CALL ctl_opn( numstr, 'tracer.stat', 'REPLACE', 'FOR
         !							         !
      ENDIF							      ENDIF

      IF( ln_trcdta )      CALL trc_dta_init(jptra)		      IF( ln_trcdta )      CALL trc_dta_init(jptra)
							      |	   !! From Elise 20170316--------------------written xiaofanL
							      >	#if defined key_bdy
							      >	       ! Initialisation of tracers Boundary Conditions
							      >	       CALL trc_bc_init(jptra)
							      >	#endif
							      >	   !! --------------written by xiaofanLuo

      IF( ln_rsttr ) THEN					      IF( ln_rsttr ) THEN
        !							        !
        CALL trc_rst_read              ! restart from a file	        CALL trc_rst_read              ! restart from a file
        !							        !
      ELSE							      ELSE
        !							        !
        IF( ln_trcdta .AND. nb_trcdta > 0 ) THEN  ! Initialis	        IF( ln_trcdta .AND. nb_trcdta > 0 ) THEN  ! Initialis
            !							            !
							      >	            CALL wrk_alloc( jpi, jpj, jpk, ztrcdta )    ! Mem
							      >	            !
            DO jn = 1, jptra					            DO jn = 1, jptra
               IF( ln_trc_ini(jn) ) THEN      ! update passiv	               IF( ln_trc_ini(jn) ) THEN      ! update passiv
                  jl = n_trc_index(jn) 				                  jl = n_trc_index(jn) 
                  CALL trc_dta( nit000, sf_trcdta(jl), rf_trf |	                  CALL trc_dta( nit000, sf_trcdta(jl),rf_trfa
                  trn(:,:,:,jn) = sf_trcdta(jl)%fnow(:,:,:)   |	                  ztrcdta(:,:,:) = sf_trcdta(jl)%fnow(:,:,:)
							      >	                  trn(:,:,:,jn) = ztrcdta(:,:,:) * tmask(:,:,
                  IF( .NOT.ln_trcdmp .AND. .NOT.ln_trcdmp_clo	                  IF( .NOT.ln_trcdmp .AND. .NOT.ln_trcdmp_clo
                     !                                       	                     !                                       
                     IF(lwp) WRITE(numout,*) 'trc_dta: deallo	                     IF(lwp) WRITE(numout,*) 'trc_dta: deallo
                                                  DEALLOCATE(	                                                  DEALLOCATE(
                     IF( sf_trcdta(jl)%ln_tint )  DEALLOCATE(	                     IF( sf_trcdta(jl)%ln_tint )  DEALLOCATE(
                     !						                     !
                  ENDIF						                  ENDIF
               ENDIF						               ENDIF
            ENDDO						            ENDDO
            !						      |	            CALL wrk_dealloc( jpi, jpj, jpk, ztrcdta )
        ENDIF							        ENDIF
        !							        !
        trb(:,:,:,:) = trn(:,:,:,:)				        trb(:,:,:,:) = trn(:,:,:,:)
        ! 							        ! 
      ENDIF							      ENDIF
 								 
      tra(:,:,:,:) = 0._wp					      tra(:,:,:,:) = 0._wp
							      >	      IF( ln_zps .AND. .NOT. lk_c1d .AND. .NOT. ln_isfcav )  
							      >	        &    CALL zps_hde    ( nit000, jptra, trn, gtru, gtrv
							      >	      IF( ln_zps .AND. .NOT. lk_c1d .AND.       ln_isfcav )  
							      >	        &    CALL zps_hde_isf( nit000, jptra, trn, pgtu=gtru,
							      >
							      >
      !								      !
      IF( nn_dttrc /= 1 )        CALL trc_sub_ini      ! Init	      IF( nn_dttrc /= 1 )        CALL trc_sub_ini      ! Init
      !								      !

      trai(:) = 0._wp                                        	      trai(:) = 0._wp                                        
      DO jn = 1, jptra						      DO jn = 1, jptra
         trai(jn) = trai(jn) + glob_sum( trn(:,:,:,jn) * cvol	         trai(jn) = trai(jn) + glob_sum( trn(:,:,:,jn) * cvol
      END DO							      END DO

      IF(lwp) THEN               ! control print		      IF(lwp) THEN               ! control print
         WRITE(numout,*)					         WRITE(numout,*)
         WRITE(numout,*)					         WRITE(numout,*)
         WRITE(numout,*) '          *** Total number of passi	         WRITE(numout,*) '          *** Total number of passi
         WRITE(numout,*) '          *** Total volume of ocean	         WRITE(numout,*) '          *** Total volume of ocean
         WRITE(numout,*) '          *** Total inital content 	         WRITE(numout,*) '          *** Total inital content 
         WRITE(numout,*)					         WRITE(numout,*)
         DO jn = 1, jptra					         DO jn = 1, jptra
            WRITE(numout,9000) jn, TRIM( ctrcnm(jn) ), trai(j	            WRITE(numout,9000) jn, TRIM( ctrcnm(jn) ), trai(j
         ENDDO							         ENDDO
         WRITE(numout,*)					         WRITE(numout,*)
      ENDIF							      ENDIF
      IF(lwp) WRITE(numout,*)					      IF(lwp) WRITE(numout,*)
      IF(ln_ctl) THEN            ! print mean trends (used fo	      IF(ln_ctl) THEN            ! print mean trends (used fo
         CALL prt_ctl_trc_init					         CALL prt_ctl_trc_init
         WRITE(charout, FMT="('ini ')")				         WRITE(charout, FMT="('ini ')")
         CALL prt_ctl_trc_info( charout )			         CALL prt_ctl_trc_info( charout )
         CALL prt_ctl_trc( tab4d=trn, mask=tmask, clinfo=ctrc	         CALL prt_ctl_trc( tab4d=trn, mask=tmask, clinfo=ctrc
      ENDIF							      ENDIF
9000  FORMAT(' tracer nb : ',i2,'      name :',a10,'      ini	9000  FORMAT(' tracer nb : ',i2,'      name :',a10,'      ini
      !								      !
      IF( nn_timing == 1 )   CALL timing_stop('trc_init')	      IF( nn_timing == 1 )   CALL timing_stop('trc_init')
      !								      !
   END SUBROUTINE trc_init					   END SUBROUTINE trc_init


   SUBROUTINE top_alloc						   SUBROUTINE top_alloc
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE top_alloc  ***	      !!                     ***  ROUTINE top_alloc  ***
      !!							      !!
      !! ** Purpose :   Allocate all the dynamic arrays of th	      !! ** Purpose :   Allocate all the dynamic arrays of th
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      USE trcadv        , ONLY:   trc_adv_alloc          ! TO	      USE trcadv        , ONLY:   trc_adv_alloc          ! TO
      USE trc           , ONLY:   trc_alloc			      USE trc           , ONLY:   trc_alloc
      USE trcnxt        , ONLY:   trc_nxt_alloc			      USE trcnxt        , ONLY:   trc_nxt_alloc
      USE trczdf        , ONLY:   trc_zdf_alloc			      USE trczdf        , ONLY:   trc_zdf_alloc
      USE trdtrc_oce    , ONLY:   trd_trc_oce_alloc		      USE trdtrc_oce    , ONLY:   trd_trc_oce_alloc
#if defined key_trdmxl_trc 					#if defined key_trdmxl_trc 
      USE trdmxl_trc    , ONLY:   trd_mxl_trc_alloc		      USE trdmxl_trc    , ONLY:   trd_mxl_trc_alloc
#endif								#endif
      !								      !
      INTEGER :: ierr						      INTEGER :: ierr
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      ierr =        trc_adv_alloc()          ! Start of TOP-r	      ierr =        trc_adv_alloc()          ! Start of TOP-r
      ierr = ierr + trc_alloc    ()				      ierr = ierr + trc_alloc    ()
      ierr = ierr + trc_nxt_alloc()				      ierr = ierr + trc_nxt_alloc()
      ierr = ierr + trc_zdf_alloc()				      ierr = ierr + trc_zdf_alloc()
      ierr = ierr + trd_trc_oce_alloc()				      ierr = ierr + trd_trc_oce_alloc()
#if defined key_trdmxl_trc 					#if defined key_trdmxl_trc 
      ierr = ierr + trd_mxl_trc_alloc()				      ierr = ierr + trd_mxl_trc_alloc()
#endif								#endif
      !								      !
      IF( lk_mpp    )   CALL mpp_sum( ierr )			      IF( lk_mpp    )   CALL mpp_sum( ierr )
      IF( ierr /= 0 )   CALL ctl_stop( 'STOP', 'top_alloc : u	      IF( ierr /= 0 )   CALL ctl_stop( 'STOP', 'top_alloc : u
      !								      !
   END SUBROUTINE top_alloc					   END SUBROUTINE top_alloc

#else								#else
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!  Empty module :                                     No 	   !!  Empty module :                                     No 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS
   SUBROUTINE trc_init                      ! Dummy routine  	   SUBROUTINE trc_init                      ! Dummy routine  
   END SUBROUTINE trc_init					   END SUBROUTINE trc_init
#endif								#endif

   !!========================================================	   !!========================================================
END MODULE trcini						END MODULE trcini
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/trcnam.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/trcnam.F90
MODULE trcnam							MODULE trcnam
   !!========================================================	   !!========================================================
   !!                       ***  MODULE trcnam  ***		   !!                       ***  MODULE trcnam  ***
   !! TOP :   Read and print options for the passive tracer r	   !! TOP :   Read and print options for the passive tracer r
   !!========================================================	   !!========================================================
   !! History :    -   !  1996-11  (M.A. Foujols, M. Levy)  o	   !! History :    -   !  1996-11  (M.A. Foujols, M. Levy)  o
   !!              -   !  1998-04  (M.A Foujols, L. Bopp) aht	   !!              -   !  1998-04  (M.A Foujols, L. Bopp) aht
   !!              -   !  1999-10  (M.A. Foujols, M. Levy) se	   !!              -   !  1999-10  (M.A. Foujols, M. Levy) se
   !!              -   !  2000-07  (A. Estublier) add TVD and	   !!              -   !  2000-07  (A. Estublier) add TVD and
   !!              -   !  2000-11  (M.A Foujols, E Kestenare)	   !!              -   !  2000-11  (M.A Foujols, E Kestenare)
   !!              -   !  2001-01 (E Kestenare) suppress ndtt	   !!              -   !  2001-01 (E Kestenare) suppress ndtt
   !!             1.0  !  2005-03 (O. Aumont, A. El Moussaoui	   !!             1.0  !  2005-03 (O. Aumont, A. El Moussaoui
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#if defined key_top						#if defined key_top
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   'key_top'                                            	   !!   'key_top'                                            
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   trc_nam    :  Read and print options for the passive 	   !!   trc_nam    :  Read and print options for the passive 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   USE oce_trc           ! shared variables between ocean and	   USE oce_trc           ! shared variables between ocean and
   USE trc               ! passive tracers common variables	   USE trc               ! passive tracers common variables
   USE trcnam_trp        ! Transport namelist			   USE trcnam_trp        ! Transport namelist
   USE trcnam_pisces     ! PISCES namelist			   USE trcnam_pisces     ! PISCES namelist
							      >	   USE trcnam_canoe     ! CanOE namelist
							      >	   USE trcnam_cmoc     ! CMOC namelist
   USE trcnam_cfc        ! CFC SMS namelist			   USE trcnam_cfc        ! CFC SMS namelist
   USE trcnam_c14b       ! C14 SMS namelist			   USE trcnam_c14b       ! C14 SMS namelist
   USE trcnam_age        ! AGE SMS namelist		      <
   USE trcnam_my_trc     ! MY_TRC SMS namelist			   USE trcnam_my_trc     ! MY_TRC SMS namelist
   USE trd_oce       						   USE trd_oce       
   USE trdtrc_oce						   USE trdtrc_oce
   USE iom               ! I/O manager				   USE iom               ! I/O manager

   IMPLICIT NONE						   IMPLICIT NONE
   PRIVATE 							   PRIVATE 

   PUBLIC trc_nam_run  ! called in trcini			   PUBLIC trc_nam_run  ! called in trcini
   PUBLIC trc_nam      ! called in trcini			   PUBLIC trc_nam      ! called in trcini

   !! * Substitutions						   !! * Substitutions
#  include "top_substitute.h90"					#  include "top_substitute.h90"
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/TOP 3.3 , NEMO Consortium (2010)			   !! NEMO/TOP 3.3 , NEMO Consortium (2010)
   !! $Id: trcnam.F90 8353 2017-07-19 14:41:00Z lovato $      |	   !! $Id: trcnam.F90 5411 2015-06-12 17:39:14Z cetlod $
   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C	   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C
   !!--------------------------------------------------------	   !!--------------------------------------------------------

CONTAINS							CONTAINS


   SUBROUTINE trc_nam						   SUBROUTINE trc_nam
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trc_nam  ***		      !!                     ***  ROUTINE trc_nam  ***
      !!							      !!
      !! ** Purpose :   READ and PRINT options for the passiv	      !! ** Purpose :   READ and PRINT options for the passiv
      !!							      !!
      !! ** Method  : - read passive tracer namelist 		      !! ** Method  : - read passive tracer namelist 
      !!              - read namelist of each defined SMS mod	      !!              - read namelist of each defined SMS mod
      !!                ( (PISCES, CFC, MY_TRC )		      !!                ( (PISCES, CFC, MY_TRC )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER  ::   jn                  ! dummy loop indice	      INTEGER  ::   jn                  ! dummy loop indice
      !                                        !   Parameters	      !                                        !   Parameters
      IF( .NOT. lk_offline ) CALL trc_nam_run			      IF( .NOT. lk_offline ) CALL trc_nam_run
      								      
      !                                        !  passive tra	      !                                        !  passive tra
                             CALL trc_nam_trc			      CALL trc_nam_trc
      								      
      !                                        !   Parameters	      !                                        !   Parameters
      IF( .NOT. lk_iomput)   CALL trc_nam_dia		      |	      CALL trc_nam_dia

      !                                        !   namelist o	      !                                        !   namelist o
                             CALL trc_nam_trp			      CALL trc_nam_trp


      IF( ln_rsttr )                      ln_trcdta = .FALSE.	      IF( ln_rsttr )                      ln_trcdta = .FALSE.
      !								      !
      IF( ln_trcdmp .OR. ln_trcdmp_clo )  ln_trcdta = .TRUE. 	      IF( ln_trcdmp .OR. ln_trcdmp_clo )  ln_trcdta = .TRUE. 
      !								      !
      IF( .NOT.ln_trcdta ) THEN					      IF( .NOT.ln_trcdta ) THEN
         ln_trc_ini(:) = .FALSE.				         ln_trc_ini(:) = .FALSE.
      ENDIF							      ENDIF

      ! Call the ice module for tracers			      <
      ! -------------------------------			      <
      CALL trc_nam_ice					      <
							      <
      ! namelist of SMS					      <
      ! ---------------					      <
      IF( lk_pisces  ) THEN   ;   CALL trc_nam_pisces      !  <
      ELSE                    ;   IF(lwp) WRITE(numout,*) '   <
      ENDIF						      <
							      <
      IF( lk_my_trc  ) THEN  ;   CALL trc_nam_my_trc       !  <
      ELSE                   ;   IF(lwp) WRITE(numout,*)  '   <
      ENDIF						      <
							      <
      IF( lk_cfc     ) THEN   ;   CALL trc_nam_cfc         !  <
      ELSE                    ;   IF(lwp) WRITE(numout,*) '   <
      ENDIF						      <
							      <
      IF( lk_c14b    ) THEN  ;   CALL trc_nam_c14b         !  <
      ELSE                   ;   IF(lwp) WRITE(numout,*)  '   <
      ENDIF						      <
							      <
      IF( lk_age     ) THEN  ;   CALL trc_nam_age         ! A <
      ELSE                   ;   IF(lwp) WRITE(numout,*)  '   <
      ENDIF						      <
							      <
     IF(lwp) THEN                   ! control print		     IF(lwp) THEN                   ! control print
         WRITE(numout,*)					         WRITE(numout,*)
         WRITE(numout,*) ' Namelist : namtrc'			         WRITE(numout,*) ' Namelist : namtrc'
         WRITE(numout,*) '   Read inputs data from file (y/n)	         WRITE(numout,*) '   Read inputs data from file (y/n)
         WRITE(numout,*) '   Damping of passive tracer (y/n) 	         WRITE(numout,*) '   Damping of passive tracer (y/n) 
         WRITE(numout,*) '   Restoring of tracer on closed se	         WRITE(numout,*) '   Restoring of tracer on closed se
         WRITE(numout,*) ' '					         WRITE(numout,*) ' '
         DO jn = 1, jptra					         DO jn = 1, jptra
            WRITE(numout,*) '  tracer nb : ', jn, '    short 	            WRITE(numout,*) '  tracer nb : ', jn, '    short 
         END DO							         END DO
         WRITE(numout,*) ' '					         WRITE(numout,*) ' '
      ENDIF							      ENDIF

      IF(lwp) THEN                   ! control print		      IF(lwp) THEN                   ! control print
         IF( ln_rsttr ) THEN					         IF( ln_rsttr ) THEN
            WRITE(numout,*)					            WRITE(numout,*)
            WRITE(numout,*) '  Read a restart file for passiv	            WRITE(numout,*) '  Read a restart file for passiv
            WRITE(numout,*)					            WRITE(numout,*)
         ENDIF							         ENDIF
         IF( ln_trcdta .AND. .NOT.ln_rsttr ) THEN		         IF( ln_trcdta .AND. .NOT.ln_rsttr ) THEN
            WRITE(numout,*)					            WRITE(numout,*)
            WRITE(numout,*) '  Some of the passive tracers ar	            WRITE(numout,*) '  Some of the passive tracers ar
            WRITE(numout,*)					            WRITE(numout,*)
         ENDIF							         ENDIF
         IF( .NOT.ln_trcdta ) THEN				         IF( .NOT.ln_trcdta ) THEN
            WRITE(numout,*)					            WRITE(numout,*)
            WRITE(numout,*) '  All the passive tracers are in	            WRITE(numout,*) '  All the passive tracers are in
            WRITE(numout,*)					            WRITE(numout,*)
         ENDIF							         ENDIF
      ENDIF							      ENDIF

      								      
      rdttrc(:) = rdttra(:) * FLOAT( nn_dttrc )   ! vertical 	      rdttrc(:) = rdttra(:) * FLOAT( nn_dttrc )   ! vertical 
  								  
      IF(lwp) THEN                   ! control print		      IF(lwp) THEN                   ! control print
        WRITE(numout,*) 					        WRITE(numout,*) 
        WRITE(numout,*) '    Passive Tracer  time step    rdt	        WRITE(numout,*) '    Passive Tracer  time step    rdt
        WRITE(numout,*) 					        WRITE(numout,*) 
      ENDIF							      ENDIF

							      >
							      >	#if defined key_trdmxl_trc || defined key_trdtrc
							      >
							      >	         REWIND( numnat_ref )              ! Namelist namtrc_
							      >	         READ  ( numnat_ref, namtrc_trd, IOSTAT = ios, ERR = 
							      >	905      IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_trd in r
							      >
							      >	         REWIND( numnat_cfg )              ! Namelist namtrc_
							      >	         READ  ( numnat_cfg, namtrc_trd, IOSTAT = ios, ERR = 
							      >	906      IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_trd in c
							      >	         IF(lwm) WRITE ( numont, namtrc_trd )
							      >
							      >	         IF(lwp) THEN
							      >	            WRITE(numout,*)
							      >	            WRITE(numout,*) ' trd_mxl_trc_init : read namelis
							      >	            WRITE(numout,*) ' ~~~~~~~~~~~~~~~~               
							      >	            WRITE(numout,*) '   * frequency of trends diagnos
							      >	            WRITE(numout,*) '   * control surface type       
							      >	            WRITE(numout,*) '   * restart for ML diagnostics 
							      >	            WRITE(numout,*) '   * flag to diagnose trends of 
							      >	            WRITE(numout,*) '     instantantaneous or mean ML
							      >	            WRITE(numout,*) '   * unit conversion factor     
							      >	            DO jn = 1, jptra
							      >	               IF( ln_trdtrc(jn) ) WRITE(numout,*) '    compu
							      >	            END DO
							      >	         ENDIF
							      >	#endif
							      >
							      >
							      >	      ! Call the ice module for tracers
							      >	      ! -------------------------------
							      >	      CALL trc_nam_ice
							      >
							      >	      ! namelist of SMS
							      >	      ! ---------------      
							      >	      IF( lk_pisces  ) THEN   ;   CALL trc_nam_pisces      ! 
							      >	      ELSE                    ;   IF(lwp) WRITE(numout,*) '  
							      >	      ENDIF
							      >	      
							      >	      IF( lk_canoe  ) THEN   ;   CALL trc_nam_canoe      ! Ca
							      >	      ELSE                    ;   IF(lwp) WRITE(numout,*) '  
							      >	      ENDIF
							      >	      
							      >	      IF( lk_cmoc  ) THEN   ;   CALL trc_nam_cmoc      ! CMOC
							      >	      ELSE                    ;   IF(lwp) WRITE(numout,*) '  
							      >	      ENDIF
							      >
							      >	      IF( lk_cfc     ) THEN   ;   CALL trc_nam_cfc         ! 
							      >	      ELSE                    ;   IF(lwp) WRITE(numout,*) '  
							      >	      ENDIF
							      >
							      >	      IF( lk_c14b     ) THEN   ;   CALL trc_nam_c14b         
							      >	      ELSE                    ;   IF(lwp) WRITE(numout,*) '  
							      >	      ENDIF
							      >
							      >	      IF( lk_my_trc  ) THEN   ;   CALL trc_nam_my_trc      ! 
							      >	      ELSE                    ;   IF(lwp) WRITE(numout,*) '  
							      >	      ENDIF
      !								      !
   END SUBROUTINE trc_nam					   END SUBROUTINE trc_nam

   SUBROUTINE trc_nam_run					   SUBROUTINE trc_nam_run
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trc_nam  ***		      !!                     ***  ROUTINE trc_nam  ***
      !!							      !!
      !! ** Purpose :   read options for the passive tracer r	      !! ** Purpose :   read options for the passive tracer r
      !!							      !!
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      NAMELIST/namtrc_run/ nn_dttrc, nn_writetrc, ln_rsttr, n	      NAMELIST/namtrc_run/ nn_dttrc, nn_writetrc, ln_rsttr, n
        &                  cn_trcrst_indir, cn_trcrst_outdir,	        &                  cn_trcrst_indir, cn_trcrst_outdir,


      INTEGER  ::   ios                 ! Local integer outpu	      INTEGER  ::   ios                 ! Local integer outpu

      !!-----------------------------------------------------	      !!-----------------------------------------------------


      IF(lwp) WRITE(numout,*) 'trc_nam : read the passive tra	      IF(lwp) WRITE(numout,*) 'trc_nam : read the passive tra
      IF(lwp) WRITE(numout,*) '~~~~~~~'				      IF(lwp) WRITE(numout,*) '~~~~~~~'

      CALL ctl_opn( numnat_ref, 'namelist_top_ref'   , 'OLD' 	      CALL ctl_opn( numnat_ref, 'namelist_top_ref'   , 'OLD' 
      CALL ctl_opn( numnat_cfg, 'namelist_top_cfg'   , 'OLD' 	      CALL ctl_opn( numnat_cfg, 'namelist_top_cfg'   , 'OLD' 
      IF(lwm) CALL ctl_opn( numont, 'output.namelist.top', 'U	      IF(lwm) CALL ctl_opn( numont, 'output.namelist.top', 'U

      REWIND( numnat_ref )              ! Namelist namtrc in 	      REWIND( numnat_ref )              ! Namelist namtrc in 
      READ  ( numnat_ref, namtrc_run, IOSTAT = ios, ERR = 901	      READ  ( numnat_ref, namtrc_run, IOSTAT = ios, ERR = 901
901   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc in referenc	901   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc in referenc

      REWIND( numnat_cfg )              ! Namelist namtrc in 	      REWIND( numnat_cfg )              ! Namelist namtrc in 
      READ  ( numnat_cfg, namtrc_run, IOSTAT = ios, ERR = 902	      READ  ( numnat_cfg, namtrc_run, IOSTAT = ios, ERR = 902
902   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc in configur	902   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc in configur
      IF(lwm) WRITE ( numont, namtrc_run )			      IF(lwm) WRITE ( numont, namtrc_run )

      !  computes the first time step of tracer model		      !  computes the first time step of tracer model
      nittrc000 = nit000 + nn_dttrc - 1				      nittrc000 = nit000 + nn_dttrc - 1

      IF(lwp) THEN                   ! control print		      IF(lwp) THEN                   ! control print
         WRITE(numout,*)					         WRITE(numout,*)
         WRITE(numout,*) ' Namelist : namtrc_run'		         WRITE(numout,*) ' Namelist : namtrc_run'
         WRITE(numout,*) '   time step freq. for passive trac	         WRITE(numout,*) '   time step freq. for passive trac
         WRITE(numout,*) '   restart  for passive tracer     	         WRITE(numout,*) '   restart  for passive tracer     
         WRITE(numout,*) '   control of time step for passive	         WRITE(numout,*) '   control of time step for passive
         WRITE(numout,*) '   first time step for pass. trac. 	         WRITE(numout,*) '   first time step for pass. trac. 
         WRITE(numout,*) '   frequency of outputs for passive	         WRITE(numout,*) '   frequency of outputs for passive
         WRITE(numout,*) '   Use euler integration for TRC (y	         WRITE(numout,*) '   Use euler integration for TRC (y
         WRITE(numout,*) ' '					         WRITE(numout,*) ' '
      ENDIF							      ENDIF
      !								      !
    END SUBROUTINE trc_nam_run					    END SUBROUTINE trc_nam_run

   SUBROUTINE trc_nam_ice					   SUBROUTINE trc_nam_ice
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trc_nam_ice ***	      !!                     ***  ROUTINE trc_nam_ice ***
      !!							      !!
      !! ** Purpose :   Read the namelist for the ice effect 	      !! ** Purpose :   Read the namelist for the ice effect 
      !!							      !!
      !! ** Method  : -						      !! ** Method  : -
      !!							      !!
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      ! --- Variable declarations --- !				      ! --- Variable declarations --- !
      INTEGER :: jn      ! dummy loop indices			      INTEGER :: jn      ! dummy loop indices
      INTEGER :: ios     ! Local integer output status for na	      INTEGER :: ios     ! Local integer output status for na

      ! --- Namelist declarations --- !				      ! --- Namelist declarations --- !
      TYPE(TRC_I_NML), DIMENSION(jptra) :: sn_tri_tracer	      TYPE(TRC_I_NML), DIMENSION(jptra) :: sn_tri_tracer
      NAMELIST/namtrc_ice/ nn_ice_tr, sn_tri_tracer		      NAMELIST/namtrc_ice/ nn_ice_tr, sn_tri_tracer

      IF(lwp) THEN						      IF(lwp) THEN
         WRITE(numout,*)					         WRITE(numout,*)
         WRITE(numout,*) 'trc_nam_ice : Read the namelist for	         WRITE(numout,*) 'trc_nam_ice : Read the namelist for
         WRITE(numout,*) '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	         WRITE(numout,*) '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      ENDIF							      ENDIF

      IF( nn_timing == 1 )  CALL timing_start('trc_nam_ice')	      IF( nn_timing == 1 )  CALL timing_start('trc_nam_ice')

      !								      !
      REWIND( numnat_ref )              ! Namelist namtrc_ice	      REWIND( numnat_ref )              ! Namelist namtrc_ice
      READ  ( numnat_ref, namtrc_ice, IOSTAT = ios, ERR = 901	      READ  ( numnat_ref, namtrc_ice, IOSTAT = ios, ERR = 901
 901  IF( ios /= 0 ) CALL ctl_nam ( ios , ' namtrc_ice in ref	 901  IF( ios /= 0 ) CALL ctl_nam ( ios , ' namtrc_ice in ref

      REWIND( numnat_cfg )              ! Namelist namtrc_ice	      REWIND( numnat_cfg )              ! Namelist namtrc_ice
      READ  ( numnat_cfg, namtrc_ice, IOSTAT = ios, ERR = 902	      READ  ( numnat_cfg, namtrc_ice, IOSTAT = ios, ERR = 902
 902  IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_ice in conf	 902  IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_ice in conf

      IF( lwp ) THEN						      IF( lwp ) THEN
         WRITE(numout,*) ' '					         WRITE(numout,*) ' '
         WRITE(numout,*) ' Sea ice tracers option (nn_ice_tr)	         WRITE(numout,*) ' Sea ice tracers option (nn_ice_tr)
         WRITE(numout,*) ' '					         WRITE(numout,*) ' '
      ENDIF							      ENDIF

      ! Assign namelist stuff					      ! Assign namelist stuff
      DO jn = 1, jptra						      DO jn = 1, jptra
         trc_ice_ratio(jn)  = sn_tri_tracer(jn)%trc_ratio	         trc_ice_ratio(jn)  = sn_tri_tracer(jn)%trc_ratio
         trc_ice_prescr(jn) = sn_tri_tracer(jn)%trc_prescr	         trc_ice_prescr(jn) = sn_tri_tracer(jn)%trc_prescr
         cn_trc_o      (jn) = sn_tri_tracer(jn)%ctrc_o		         cn_trc_o      (jn) = sn_tri_tracer(jn)%ctrc_o
      END DO							      END DO

      IF( nn_timing == 1 )   CALL timing_stop('trc_nam_ice')	      IF( nn_timing == 1 )   CALL timing_stop('trc_nam_ice')
      !								      !
   END SUBROUTINE trc_nam_ice					   END SUBROUTINE trc_nam_ice

   SUBROUTINE trc_nam_trc					   SUBROUTINE trc_nam_trc
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trc_nam  ***		      !!                     ***  ROUTINE trc_nam  ***
      !!							      !!
      !! ** Purpose :   read options for the passive tracer r	      !! ** Purpose :   read options for the passive tracer r
      !!							      !!
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      TYPE(PTRACER), DIMENSION(jptra) :: sn_tracer  ! type of	      TYPE(PTRACER), DIMENSION(jptra) :: sn_tracer  ! type of
      !!							      !!
      NAMELIST/namtrc/ sn_tracer, ln_trcdta,ln_trcdmp, ln_trc	      NAMELIST/namtrc/ sn_tracer, ln_trcdta,ln_trcdmp, ln_trc
  								  
      INTEGER  ::   ios                 ! Local integer outpu	      INTEGER  ::   ios                 ! Local integer outpu
      INTEGER  ::   jn                  ! dummy loop indice	      INTEGER  ::   jn                  ! dummy loop indice
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      IF(lwp) WRITE(numout,*)					      IF(lwp) WRITE(numout,*)
      IF(lwp) WRITE(numout,*) 'trc_nam : read the passive tra	      IF(lwp) WRITE(numout,*) 'trc_nam : read the passive tra
      IF(lwp) WRITE(numout,*) '~~~~~~~'				      IF(lwp) WRITE(numout,*) '~~~~~~~'


      REWIND( numnat_ref )              ! Namelist namtrc in 	      REWIND( numnat_ref )              ! Namelist namtrc in 
      READ  ( numnat_ref, namtrc, IOSTAT = ios, ERR = 901)	      READ  ( numnat_ref, namtrc, IOSTAT = ios, ERR = 901)
901   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc in referenc	901   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc in referenc

      REWIND( numnat_cfg )              ! Namelist namtrc in 	      REWIND( numnat_cfg )              ! Namelist namtrc in 
      READ  ( numnat_cfg, namtrc, IOSTAT = ios, ERR = 902 )	      READ  ( numnat_cfg, namtrc, IOSTAT = ios, ERR = 902 )
902   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc in configur	902   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc in configur
      IF(lwm) WRITE ( numont, namtrc )				      IF(lwm) WRITE ( numont, namtrc )

      DO jn = 1, jptra						      DO jn = 1, jptra
         ctrcnm    (jn) = TRIM( sn_tracer(jn)%clsname )		         ctrcnm    (jn) = TRIM( sn_tracer(jn)%clsname )
         ctrcln    (jn) = TRIM( sn_tracer(jn)%cllname )		         ctrcln    (jn) = TRIM( sn_tracer(jn)%cllname )
         ctrcun    (jn) = TRIM( sn_tracer(jn)%clunit  )		         ctrcun    (jn) = TRIM( sn_tracer(jn)%clunit  )
         ln_trc_ini(jn) =       sn_tracer(jn)%llinit		         ln_trc_ini(jn) =       sn_tracer(jn)%llinit
							      >	!! FROM Elise 20170316---------------xiaofanLuo
							      >	!#if defined key_bdy
							      >	          ln_trc_sbc(jn) =       sn_tracer(jn)%llsbc
							      >	          ln_trc_cbc(jn) =       sn_tracer(jn)%llcbc
							      >	          ln_trc_obc(jn) =       sn_tracer(jn)%llobc
							      >	!#endif
							      >	!----------------------xiaofanLuo
         ln_trc_wri(jn) =       sn_tracer(jn)%llsave		        ln_trc_wri(jn) =       sn_tracer(jn)%llsave
							      >	       
							      >
      END DO							      END DO
							      >	      IF(lwp) WRITE(numout,*) 'trc_nam : read the passive tra
      
    END SUBROUTINE trc_nam_trc					    END SUBROUTINE trc_nam_trc


   SUBROUTINE trc_nam_dia					   SUBROUTINE trc_nam_dia
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trc_nam_dia  ***	      !!                     ***  ROUTINE trc_nam_dia  ***
      !!							      !!
      !! ** Purpose :   read options for the passive tracer d	      !! ** Purpose :   read options for the passive tracer d
      !!							      !!
      !! ** Method  : - read passive tracer namelist 		      !! ** Method  : - read passive tracer namelist 
      !!              - read namelist of each defined SMS mod	      !!              - read namelist of each defined SMS mod
      !!                ( (PISCES, CFC, MY_TRC )		      !!                ( (PISCES, CFC, MY_TRC )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER ::  ierr						      INTEGER ::  ierr
#if defined key_trdmxl_trc  || defined key_trdtrc		#if defined key_trdmxl_trc  || defined key_trdtrc
      NAMELIST/namtrc_trd/ nn_trd_trc, nn_ctls_trc, rn_ucf_tr	      NAMELIST/namtrc_trd/ nn_trd_trc, nn_ctls_trc, rn_ucf_tr
         &                ln_trdmxl_trc_restart, ln_trdmxl_tr	         &                ln_trdmxl_trc_restart, ln_trdmxl_tr
         &                cn_trdrst_trc_in, cn_trdrst_trc_out	         &                cn_trdrst_trc_in, cn_trdrst_trc_out
#endif								#endif
      NAMELIST/namtrc_dia/ ln_diatrc, ln_diabio, nn_writedia,	      NAMELIST/namtrc_dia/ ln_diatrc, ln_diabio, nn_writedia,

      INTEGER  ::   jn        				      <
      INTEGER  ::   ios                 ! Local integer outpu	      INTEGER  ::   ios                 ! Local integer outpu
      !!-----------------------------------------------------	      !!-----------------------------------------------------

      IF(lwp) WRITE(numout,*) 					      IF(lwp) WRITE(numout,*) 
      IF(lwp) WRITE(numout,*) 'trc_nam_dia : read the passive	      IF(lwp) WRITE(numout,*) 'trc_nam_dia : read the passive
      IF(lwp) WRITE(numout,*) '~~~~~~~'				      IF(lwp) WRITE(numout,*) '~~~~~~~'

      IF(lwp) WRITE(numout,*)					      IF(lwp) WRITE(numout,*)
      IF(lwp) WRITE(numout,*) 'trc_nam_dia : read the passive	      IF(lwp) WRITE(numout,*) 'trc_nam_dia : read the passive
      IF(lwp) WRITE(numout,*) '~~~~~~~'				      IF(lwp) WRITE(numout,*) '~~~~~~~'

      REWIND( numnat_ref )              ! Namelist namtrc_dia	      REWIND( numnat_ref )              ! Namelist namtrc_dia
      READ  ( numnat_ref, namtrc_dia, IOSTAT = ios, ERR = 903	      READ  ( numnat_ref, namtrc_dia, IOSTAT = ios, ERR = 903
903   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_dia in refe	903   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_dia in refe

      REWIND( numnat_cfg )              ! Namelist namtrc_dia	      REWIND( numnat_cfg )              ! Namelist namtrc_dia
      READ  ( numnat_cfg, namtrc_dia, IOSTAT = ios, ERR = 904	      READ  ( numnat_cfg, namtrc_dia, IOSTAT = ios, ERR = 904
904   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_dia in conf	904   IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_dia in conf
      IF(lwm) WRITE ( numont, namtrc_dia )			      IF(lwm) WRITE ( numont, namtrc_dia )

      IF(lwp) THEN						      IF(lwp) THEN
         WRITE(numout,*)					         WRITE(numout,*)
         WRITE(numout,*)					         WRITE(numout,*)
         WRITE(numout,*) ' Namelist : namtrc_dia'		         WRITE(numout,*) ' Namelist : namtrc_dia'
         WRITE(numout,*) '    save additionnal diagnostics ar	         WRITE(numout,*) '    save additionnal diagnostics ar
         WRITE(numout,*) '    save additionnal biology diagno	         WRITE(numout,*) '    save additionnal biology diagno
         WRITE(numout,*) '    frequency of outputs for additi	         WRITE(numout,*) '    frequency of outputs for additi
         WRITE(numout,*) '    frequency of outputs for biolog	         WRITE(numout,*) '    frequency of outputs for biolog
         WRITE(numout,*) ' '					         WRITE(numout,*) ' '
      ENDIF							      ENDIF

      IF( ln_diatrc ) THEN 				      |	      IF( ln_diatrc .AND. .NOT. lk_iomput ) THEN 
         ALLOCATE( trc2d(jpi,jpj,jpdia2d), trc3d(jpi,jpj,jpk,	         ALLOCATE( trc2d(jpi,jpj,jpdia2d), trc3d(jpi,jpj,jpk,
           &       ctrc2d(jpdia2d), ctrc2l(jpdia2d), ctrc2u(j	           &       ctrc2d(jpdia2d), ctrc2l(jpdia2d), ctrc2u(j
           &       ctrc3d(jpdia3d), ctrc3l(jpdia3d), ctrc3u(j	           &       ctrc3d(jpdia3d), ctrc3l(jpdia3d), ctrc3u(j
         IF( ierr > 0 )   CALL ctl_stop( 'STOP', 'trcnam: una	         IF( ierr > 0 )   CALL ctl_stop( 'STOP', 'trcnam: una
         !							         !
         trc2d(:,:,:  ) = 0._wp  ;   ctrc2d(:) = ' '   ;   ct	         trc2d(:,:,:  ) = 0._wp  ;   ctrc2d(:) = ' '   ;   ct
         trc3d(:,:,:,:) = 0._wp  ;   ctrc3d(:) = ' '   ;   ct	         trc3d(:,:,:,:) = 0._wp  ;   ctrc3d(:) = ' '   ;   ct
         !							         !
      ENDIF							      ENDIF

      IF( ln_diabio .OR. l_trdtrc ) THEN		      |	      IF( ( ln_diabio .AND. .NOT. lk_iomput ) .OR. l_trdtrc )
         ALLOCATE( trbio (jpi,jpj,jpk,jpdiabio) , &		         ALLOCATE( trbio (jpi,jpj,jpk,jpdiabio) , &
           &       ctrbio(jpdiabio), ctrbil(jpdiabio), ctrbiu	           &       ctrbio(jpdiabio), ctrbil(jpdiabio), ctrbiu
         IF( ierr > 0 )   CALL ctl_stop( 'STOP', 'trcnam: una	         IF( ierr > 0 )   CALL ctl_stop( 'STOP', 'trcnam: una
         !							         !
         trbio(:,:,:,:) = 0._wp  ;   ctrbio(:) = ' '   ;   ct	         trbio(:,:,:,:) = 0._wp  ;   ctrbio(:) = ' '   ;   ct
         !							         !
      ENDIF							      ENDIF
							      <
#if defined key_trdmxl_trc || defined key_trdtrc	      <
							      <
         REWIND( numnat_ref )              ! Namelist namtrc_ <
         READ  ( numnat_ref, namtrc_trd, IOSTAT = ios, ERR =  <
905      IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_trd in r <
							      <
         REWIND( numnat_cfg )              ! Namelist namtrc_ <
         READ  ( numnat_cfg, namtrc_trd, IOSTAT = ios, ERR =  <
906      IF( ios /= 0 ) CALL ctl_nam ( ios , 'namtrc_trd in c <
         IF(lwm) WRITE ( numont, namtrc_trd )		      <
							      <
         IF(lwp) THEN					      <
            WRITE(numout,*)				      <
            WRITE(numout,*) ' trd_mxl_trc_init : read namelis <
            WRITE(numout,*) ' ~~~~~~~~~~~~~~~~                <
            WRITE(numout,*) '   * frequency of trends diagnos <
            WRITE(numout,*) '   * control surface type        <
            WRITE(numout,*) '   * restart for ML diagnostics  <
            WRITE(numout,*) '   * flag to diagnose trends of  <
            WRITE(numout,*) '     instantantaneous or mean ML <
            WRITE(numout,*) '   * unit conversion factor      <
            DO jn = 1, jptra				      <
               IF( ln_trdtrc(jn) ) WRITE(numout,*) '    compu <
            END DO					      <
         ENDIF						      <
#endif							      <
      !								      !
   END SUBROUTINE trc_nam_dia					   END SUBROUTINE trc_nam_dia

#else								#else
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!  Dummy module :                                     No 	   !!  Dummy module :                                     No 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS
   SUBROUTINE trc_nam                      ! Empty routine   	   SUBROUTINE trc_nam                      ! Empty routine   
   END SUBROUTINE trc_nam					   END SUBROUTINE trc_nam
   SUBROUTINE trc_nam_run                      ! Empty routin	   SUBROUTINE trc_nam_run                      ! Empty routin
   END SUBROUTINE trc_nam_run					   END SUBROUTINE trc_nam_run
#endif								#endif

   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/TOP 3.3 , NEMO Consortium (2010)			   !! NEMO/TOP 3.3 , NEMO Consortium (2010)
   !! $Id: trcnam.F90 8353 2017-07-19 14:41:00Z lovato $      |	   !! $Id: trcnam.F90 5411 2015-06-12 17:39:14Z cetlod $
   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C	   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C
   !!========================================================	   !!========================================================
END MODULE trcnam						END MODULE  trcnam
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/trcrst.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/trcrst.F90
MODULE trcrst							MODULE trcrst
   !!========================================================	   !!========================================================
   !!                         ***  MODULE trcrst  ***		   !!                         ***  MODULE trcrst  ***
   !! TOP :   Manage the passive tracer restart			   !! TOP :   Manage the passive tracer restart
   !!========================================================	   !!========================================================
   !! History :    -   !  1991-03  ()  original code		   !! History :    -   !  1991-03  ()  original code
   !!             1.0  !  2005-03 (O. Aumont, A. El Moussaoui	   !!             1.0  !  2005-03 (O. Aumont, A. El Moussaoui
   !!              -   !  2005-10 (C. Ethe) print control	   !!              -   !  2005-10 (C. Ethe) print control
   !!             2.0  !  2005-10 (C. Ethe, G. Madec) revised	   !!             2.0  !  2005-10 (C. Ethe, G. Madec) revised
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#if defined key_top						#if defined key_top
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   'key_top'                                            	   !!   'key_top'                                            
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   trc_rst :   Restart for passive tracer			   !!   trc_rst :   Restart for passive tracer
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   'key_top'                                            	   !!   'key_top'                                            
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   trc_rst_opn    : open  restart file			   !!   trc_rst_opn    : open  restart file
   !!   trc_rst_read   : read  restart file			   !!   trc_rst_read   : read  restart file
   !!   trc_rst_wri    : write restart file			   !!   trc_rst_wri    : write restart file
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   USE oce_trc							   USE oce_trc
   USE trc							   USE trc
   USE trcnam_trp						   USE trcnam_trp
   USE iom							   USE iom
   USE daymod							   USE daymod
   IMPLICIT NONE						   IMPLICIT NONE
   PRIVATE							   PRIVATE

   PUBLIC   trc_rst_opn       ! called by ???			   PUBLIC   trc_rst_opn       ! called by ???
   PUBLIC   trc_rst_read      ! called by ???			   PUBLIC   trc_rst_read      ! called by ???
   PUBLIC   trc_rst_wri       ! called by ???			   PUBLIC   trc_rst_wri       ! called by ???
   PUBLIC   trc_rst_cal						   PUBLIC   trc_rst_cal

   !! * Substitutions						   !! * Substitutions
#  include "top_substitute.h90"					#  include "top_substitute.h90"
   								   
CONTAINS							CONTAINS
   								   
   SUBROUTINE trc_rst_opn( kt )					   SUBROUTINE trc_rst_opn( kt )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                    ***  trc_rst_opn  ***		      !!                    ***  trc_rst_opn  ***
      !!							      !!
      !! ** purpose  :   output of sea-trc variable in a netc	      !! ** purpose  :   output of sea-trc variable in a netc
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER, INTENT(in) ::   kt       ! number of iteration	      INTEGER, INTENT(in) ::   kt       ! number of iteration
      !								      !
      CHARACTER(LEN=20)   ::   clkt     ! ocean time-step def	      CHARACTER(LEN=20)   ::   clkt     ! ocean time-step def
      CHARACTER(LEN=50)   ::   clname   ! trc output restart 	      CHARACTER(LEN=50)   ::   clname   ! trc output restart 
      CHARACTER(LEN=256)  ::   clpath   ! full path to ocean 	      CHARACTER(LEN=256)  ::   clpath   ! full path to ocean 
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      IF( lk_offline ) THEN					      IF( lk_offline ) THEN
         IF( kt == nittrc000 ) THEN				         IF( kt == nittrc000 ) THEN
            lrst_trc = .FALSE.					            lrst_trc = .FALSE.
            IF( ln_rst_list ) THEN				            IF( ln_rst_list ) THEN
               nrst_lst = 1					               nrst_lst = 1
               nitrst = nstocklist( nrst_lst )			               nitrst = nstocklist( nrst_lst )
            ELSE						            ELSE
               nitrst = nitend					               nitrst = nitend
            ENDIF						            ENDIF
         ENDIF							         ENDIF

         IF( .NOT. ln_rst_list .AND. MOD( kt - 1, nstock ) ==	         IF( .NOT. ln_rst_list .AND. MOD( kt - 1, nstock ) ==
            ! we use kt - 1 and not kt - nittrc000 to keep th	            ! we use kt - 1 and not kt - nittrc000 to keep th
            nitrst = kt + nstock - 1                  ! defin	            nitrst = kt + nstock - 1                  ! defin
            IF( nitrst > nitend )   nitrst = nitend   ! make 	            IF( nitrst > nitend )   nitrst = nitend   ! make 
         ENDIF							         ENDIF
      ELSE							      ELSE
         IF( kt == nittrc000 ) lrst_trc = .FALSE.		         IF( kt == nittrc000 ) lrst_trc = .FALSE.
      ENDIF							      ENDIF

      ! to get better performances with NetCDF format:		      ! to get better performances with NetCDF format:
      ! we open and define the tracer restart file one tracer	      ! we open and define the tracer restart file one tracer
      ! except if we write tracer restart files every tracer 	      ! except if we write tracer restart files every tracer 
      IF( kt == nitrst - 2*nn_dttrc .OR. nstock == nn_dttrc .	      IF( kt == nitrst - 2*nn_dttrc .OR. nstock == nn_dttrc .
         ! beware of the format used to write kt (default is 	         ! beware of the format used to write kt (default is 
         IF( nitrst > 1.0e9 ) THEN   ;   WRITE(clkt,*       )	         IF( nitrst > 1.0e9 ) THEN   ;   WRITE(clkt,*       )
         ELSE                        ;   WRITE(clkt,'(i8.8)')	         ELSE                        ;   WRITE(clkt,'(i8.8)')
         ENDIF							         ENDIF
         ! create the file					         ! create the file
         IF(lwp) WRITE(numout,*)				         IF(lwp) WRITE(numout,*)
         clname = TRIM(cexper)//"_"//TRIM(ADJUSTL(clkt))//"_"	         clname = TRIM(cexper)//"_"//TRIM(ADJUSTL(clkt))//"_"
         clpath = TRIM(cn_trcrst_outdir)			         clpath = TRIM(cn_trcrst_outdir)
         IF( clpath(LEN_TRIM(clpath):) /= '/' ) clpath = TRIM	         IF( clpath(LEN_TRIM(clpath):) /= '/' ) clpath = TRIM
         IF(lwp) WRITE(numout,*) &				         IF(lwp) WRITE(numout,*) &
             '             open trc restart.output NetCDF fil	             '             open trc restart.output NetCDF fil
         CALL iom_open( TRIM(clpath)//TRIM(clname), numrtw, l	         CALL iom_open( TRIM(clpath)//TRIM(clname), numrtw, l
         lrst_trc = .TRUE.					         lrst_trc = .TRUE.
      ENDIF							      ENDIF
      !								      !
   END SUBROUTINE trc_rst_opn					   END SUBROUTINE trc_rst_opn

   SUBROUTINE trc_rst_read					   SUBROUTINE trc_rst_read
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                    ***  trc_rst_opn  ***		      !!                    ***  trc_rst_opn  ***
      !!							      !!
      !! ** purpose  :   read passive tracer fields in restar	      !! ** purpose  :   read passive tracer fields in restar
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER  ::  jn     					      INTEGER  ::  jn     

      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      IF(lwp) WRITE(numout,*)					      IF(lwp) WRITE(numout,*)
      IF(lwp) WRITE(numout,*) 'trc_rst_read : read data in th	      IF(lwp) WRITE(numout,*) 'trc_rst_read : read data in th
      IF(lwp) WRITE(numout,*) '~~~~~~~~~~~~'			      IF(lwp) WRITE(numout,*) '~~~~~~~~~~~~'

      ! READ prognostic variables and computes diagnostic var	      ! READ prognostic variables and computes diagnostic var
      DO jn = 1, jptra						      DO jn = 1, jptra
         CALL iom_get( numrtr, jpdom_autoglo, 'TRN'//ctrcnm(j	         CALL iom_get( numrtr, jpdom_autoglo, 'TRN'//ctrcnm(j
      END DO							      END DO

      DO jn = 1, jptra						      DO jn = 1, jptra
         CALL iom_get( numrtr, jpdom_autoglo, 'TRB'//ctrcnm(j	         CALL iom_get( numrtr, jpdom_autoglo, 'TRB'//ctrcnm(j
      END DO							      END DO
      !								      !
   END SUBROUTINE trc_rst_read					   END SUBROUTINE trc_rst_read

   SUBROUTINE trc_rst_wri( kt )					   SUBROUTINE trc_rst_wri( kt )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                    ***  trc_rst_wri  ***		      !!                    ***  trc_rst_wri  ***
      !!							      !!
      !! ** purpose  :   write passive tracer fields in resta	      !! ** purpose  :   write passive tracer fields in resta
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER, INTENT( in ) ::   kt    ! ocean time-step inde	      INTEGER, INTENT( in ) ::   kt    ! ocean time-step inde
      !!							      !!
      INTEGER  :: jn						      INTEGER  :: jn
      REAL(wp) :: zarak0					      REAL(wp) :: zarak0
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      CALL iom_rstput( kt, nitrst, numrtw, 'rdttrc1', rdttrc(	      CALL iom_rstput( kt, nitrst, numrtw, 'rdttrc1', rdttrc(
      ! prognostic variables 					      ! prognostic variables 
      ! -------------------- 					      ! -------------------- 
      DO jn = 1, jptra						      DO jn = 1, jptra
         CALL iom_rstput( kt, nitrst, numrtw, 'TRN'//ctrcnm(j	         CALL iom_rstput( kt, nitrst, numrtw, 'TRN'//ctrcnm(j
      END DO							      END DO

      DO jn = 1, jptra						      DO jn = 1, jptra
         CALL iom_rstput( kt, nitrst, numrtw, 'TRB'//ctrcnm(j	         CALL iom_rstput( kt, nitrst, numrtw, 'TRB'//ctrcnm(j
      END DO							      END DO
      !								      !
      IF( kt == nitrst ) THEN					      IF( kt == nitrst ) THEN
          CALL trc_rst_stat            ! statistics		          CALL trc_rst_stat            ! statistics
          CALL iom_close( numrtw )     ! close the restart fi	          CALL iom_close( numrtw )     ! close the restart fi
#if ! defined key_trdmxl_trc					#if ! defined key_trdmxl_trc
          lrst_trc = .FALSE.					          lrst_trc = .FALSE.
#endif								#endif
          IF( lk_offline .AND. ln_rst_list ) THEN		          IF( lk_offline .AND. ln_rst_list ) THEN
             nrst_lst = nrst_lst + 1				             nrst_lst = nrst_lst + 1
             nitrst = nstocklist( nrst_lst )			             nitrst = nstocklist( nrst_lst )
          ENDIF							          ENDIF
      ENDIF							      ENDIF
      !								      !
   END SUBROUTINE trc_rst_wri 					   END SUBROUTINE trc_rst_wri 


   SUBROUTINE trc_rst_cal( kt, cdrw )				   SUBROUTINE trc_rst_cal( kt, cdrw )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                   ***  ROUTINE trc_rst_cal  ***	      !!                   ***  ROUTINE trc_rst_cal  ***
      !!							      !!
      !!  ** Purpose : Read or write calendar in restart file	      !!  ** Purpose : Read or write calendar in restart file
      !!							      !!
      !!  WRITE(READ) mode:					      !!  WRITE(READ) mode:
      !!       kt        : number of time step since the begi	      !!       kt        : number of time step since the begi
      !!                   end of the current(previous) run	      !!                   end of the current(previous) run
      !!       adatrj(0) : number of elapsed days since the b	      !!       adatrj(0) : number of elapsed days since the b
      !!                   end of the current(previous) run (	      !!                   end of the current(previous) run (
      !!       ndastp    : date at the end of the current(pre	      !!       ndastp    : date at the end of the current(pre
      !!							      !!
      !!   According to namelist parameter nrstdt,		      !!   According to namelist parameter nrstdt,
      !!       nn_rsttr = 0  no control on the date (nittrc00	      !!       nn_rsttr = 0  no control on the date (nittrc00
      !!       nn_rsttr = 1  we verify that nittrc000 is equa	      !!       nn_rsttr = 1  we verify that nittrc000 is equa
      !!                   time step of previous run + 1.	      !!                   time step of previous run + 1.
      !!       In both those options, the  exact duration of 	      !!       In both those options, the  exact duration of 
      !!       since the beginning (cumulated duration of all	      !!       since the beginning (cumulated duration of all
      !!       is not stored in the restart and is assumed to	      !!       is not stored in the restart and is assumed to
      !!       This is valid is the time step has remained co	      !!       This is valid is the time step has remained co
      !!							      !!
      !!       nn_rsttr = 2  the duration of the experiment i	      !!       nn_rsttr = 2  the duration of the experiment i
      !!                    has been stored in the restart fi	      !!                    has been stored in the restart fi
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER         , INTENT(in) ::   kt         ! ocean ti	      INTEGER         , INTENT(in) ::   kt         ! ocean ti
      CHARACTER(len=*), INTENT(in) ::   cdrw       ! "READ"/"	      CHARACTER(len=*), INTENT(in) ::   cdrw       ! "READ"/"
      !								      !
      INTEGER  ::  jlibalt = jprstlib				      INTEGER  ::  jlibalt = jprstlib
      LOGICAL  ::  llok						      LOGICAL  ::  llok
      REAL(wp) ::  zkt, zrdttrc1				      REAL(wp) ::  zkt, zrdttrc1
      REAL(wp) ::  zndastp					      REAL(wp) ::  zndastp

      ! Time domain : restart					      ! Time domain : restart
      ! ---------------------					      ! ---------------------

      IF( TRIM(cdrw) == 'READ' ) THEN				      IF( TRIM(cdrw) == 'READ' ) THEN

         IF(lwp) WRITE(numout,*)				         IF(lwp) WRITE(numout,*)
         IF(lwp) WRITE(numout,*) 'trc_rst_cal : read the TOP 	         IF(lwp) WRITE(numout,*) 'trc_rst_cal : read the TOP 
         IF(lwp) WRITE(numout,*) '~~~~~~~~~~~~'			         IF(lwp) WRITE(numout,*) '~~~~~~~~~~~~'

         IF ( jprstlib == jprstdimg ) THEN			         IF ( jprstlib == jprstdimg ) THEN
           ! eventually read netcdf file (monobloc)  for rest	           ! eventually read netcdf file (monobloc)  for rest
           ! if {cn_trcrst_in}.nc exists, then set jlibalt to	           ! if {cn_trcrst_in}.nc exists, then set jlibalt to
           INQUIRE( FILE = TRIM(cn_trcrst_indir)//'/'//TRIM(c	           INQUIRE( FILE = TRIM(cn_trcrst_indir)//'/'//TRIM(c
           IF ( llok ) THEN ; jlibalt = jpnf90  ; ELSE ; jlib	           IF ( llok ) THEN ; jlibalt = jpnf90  ; ELSE ; jlib
         ENDIF							         ENDIF

         IF( ln_rsttr ) THEN					         IF( ln_rsttr ) THEN
            CALL iom_open( TRIM(cn_trcrst_indir)//'/'//cn_trc	            CALL iom_open( TRIM(cn_trcrst_indir)//'/'//cn_trc
            CALL iom_get ( numrtr, 'kt', zkt )   ! last time-	            CALL iom_get ( numrtr, 'kt', zkt )   ! last time-

            IF(lwp) THEN					            IF(lwp) THEN
               WRITE(numout,*) ' *** Info read in restart : '	               WRITE(numout,*) ' *** Info read in restart : '
               WRITE(numout,*) '   previous time-step        	               WRITE(numout,*) '   previous time-step        
               WRITE(numout,*) ' *** restart option'		               WRITE(numout,*) ' *** restart option'
               SELECT CASE ( nn_rsttr )				               SELECT CASE ( nn_rsttr )
               CASE ( 0 )   ;   WRITE(numout,*) ' nn_rsttr = 	               CASE ( 0 )   ;   WRITE(numout,*) ' nn_rsttr = 
               CASE ( 1 )   ;   WRITE(numout,*) ' nn_rsttr = 	               CASE ( 1 )   ;   WRITE(numout,*) ' nn_rsttr = 
               CASE ( 2 )   ;   WRITE(numout,*) ' nn_rsttr = 	               CASE ( 2 )   ;   WRITE(numout,*) ' nn_rsttr = 
               END SELECT					               END SELECT
               WRITE(numout,*)					               WRITE(numout,*)
            ENDIF						            ENDIF
            ! Control of date 					            ! Control of date 
            IF( nittrc000  - NINT( zkt ) /= nn_dttrc .AND.  n	            IF( nittrc000  - NINT( zkt ) /= nn_dttrc .AND.  n
               &   CALL ctl_stop( ' ===>>>> : problem with ni	               &   CALL ctl_stop( ' ===>>>> : problem with ni
               &                  ' verify the restart file o	               &                  ' verify the restart file o
         ENDIF							         ENDIF
         !							         !
         IF( lk_offline ) THEN    				         IF( lk_offline ) THEN    
            !                                          ! set 	            !                                          ! set 
            IF( ln_rsttr .AND. nn_rsttr == 2 ) THEN		            IF( ln_rsttr .AND. nn_rsttr == 2 ) THEN
               CALL iom_get( numrtr, 'ndastp', zndastp ) 	               CALL iom_get( numrtr, 'ndastp', zndastp ) 
               ndastp = NINT( zndastp )				               ndastp = NINT( zndastp )
               CALL iom_get( numrtr, 'adatrj', adatrj  )	               CALL iom_get( numrtr, 'adatrj', adatrj  )
             ELSE						             ELSE
               ndastp = ndate0 - 1     ! ndate0 read in the n	               ndastp = ndate0 - 1     ! ndate0 read in the n
               adatrj = ( REAL( nittrc000-1, wp ) * rdttra(1)	               adatrj = ( REAL( nittrc000-1, wp ) * rdttra(1)
               ! note this is wrong if time step has changed 	               ! note this is wrong if time step has changed 
            ENDIF						            ENDIF
            !							            !
            IF(lwp) THEN					            IF(lwp) THEN
              WRITE(numout,*) ' *** Info used values : '	              WRITE(numout,*) ' *** Info used values : '
              WRITE(numout,*) '   date ndastp                	              WRITE(numout,*) '   date ndastp                
              WRITE(numout,*) '   number of elapsed days sinc	              WRITE(numout,*) '   number of elapsed days sinc
              WRITE(numout,*)					              WRITE(numout,*)
            ENDIF						            ENDIF
            !							            !
            IF( ln_rsttr )  THEN   ;    neuler = 1		            IF( ln_rsttr )  THEN   ;    neuler = 1
            ELSE                   ;    neuler = 0		            ELSE                   ;    neuler = 0
            ENDIF						            ENDIF
            !							            !
            CALL day_init          ! compute calendar		            CALL day_init          ! compute calendar
            !							            !
         ENDIF							         ENDIF
         !							         !
      ELSEIF( TRIM(cdrw) == 'WRITE' ) THEN			      ELSEIF( TRIM(cdrw) == 'WRITE' ) THEN
         !							         !
         IF(  kt == nitrst ) THEN				         IF(  kt == nitrst ) THEN
            IF(lwp) WRITE(numout,*)				            IF(lwp) WRITE(numout,*)
            IF(lwp) WRITE(numout,*) 'trc_wri : write the TOP 	            IF(lwp) WRITE(numout,*) 'trc_wri : write the TOP 
            IF(lwp) WRITE(numout,*) '~~~~~~~'			            IF(lwp) WRITE(numout,*) '~~~~~~~'
         ENDIF							         ENDIF
         CALL iom_rstput( kt, nitrst, numrtw, 'kt'     , REAL	         CALL iom_rstput( kt, nitrst, numrtw, 'kt'     , REAL
         CALL iom_rstput( kt, nitrst, numrtw, 'ndastp' , REAL	         CALL iom_rstput( kt, nitrst, numrtw, 'ndastp' , REAL
         CALL iom_rstput( kt, nitrst, numrtw, 'adatrj' , adat	         CALL iom_rstput( kt, nitrst, numrtw, 'adatrj' , adat
         !                                                   	         !                                                   
      ENDIF							      ENDIF

   END SUBROUTINE trc_rst_cal					   END SUBROUTINE trc_rst_cal


   SUBROUTINE trc_rst_stat					   SUBROUTINE trc_rst_stat
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                    ***  trc_rst_stat  ***		      !!                    ***  trc_rst_stat  ***
      !!							      !!
      !! ** purpose  :   Compute tracers statistics		      !! ** purpose  :   Compute tracers statistics
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER  :: jk, jn					      INTEGER  :: jk, jn
      REAL(wp) :: ztraf, zmin, zmax, zmean, zdrift		      REAL(wp) :: ztraf, zmin, zmax, zmean, zdrift
      REAL(wp), DIMENSION(jpi,jpj,jpk) :: zvol			      REAL(wp), DIMENSION(jpi,jpj,jpk) :: zvol
      !!-----------------------------------------------------	      !!-----------------------------------------------------

      IF( lwp ) THEN						      IF( lwp ) THEN
         WRITE(numout,*) 					         WRITE(numout,*) 
         WRITE(numout,*) '           ----TRACER STAT----     	         WRITE(numout,*) '           ----TRACER STAT----     
         WRITE(numout,*) 					         WRITE(numout,*) 
      ENDIF							      ENDIF
      !								      !
      DO jk = 1, jpk						      DO jk = 1, jpk
         zvol(:,:,jk) = e1e2t(:,:) * fse3t_a(:,:,jk) * tmask(	         zvol(:,:,jk) = e1e2t(:,:) * fse3t_a(:,:,jk) * tmask(
      END DO							      END DO
      !								      !
      DO jn = 1, jptra						      DO jn = 1, jptra
         ztraf = glob_sum( trn(:,:,:,jn) * zvol(:,:,:) )	         ztraf = glob_sum( trn(:,:,:,jn) * zvol(:,:,:) )
         zmin  = MINVAL( trn(:,:,:,jn), mask= ((tmask*SPREAD(	         zmin  = MINVAL( trn(:,:,:,jn), mask= ((tmask*SPREAD(
         zmax  = MAXVAL( trn(:,:,:,jn), mask= ((tmask*SPREAD(	         zmax  = MAXVAL( trn(:,:,:,jn), mask= ((tmask*SPREAD(
         IF( lk_mpp ) THEN					         IF( lk_mpp ) THEN
            CALL mpp_min( zmin )      ! min over the global d	            CALL mpp_min( zmin )      ! min over the global d
            CALL mpp_max( zmax )      ! max over the global d	            CALL mpp_max( zmax )      ! max over the global d
         END IF							         END IF
         zmean  = ztraf / areatot				         zmean  = ztraf / areatot
         zdrift = ( ( ztraf - trai(jn) ) / ( trai(jn) + 1.e-1	         zdrift = ( ( ztraf - trai(jn) ) / ( trai(jn) + 1.e-1
         IF(lwp) WRITE(numout,9000) jn, TRIM( ctrcnm(jn) ), z	         IF(lwp) WRITE(numout,9000) jn, TRIM( ctrcnm(jn) ), z
      END DO							      END DO
      IF(lwp) WRITE(numout,*) 				      |	      WRITE(numout,*) 
9000  FORMAT(' tracer nb :',i2,'    name :',a10,'    mean :',	9000  FORMAT(' tracer nb :',i2,'    name :',a10,'    mean :',
      &      '    max :',e18.10,'    drift :',e18.10, ' %')	      &      '    max :',e18.10,'    drift :',e18.10, ' %')
      !								      !
   END SUBROUTINE trc_rst_stat					   END SUBROUTINE trc_rst_stat

#else								#else
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!  Dummy module :                                     No 	   !!  Dummy module :                                     No 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS
   SUBROUTINE trc_rst_read                      ! Empty routi	   SUBROUTINE trc_rst_read                      ! Empty routi
   END SUBROUTINE trc_rst_read					   END SUBROUTINE trc_rst_read
   SUBROUTINE trc_rst_wri( kt )					   SUBROUTINE trc_rst_wri( kt )
      INTEGER, INTENT ( in ) :: kt				      INTEGER, INTENT ( in ) :: kt
      WRITE(*,*) 'trc_rst_wri: You should not have seen this 	      WRITE(*,*) 'trc_rst_wri: You should not have seen this 
   END SUBROUTINE trc_rst_wri   				   END SUBROUTINE trc_rst_wri   
#endif								#endif

   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/TOP 3.3 , NEMO Consortium (2010)			   !! NEMO/TOP 3.3 , NEMO Consortium (2010)
   !! $Id: trcrst.F90 7052 2016-10-20 10:23:27Z acc $	      |	   !! $Id: trcrst.F90 5513 2015-06-30 09:59:46Z cetlod $
   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C	   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C
   !!========================================================	   !!========================================================
END MODULE trcrst						END MODULE trcrst
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/trcsms.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/trcsms.F90
MODULE trcsms							MODULE trcsms
   !!========================================================	   !!========================================================
   !!                         ***  MODULE trcsms  ***		   !!                         ***  MODULE trcsms  ***
   !! TOP :   Time loop of passive tracers sms			   !! TOP :   Time loop of passive tracers sms
   !!========================================================	   !!========================================================
   !! History :   1.0  !  2005-03 (O. Aumont, A. El Moussaoui	   !! History :   1.0  !  2005-03 (O. Aumont, A. El Moussaoui
   !!             2.0  !  2007-12  (C. Ethe, G. Madec)  revis	   !!             2.0  !  2007-12  (C. Ethe, G. Madec)  revis
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#if defined key_top						#if defined key_top
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   'key_top'                                            	   !!   'key_top'                                            
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   trc_sms        :  Time loop of passive tracers sms	   !!   trc_sms        :  Time loop of passive tracers sms
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   USE oce_trc            !					   USE oce_trc            !
   USE trc                !					   USE trc                !
   USE trcsms_pisces      ! PISCES biogeo-model			   USE trcsms_pisces      ! PISCES biogeo-model
							      >	   USE trcsms_canoe      ! PISCES biogeo-model
							      >	   USE trcsms_cmoc      !CMOC biogeo-model
   USE trcsms_cfc         ! CFC 11 & 12				   USE trcsms_cfc         ! CFC 11 & 12
   USE trcsms_c14b        ! C14b tracer 			   USE trcsms_c14b        ! C14b tracer 
   USE trcsms_age         ! AGE tracer 			      <
   USE trcsms_my_trc      ! MY_TRC  tracers			   USE trcsms_my_trc      ! MY_TRC  tracers
   USE prtctl_trc         ! Print control for debbuging		   USE prtctl_trc         ! Print control for debbuging

   IMPLICIT NONE						   IMPLICIT NONE
   PRIVATE							   PRIVATE

   PUBLIC   trc_sms    ! called in trcstp.F90			   PUBLIC   trc_sms    ! called in trcstp.F90

   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/TOP 3.3 , NEMO Consortium (2010)			   !! NEMO/TOP 3.3 , NEMO Consortium (2010)
   !! $Id: trcsms.F90 8353 2017-07-19 14:41:00Z lovato $      |	   !! $Id: trcsms.F90 3680 2012-11-27 14:42:24Z rblod $ 
   !! Software governed by the CeCILL licence     (NEMOGCM/NE	   !! Software governed by the CeCILL licence     (NEMOGCM/NE
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS

   SUBROUTINE trc_sms( kt )					   SUBROUTINE trc_sms( kt )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trc_sms  ***		      !!                     ***  ROUTINE trc_sms  ***
      !!							      !!
      !! ** Purpose :   Managment of the time loop of passive	      !! ** Purpose :   Managment of the time loop of passive
      !!							      !!
      !! ** Method  : -  call the main routine of of each def	      !! ** Method  : -  call the main routine of of each def
      !! ----------------------------------------------------	      !! ----------------------------------------------------
      INTEGER, INTENT( in ) ::   kt      ! ocean time-step in	      INTEGER, INTENT( in ) ::   kt      ! ocean time-step in
      !!							      !!
      CHARACTER (len=25) :: charout				      CHARACTER (len=25) :: charout
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      IF( nn_timing == 1 )   CALL timing_start('trc_sms')	      IF( nn_timing == 1 )   CALL timing_start('trc_sms')
      !								      !
      IF( lk_pisces  )   CALL trc_sms_pisces ( kt )    ! main	      IF( lk_pisces  )   CALL trc_sms_pisces ( kt )    ! main
      IF( lk_my_trc  )   CALL trc_sms_my_trc ( kt )    ! MY_T |	      IF( lk_canoe  )   CALL trc_sms_canoe ( kt )    ! main p
							      >	      IF( lk_cmoc  )     CALL trc_sms_cmoc ( kt )    ! main p
      IF( lk_cfc     )   CALL trc_sms_cfc    ( kt )    ! surf	      IF( lk_cfc     )   CALL trc_sms_cfc    ( kt )    ! surf
      IF( lk_c14b    )   CALL trc_sms_c14b   ( kt )    ! surf	      IF( lk_c14b    )   CALL trc_sms_c14b   ( kt )    ! surf
      IF( lk_age     )   CALL trc_sms_age    ( kt )    ! AGE  |	      IF( lk_my_trc  )   CALL trc_sms_my_trc ( kt )    ! MY_T

      IF(ln_ctl) THEN      ! print mean trends (used for debu	      IF(ln_ctl) THEN      ! print mean trends (used for debu
         WRITE(charout, FMT="('sms ')")				         WRITE(charout, FMT="('sms ')")
         CALL prt_ctl_trc_info( charout )			         CALL prt_ctl_trc_info( charout )
         CALL prt_ctl_trc( tab4d=trn, mask=tmask, clinfo=ctrc	         CALL prt_ctl_trc( tab4d=trn, mask=tmask, clinfo=ctrc
      ENDIF							      ENDIF
      !								      !
      IF( nn_timing == 1 )   CALL timing_stop('trc_sms')	      IF( nn_timing == 1 )   CALL timing_stop('trc_sms')
      !								      !
   END SUBROUTINE trc_sms					   END SUBROUTINE trc_sms

#else								#else
   !!========================================================	   !!========================================================
   !!  Dummy module :                                     No 	   !!  Dummy module :                                     No 
   !!========================================================	   !!========================================================
CONTAINS							CONTAINS
   SUBROUTINE trc_sms( kt )                   ! Empty routine	   SUBROUTINE trc_sms( kt )                   ! Empty routine
      INTEGER, INTENT( in ) ::   kt				      INTEGER, INTENT( in ) ::   kt
      WRITE(*,*) 'trc_sms: You should not have seen this prin	      WRITE(*,*) 'trc_sms: You should not have seen this prin
   END SUBROUTINE trc_sms					   END SUBROUTINE trc_sms
#endif 								#endif 

   !!========================================================	   !!========================================================
END MODULE trcsms						END MODULE  trcsms
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/trcstp.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/trcstp.F90
MODULE trcstp							MODULE trcstp
   !!========================================================	   !!========================================================
   !!                       ***  MODULE trcstp  ***		   !!                       ***  MODULE trcstp  ***
   !! Time-stepping    : time loop of opa for passive tracer	   !! Time-stepping    : time loop of opa for passive tracer
   !!========================================================	   !!========================================================
   !! History :  1.0  !  2004-03  (C. Ethe)  Original		   !! History :  1.0  !  2004-03  (C. Ethe)  Original
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#if defined key_top						#if defined key_top
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   trc_stp      : passive tracer system time-stepping	   !!   trc_stp      : passive tracer system time-stepping
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   USE oce_trc          ! ocean dynamics and active tracers v	   USE oce_trc          ! ocean dynamics and active tracers v
   USE sbc_oce							   USE sbc_oce
   USE trc							   USE trc
   USE trctrp           ! passive tracers transport		   USE trctrp           ! passive tracers transport
   USE trcsms           ! passive tracers sources and sinks	   USE trcsms           ! passive tracers sources and sinks
   USE prtctl_trc       ! Print control for debbuging		   USE prtctl_trc       ! Print control for debbuging
   USE trcdia							   USE trcdia
   USE trcwri							   USE trcwri
   USE trcrst							   USE trcrst
   USE trdtrc_oce						   USE trdtrc_oce
   USE trdmxl_trc						   USE trdmxl_trc
   USE iom							   USE iom
   USE in_out_manager						   USE in_out_manager
   USE trcsub							   USE trcsub
							      |	   !! wirtten by xiaofan Luo for update obc
							      >	#if defined key_bdy
							      >	   USE trcbc
							      >	#endif    
   IMPLICIT NONE						   IMPLICIT NONE
   PRIVATE							   PRIVATE

   PUBLIC   trc_stp    ! called by step				   PUBLIC   trc_stp    ! called by step

   REAL(wp), DIMENSION(:,:,:), SAVE, ALLOCATABLE ::   qsr_arr	   REAL(wp), DIMENSION(:,:,:), SAVE, ALLOCATABLE ::   qsr_arr
   REAL(wp) :: rdt_sampl					   REAL(wp) :: rdt_sampl
   INTEGER  :: nb_rec_per_day, ktdcy			      |	   INTEGER  :: nb_rec_per_days
   REAL(wp) :: rsecfst, rseclast			      |	   INTEGER  :: isecfst, iseclast
   LOGICAL  :: llnew						   LOGICAL  :: llnew

   !! * Substitutions						   !! * Substitutions
#  include "domzgr_substitute.h90"				#  include "domzgr_substitute.h90"
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/TOP 3.3 , NEMO Consortium (2010)			   !! NEMO/TOP 3.3 , NEMO Consortium (2010)
   !! $Id: trcstp.F90 7654 2017-02-07 16:16:04Z cetlod $      |	   !! $Id: trcstp.F90 5407 2015-06-11 19:13:22Z smasson $ 
   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C	   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS

   SUBROUTINE trc_stp( kt )					   SUBROUTINE trc_stp( kt )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trc_stp  ***		      !!                     ***  ROUTINE trc_stp  ***
      !!                      					      !!                      
      !! ** Purpose : Time loop of opa for passive tracer	      !! ** Purpose : Time loop of opa for passive tracer
      !! 							      !! 
      !! ** Method  : 						      !! ** Method  : 
      !!              Compute the passive tracers trends 	      !!              Compute the passive tracers trends 
      !!              Update the passive tracers		      !!              Update the passive tracers
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER, INTENT( in ) ::  kt      ! ocean time-step ind	      INTEGER, INTENT( in ) ::  kt      ! ocean time-step ind
      INTEGER               ::  jk, jn  ! dummy loop indices	      INTEGER               ::  jk, jn  ! dummy loop indices
      REAL(wp)              ::  ztrai				      REAL(wp)              ::  ztrai
      CHARACTER (len=25)    ::  charout 			      CHARACTER (len=25)    ::  charout 
      !!-----------------------------------------------------
      !								      !!-----------------------------------------------------
      IF( nn_timing == 1 )   CALL timing_start('trc_stp')	      !
      !								      IF( nn_timing == 1 )   CALL timing_start('trc_stp')
      IF( kt == nittrc000 .AND. lk_trdmxl_trc )  CALL trd_mxl	      !
      !								      IF( kt == nittrc000 .AND. lk_trdmxl_trc )  CALL trd_mxl
      IF( lk_vvl ) THEN                                      	      !
         DO jk = 1, jpk						      IF( lk_vvl ) THEN                                      
            cvol(:,:,jk) = e1e2t(:,:) * fse3t(:,:,jk) * tmask	         DO jk = 1, jpk
         END DO							            cvol(:,:,jk) = e1e2t(:,:) * fse3t(:,:,jk) * tmask
         IF( lk_degrad )  cvol(:,:,:) = cvol(:,:,:) * facvol(	         END DO
         areatot         = glob_sum( cvol(:,:,:) )		         IF( lk_degrad )  cvol(:,:,:) = cvol(:,:,:) * facvol(
      ENDIF							         areatot         = glob_sum( cvol(:,:,:) )
      !								      ENDIF
      IF( l_trcdm2dc )   CALL trc_mean_qsr( kt )		      !
      !    							      IF( l_trcdm2dc )   CALL trc_mean_qsr( kt )
      IF( nn_dttrc /= 1 )   CALL trc_sub_stp( kt )  ! averagi	      !    
      !    							      IF( nn_dttrc /= 1 )   CALL trc_sub_stp( kt )  ! averagi
      IF( MOD( kt , nn_dttrc ) == 0 ) THEN      ! only every 	      !    
         !							      IF( MOD( kt , nn_dttrc ) == 0 ) THEN      ! only every 
         IF(ln_ctl) THEN					         !
            WRITE(charout,FMT="('kt =', I4,'  d/m/y =',I2,I2,	         IF(ln_ctl) THEN
            CALL prt_ctl_trc_info(charout)			            WRITE(charout,FMT="('kt =', I4,'  d/m/y =',I2,I2,
         ENDIF							            CALL prt_ctl_trc_info(charout)
         !							         ENDIF
         tra(:,:,:,:) = 0.e0					         !
         !							         tra(:,:,:,:) = 0.e0
							      )	         !
         IF( .NOT.lk_offline )     CALL trc_rst_opn  ( kt )   |	                                   CALL trc_rst_opn  ( kt )  
         IF( lrst_trc )            CALL trc_rst_cal  ( kt, 'W	         IF( lrst_trc )            CALL trc_rst_cal  ( kt, 'W
         IF( lk_iomput ) THEN  ;   CALL trc_wri      ( kt )  	         IF( lk_iomput ) THEN  ;   CALL trc_wri      ( kt )  
         ELSE                  ;   CALL trc_dia      ( kt )  	         ELSE                  ;   CALL trc_dia      ( kt )  
         ENDIF							         ENDIF
                                   CALL trc_sms      ( kt )   |	                                   CALL trc_sms      ( kt )  
							      >	 !! written by xiaofan Luo for obc update
							      >	#if defined key_bdy                
							      >	                                   CALL trc_bc_read  ( kt )
							      >	#endif     
                                   CALL trc_trp      ( kt )  	                                   CALL trc_trp      ( kt )  
								         IF( kt == nittrc000 ) THEN
         IF( kt == nittrc000 ) THEN				            CALL iom_close( numrtr )       ! close input trac
            CALL iom_close( numrtr )       ! close input trac	            IF(lwm) CALL FLUSH( numont )   ! flush namelist o
            IF(lwm) CALL FLUSH( numont )   ! flush namelist o	         ENDIF
         ENDIF							         IF( lrst_trc )            CALL trc_rst_wri  ( kt )  
         IF( lrst_trc )            CALL trc_rst_wri  ( kt )  	         IF( lk_trdmxl_trc  )      CALL trd_mxl_trc  ( kt )  
         IF( lk_trdmxl_trc  )      CALL trd_mxl_trc  ( kt )  	         !
         !							         IF( nn_dttrc /= 1   )     CALL trc_sub_reset( kt )  
         IF( nn_dttrc /= 1   )     CALL trc_sub_reset( kt )  	         !
         !							      ENDIF
      ENDIF							      !
      !								      ztrai = 0._wp                                          
								      DO jn = 1, jptra
      ztrai = 0._wp                                          	         ztrai = ztrai + glob_sum( trn(:,:,:,jn) * cvol(:,:,:
      DO jn = 1, jptra						      END DO
         ztrai = ztrai + glob_sum( trn(:,:,:,jn) * cvol(:,:,:	      IF( lwp ) WRITE(numstr,9300) kt,  ztrai / areatot
      END DO						      (
      IF( lwp ) WRITE(numstr,9300) kt,  ztrai / areatot	      (
9300  FORMAT(i10,D23.16)				      |	9300  FORMAT(i10,e18.10)
      !								      !
      IF( nn_timing == 1 )   CALL timing_stop('trc_stp')	      IF( nn_timing == 1 )   CALL timing_stop('trc_stp')
      !								      !
   END SUBROUTINE trc_stp					   END SUBROUTINE trc_stp

   SUBROUTINE trc_mean_qsr( kt )				   SUBROUTINE trc_mean_qsr( kt )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!             ***  ROUTINE trc_mean_qsr  ***		      !!             ***  ROUTINE trc_mean_qsr  ***
      !!							      !!
      !! ** Purpose :  Compute daily mean qsr for biogeochemi	      !! ** Purpose :  Compute daily mean qsr for biogeochemi
      !!               of diurnal cycle				      !!               of diurnal cycle
      !!							      !!
      !! ** Method  : store in TOP the qsr every hour ( or ev |	      !! ** Method  : store in TOP the qsr every hour ( or ev
      !!              is greater than 1 hour ) and then, comp	      !!              is greater than 1 hour ) and then, comp
      !!              a moving average over 24 hours. 		      !!              a moving average over 24 hours. 
      !!              In coupled mode, the sampling is done a	      !!              In coupled mode, the sampling is done a
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER, INTENT(in) ::   kt				      INTEGER, INTENT(in) ::   kt
      INTEGER  :: jn						      INTEGER  :: jn
      REAL(wp) :: zkt, zrec				      <
      CHARACTER(len=1)               ::   cl1                 <
      CHARACTER(len=2)               ::   cl2                 <

      IF( kt == nittrc000 ) THEN				      IF( kt == nittrc000 ) THEN
         IF( ln_cpl )  THEN  					         IF( ln_cpl )  THEN  
            rdt_sampl = rday / ncpl_qsr_freq		      |	            rdt_sampl = 86400. / ncpl_qsr_freq
            nb_rec_per_day = ncpl_qsr_freq		      |	            nb_rec_per_days = ncpl_qsr_freq
         ELSE  							         ELSE  
            rdt_sampl = MAX( 3600., rdttrc(1) )		      |	            rdt_sampl = MAX( 3600., rdt * nn_dttrc )
            nb_rec_per_day = INT( rday / rdt_sampl )	      |	            nb_rec_per_days = INT( 86400 / rdt_sampl )
         ENDIF							         ENDIF
         !							         !
         IF( lwp ) THEN						         IF( lwp ) THEN
            WRITE(numout,*) 					            WRITE(numout,*) 
            WRITE(numout,*) ' Sampling frequency dt = ', rdt_ |	            WRITE(numout,*) ' Sampling frequency dt = ', rdt_
            WRITE(numout,*) 					            WRITE(numout,*) 
         ENDIF							         ENDIF
         !							         !
         ALLOCATE( qsr_arr(jpi,jpj,nb_rec_per_day ) )	      |	         ALLOCATE( qsr_arr(jpi,jpj,nb_rec_per_days ) )
         !						      |	         DO jn = 1, nb_rec_per_days
         !                                            !* Rest |	            qsr_arr(:,:,jn) = qsr(:,:)
         IF( ln_rsttr .AND. nn_rsttr /= 0 .AND. iom_varid( nu <
           &                              .AND. iom_varid( nu <
           &                              .AND. iom_varid( nu <
           &                              .AND. iom_varid( nu <
							      <
            CALL iom_get( numrtr, 'ktdcy', zkt )  	      <
            rsecfst = INT( zkt ) * rdttrc(1)		      <
            IF(lwp) WRITE(numout,*) 'trc_qsr_mean:   qsr_mean <
            CALL iom_get( numrtr, jpdom_autoglo, 'qsr_mean',  <
            CALL iom_get( numrtr, 'nrdcy', zrec )   !  Number <
            IF( INT( zrec ) == nb_rec_per_day ) THEN	      <
               DO jn = 1, nb_rec_per_day 		      <
                  IF( jn <= 9 )  THEN			      <
                    WRITE(cl1,'(i1)') jn		      <
                    CALL iom_get( numrtr, jpdom_autoglo, 'qsr <
                  ELSE					      <
                    WRITE(cl2,'(i2.2)') jn		      <
                    CALL iom_get( numrtr, jpdom_autoglo, 'qsr <
                  ENDIF					      <
              ENDDO					      <
            ELSE					      <
               DO jn = 1, nb_rec_per_day		      <
                  qsr_arr(:,:,jn) = qsr_mean(:,:)	      <
               ENDDO						         ENDDO
            ENDIF					      <
         ELSE                                         !* no r <
            IF(lwp) WRITE(numout,*) 'trc_qsr_mean:   qsr_mean <
            rsecfst  = kt * rdttrc(1)			      <
            !						      <
            qsr_mean(:,:) = qsr(:,:)				         qsr_mean(:,:) = qsr(:,:)
            DO jn = 1, nb_rec_per_day			      <
               qsr_arr(:,:,jn) = qsr_mean(:,:)		      <
            ENDDO					      <
         ENDIF						      <
         !						      <
      ENDIF						      <
      !								         !
      rseclast = kt * rdttrc(1)				      |	         isecfst  = nsec_year + nsec1jan000   !   number of s
							      >	         iseclast = isecfst
      !								         !
      llnew   = ( rseclast - rsecfst ) .ge.  rdt_sampl    !   <
      IF( llnew ) THEN					      <
          ktdcy = kt					      <
          IF( lwp .AND. kt < nittrc000 + 100 ) WRITE(numout,* <
             &                      ' time = ', rseclast/3600 <
          rsecfst = rseclast				      <
          DO jn = 1, nb_rec_per_day - 1			      <
             qsr_arr(:,:,jn) = qsr_arr(:,:,jn+1)	      <
          ENDDO						      <
          qsr_arr (:,:,nb_rec_per_day) = qsr(:,:)	      <
          qsr_mean(:,:                ) = SUM( qsr_arr(:,:,:) <
      ENDIF							      ENDIF
      !								      !
      IF( lrst_trc ) THEN    !* Write the mean of qsr in rest |	      iseclast = nsec_year + nsec1jan000
         IF(lwp) WRITE(numout,*)			      |	      llnew   = ( iseclast - isecfst )  > INT( rdt_sampl )   
         IF(lwp) WRITE(numout,*) 'trc_mean_qsr : write qsr_me |	      IF( kt /= nittrc000 .AND. llnew ) THEN
         IF(lwp) WRITE(numout,*) '~~~~~~~'		      |	          IF( lwp ) WRITE(numout,*) ' New shortwave to sample
         zkt  = REAL( ktdcy, wp )			      |	             &                      ' time = ', (iseclast+rdt
         zrec = REAL( nb_rec_per_day, wp )		      |	          isecfst = iseclast
         CALL iom_rstput( kt, nitrst, numrtw, 'ktdcy', zkt  ) |	          DO jn = 1, nb_rec_per_days - 1
         CALL iom_rstput( kt, nitrst, numrtw, 'nrdcy', zrec ) |	             qsr_arr(:,:,jn) = qsr_arr(:,:,jn+1)
          DO jn = 1, nb_rec_per_day 			      <
             IF( jn <= 9 )  THEN			      <
               WRITE(cl1,'(i1)') jn			      <
               CALL iom_rstput( kt, nitrst, numrtw, 'qsr_arr_ <
             ELSE					      <
               WRITE(cl2,'(i2.2)') jn			      <
               CALL iom_rstput( kt, nitrst, numrtw, 'qsr_arr_ <
             ENDIF					      <
         ENDDO							          ENDDO
         CALL iom_rstput( kt, nitrst, numrtw, 'qsr_mean', qsr |	          qsr_arr (:,:,nb_rec_per_days) = qsr(:,:)
							      >	          qsr_mean(:,:                ) = SUM( qsr_arr(:,:,:)
      ENDIF							      ENDIF
      !								      !
   END SUBROUTINE trc_mean_qsr					   END SUBROUTINE trc_mean_qsr

#else								#else
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   Default key                                     NO pa	   !!   Default key                                     NO pa
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS
   SUBROUTINE trc_stp( kt )        ! Empty routine		   SUBROUTINE trc_stp( kt )        ! Empty routine
      WRITE(*,*) 'trc_stp: You should not have seen this prin	      WRITE(*,*) 'trc_stp: You should not have seen this prin
   END SUBROUTINE trc_stp					   END SUBROUTINE trc_stp
#endif								#endif

   !!========================================================	   !!========================================================
END MODULE trcstp						END MODULE trcstp
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/trcsub.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/trcsub.F90
MODULE trcsub							MODULE trcsub
   !!========================================================	   !!========================================================
   !!                       ***  MODULE trcsubstp  ***		   !!                       ***  MODULE trcsubstp  ***
   !!TOP :   Averages physics variables for TOP substepping. 	   !!TOP :   Averages physics variables for TOP substepping. 
   !!========================================================	   !!========================================================
   !! History :  1.0  !  2011-10  (K. Edwards)  Original	   !! History :  1.0  !  2011-10  (K. Edwards)  Original
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#if defined key_top						#if defined key_top
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   trc_sub    : passive tracer system sub-stepping 	   !!   trc_sub    : passive tracer system sub-stepping 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   USE oce_trc          ! ocean dynamics and active tracers v	   USE oce_trc          ! ocean dynamics and active tracers v
   USE trc							   USE trc
   USE prtctl_trc       ! Print control for debbuging		   USE prtctl_trc       ! Print control for debbuging
   USE iom							   USE iom
   USE in_out_manager						   USE in_out_manager
   USE lbclnk							   USE lbclnk
							      >	#if defined key_zdftke
							      >	   USE zdftke          ! twice TKE (en)
							      >	#endif
							      >	#if defined key_zdfgls
							      >	   USE zdfgls, ONLY: en
							      >	#endif
   USE trabbl							   USE trabbl
   USE zdf_oce							   USE zdf_oce
   USE domvvl							   USE domvvl
   USE divcur          ! hor. divergence and curl      (div &	   USE divcur          ! hor. divergence and curl      (div &
   USE sbcrnf, ONLY: h_rnf, nk_rnf   ! River runoff 		   USE sbcrnf, ONLY: h_rnf, nk_rnf   ! River runoff 
   USE bdy_oce							   USE bdy_oce
#if defined key_agrif						#if defined key_agrif
   USE agrif_opa_update						   USE agrif_opa_update
   USE agrif_opa_interp						   USE agrif_opa_interp
#endif								#endif

   IMPLICIT NONE						   IMPLICIT NONE

   PUBLIC   trc_sub_stp      ! called by trc_stp		   PUBLIC   trc_sub_stp      ! called by trc_stp
   PUBLIC   trc_sub_ini      ! called by trc_ini to initializ	   PUBLIC   trc_sub_ini      ! called by trc_ini to initializ
   PUBLIC   trc_sub_reset    ! called by trc_stp to reset phy	   PUBLIC   trc_sub_reset    ! called by trc_stp to reset phy
   PUBLIC   trc_sub_ssh      ! called by trc_stp to reset phy	   PUBLIC   trc_sub_ssh      ! called by trc_stp to reset phy

   !!* Module variables						   !!* Module variables
   REAL(wp)  :: r1_ndttrc     !    1 /  nn_dttrc 		   REAL(wp)  :: r1_ndttrc     !    1 /  nn_dttrc 
   REAL(wp)  :: r1_ndttrcp1   !    1 / (nn_dttrc+1) 		   REAL(wp)  :: r1_ndttrcp1   !    1 / (nn_dttrc+1) 

   !!* Substitution						   !!* Substitution
#  include "top_substitute.h90"					#  include "top_substitute.h90"
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/TOP 3.3 , NEMO Consortium (2010)			   !! NEMO/TOP 3.3 , NEMO Consortium (2010)
   !! $Id: trcsub.F90 7088 2016-10-25 14:35:26Z lovato $      |	   !! $Id: trcsub.F90 5215 2015-04-15 16:11:56Z nicolasmartin
   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C	   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS

   SUBROUTINE trc_sub_stp( kt )					   SUBROUTINE trc_sub_stp( kt )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trc_stp  ***		      !!                     ***  ROUTINE trc_stp  ***
      !!                      					      !!                      
      !! ** Purpose : Average variables needed for sub-steppi	      !! ** Purpose : Average variables needed for sub-steppi
      !! 							      !! 
      !! ** Method  : Called every timestep to increment _tm 	      !! ** Method  : Called every timestep to increment _tm 
      !!              on TOP steps, calculate averages.		      !!              on TOP steps, calculate averages.
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER, INTENT( in ) ::  kt        ! ocean time-step i	      INTEGER, INTENT( in ) ::  kt        ! ocean time-step i
      INTEGER               ::  ji,jj,jk  ! dummy loop indice	      INTEGER               ::  ji,jj,jk  ! dummy loop indice
      REAL(wp)              ::  z1_ne3t, z1_ne3u, z1_ne3v, z1	      REAL(wp)              ::  z1_ne3t, z1_ne3u, z1_ne3v, z1
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      IF( nn_timing == 1 )  CALL timing_start('trc_sub_stp')	      IF( nn_timing == 1 )  CALL timing_start('trc_sub_stp')
      !								      !
      IF( kt == nit000 ) THEN					      IF( kt == nit000 ) THEN
           IF(lwp) WRITE(numout,*)				           IF(lwp) WRITE(numout,*)
           IF(lwp) WRITE(numout,*) 'trc_sub_stp : substepping	           IF(lwp) WRITE(numout,*) 'trc_sub_stp : substepping
           IF(lwp) WRITE(numout,*) '~~~~~~~~~~~'		           IF(lwp) WRITE(numout,*) '~~~~~~~~~~~'
           !							           !
           sshb_hold  (:,:) = sshn  (:,:)			           sshb_hold  (:,:) = sshn  (:,:)
           emp_b_hold (:,:) = emp_b (:,:)			           emp_b_hold (:,:) = emp_b (:,:)
           !							           !
           r1_ndttrc        = 1._wp / REAL( nn_dttrc    , wp 	           r1_ndttrc        = 1._wp / REAL( nn_dttrc    , wp 
           r1_ndttrcp1      = 1._wp / REAL( nn_dttrc + 1, wp 	           r1_ndttrcp1      = 1._wp / REAL( nn_dttrc + 1, wp 
           !							           !
      ENDIF  							      ENDIF  

       IF( MOD( kt , nn_dttrc ) /= 0 ) THEN			       IF( MOD( kt , nn_dttrc ) /= 0 ) THEN
          !							          !
          un_tm   (:,:,:)        = un_tm   (:,:,:)        + u	          un_tm   (:,:,:)        = un_tm   (:,:,:)        + u
          vn_tm   (:,:,:)        = vn_tm   (:,:,:)        + v	          vn_tm   (:,:,:)        = vn_tm   (:,:,:)        + v
          tsn_tm  (:,:,:,jp_tem) = tsn_tm  (:,:,:,jp_tem) + t	          tsn_tm  (:,:,:,jp_tem) = tsn_tm  (:,:,:,jp_tem) + t
          tsn_tm  (:,:,:,jp_sal) = tsn_tm  (:,:,:,jp_sal) + t	          tsn_tm  (:,:,:,jp_sal) = tsn_tm  (:,:,:,jp_sal) + t
          rhop_tm (:,:,:)        = rhop_tm (:,:,:)        + r	          rhop_tm (:,:,:)        = rhop_tm (:,:,:)        + r
          avt_tm  (:,:,:)        = avt_tm  (:,:,:)        + a	          avt_tm  (:,:,:)        = avt_tm  (:,:,:)        + a
# if defined key_zdfddm						# if defined key_zdfddm
          avs_tm  (:,:,:)        = avs_tm  (:,:,:)        + a	          avs_tm  (:,:,:)        = avs_tm  (:,:,:)        + a
# endif								# endif
#if defined key_ldfslp						#if defined key_ldfslp
          wslpi_tm(:,:,:)        = wslpi_tm(:,:,:)        + w	          wslpi_tm(:,:,:)        = wslpi_tm(:,:,:)        + w
          wslpj_tm(:,:,:)        = wslpj_tm(:,:,:)        + w	          wslpj_tm(:,:,:)        = wslpj_tm(:,:,:)        + w
          uslp_tm (:,:,:)        = uslp_tm (:,:,:)        + u	          uslp_tm (:,:,:)        = uslp_tm (:,:,:)        + u
          vslp_tm (:,:,:)        = vslp_tm (:,:,:)        + v	          vslp_tm (:,:,:)        = vslp_tm (:,:,:)        + v
#endif								#endif
# if defined key_trabbl						# if defined key_trabbl
          IF( nn_bbl_ldf == 1 ) THEN				          IF( nn_bbl_ldf == 1 ) THEN
             ahu_bbl_tm(:,:)     = ahu_bbl_tm(:,:)        + a	             ahu_bbl_tm(:,:)     = ahu_bbl_tm(:,:)        + a
             ahv_bbl_tm(:,:)     = ahv_bbl_tm(:,:)        + a	             ahv_bbl_tm(:,:)     = ahv_bbl_tm(:,:)        + a
          ENDIF							          ENDIF
          IF( nn_bbl_adv == 1 ) THEN				          IF( nn_bbl_adv == 1 ) THEN
             utr_bbl_tm(:,:)     = utr_bbl_tm(:,:)        + u	             utr_bbl_tm(:,:)     = utr_bbl_tm(:,:)        + u
             vtr_bbl_tm(:,:)     = vtr_bbl_tm(:,:)        + v	             vtr_bbl_tm(:,:)     = vtr_bbl_tm(:,:)        + v
          ENDIF							          ENDIF
# endif								# endif
          !							          !
          sshn_tm  (:,:)         = sshn_tm  (:,:)         + s	          sshn_tm  (:,:)         = sshn_tm  (:,:)         + s
          rnf_tm   (:,:)         = rnf_tm   (:,:)         + r	          rnf_tm   (:,:)         = rnf_tm   (:,:)         + r
          h_rnf_tm (:,:)         = h_rnf_tm (:,:)         + h	          h_rnf_tm (:,:)         = h_rnf_tm (:,:)         + h
          hmld_tm  (:,:)         = hmld_tm  (:,:)         + h	          hmld_tm  (:,:)         = hmld_tm  (:,:)         + h
          fr_i_tm  (:,:)         = fr_i_tm  (:,:)         + f	          fr_i_tm  (:,:)         = fr_i_tm  (:,:)         + f
          emp_tm   (:,:)         = emp_tm   (:,:)         + e	          emp_tm   (:,:)         = emp_tm   (:,:)         + e
          fmmflx_tm(:,:)         = fmmflx_tm(:,:)         + f	          fmmflx_tm(:,:)         = fmmflx_tm(:,:)         + f
          qsr_tm   (:,:)         = qsr_tm   (:,:)         + q	          qsr_tm   (:,:)         = qsr_tm   (:,:)         + q
          wndm_tm  (:,:)         = wndm_tm  (:,:)         + w	          wndm_tm  (:,:)         = wndm_tm  (:,:)         + w

      ELSE                           !  It is time to substep	      ELSE                           !  It is time to substep
         !   1. set temporary arrays to hold physics variable	         !   1. set temporary arrays to hold physics variable
         un_temp    (:,:,:)      = un    (:,:,:)		         un_temp    (:,:,:)      = un    (:,:,:)
         vn_temp    (:,:,:)      = vn    (:,:,:)		         vn_temp    (:,:,:)      = vn    (:,:,:)
         wn_temp    (:,:,:)      = wn    (:,:,:)		         wn_temp    (:,:,:)      = wn    (:,:,:)
         tsn_temp   (:,:,:,:)    = tsn   (:,:,:,:)		         tsn_temp   (:,:,:,:)    = tsn   (:,:,:,:)
         rhop_temp  (:,:,:)      = rhop  (:,:,:)    		         rhop_temp  (:,:,:)      = rhop  (:,:,:)    
         avt_temp   (:,:,:)      = avt   (:,:,:)		         avt_temp   (:,:,:)      = avt   (:,:,:)
# if defined key_zdfddm						# if defined key_zdfddm
         avs_temp   (:,:,:)      = avs   (:,:,:)		         avs_temp   (:,:,:)      = avs   (:,:,:)
# endif								# endif
#if defined key_ldfslp						#if defined key_ldfslp
         wslpi_temp (:,:,:)      = wslpi (:,:,:)		         wslpi_temp (:,:,:)      = wslpi (:,:,:)
         wslpj_temp (:,:,:)      = wslpj (:,:,:)		         wslpj_temp (:,:,:)      = wslpj (:,:,:)
         uslp_temp  (:,:,:)      = uslp  (:,:,:)		         uslp_temp  (:,:,:)      = uslp  (:,:,:)
         vslp_temp  (:,:,:)      = vslp  (:,:,:)		         vslp_temp  (:,:,:)      = vslp  (:,:,:)
#endif								#endif
# if defined key_trabbl						# if defined key_trabbl
          IF( nn_bbl_ldf == 1 ) THEN				          IF( nn_bbl_ldf == 1 ) THEN
             ahu_bbl_temp(:,:)   = ahu_bbl(:,:)  		             ahu_bbl_temp(:,:)   = ahu_bbl(:,:)  
             ahv_bbl_temp(:,:)   = ahv_bbl(:,:) 		             ahv_bbl_temp(:,:)   = ahv_bbl(:,:) 
          ENDIF							          ENDIF
          IF( nn_bbl_adv == 1 ) THEN				          IF( nn_bbl_adv == 1 ) THEN
             utr_bbl_temp(:,:)   = utr_bbl(:,:) 		             utr_bbl_temp(:,:)   = utr_bbl(:,:) 
             vtr_bbl_temp(:,:)   = vtr_bbl(:,:) 		             vtr_bbl_temp(:,:)   = vtr_bbl(:,:) 
          ENDIF							          ENDIF
# endif								# endif
         sshn_temp  (:,:)        = sshn  (:,:)			         sshn_temp  (:,:)        = sshn  (:,:)
         sshb_temp  (:,:)        = sshb  (:,:)			         sshb_temp  (:,:)        = sshb  (:,:)
         ssha_temp  (:,:)        = ssha  (:,:)			         ssha_temp  (:,:)        = ssha  (:,:)
         rnf_temp   (:,:)        = rnf   (:,:)			         rnf_temp   (:,:)        = rnf   (:,:)
         h_rnf_temp (:,:)        = h_rnf (:,:)			         h_rnf_temp (:,:)        = h_rnf (:,:)
         hmld_temp  (:,:)        = hmld  (:,:)			         hmld_temp  (:,:)        = hmld  (:,:)
         fr_i_temp  (:,:)        = fr_i  (:,:)			         fr_i_temp  (:,:)        = fr_i  (:,:)
         emp_temp   (:,:)        = emp   (:,:)			         emp_temp   (:,:)        = emp   (:,:)
         emp_b_temp (:,:)        = emp_b (:,:)			         emp_b_temp (:,:)        = emp_b (:,:)
         fmmflx_temp(:,:)        = fmmflx(:,:)			         fmmflx_temp(:,:)        = fmmflx(:,:)
         qsr_temp   (:,:)        = qsr   (:,:)			         qsr_temp   (:,:)        = qsr   (:,:)
         wndm_temp  (:,:)        = wndm  (:,:)			         wndm_temp  (:,:)        = wndm  (:,:)
         !                                    !  Variables re	         !                                    !  Variables re
         rotn_temp  (:,:,:)      = rotn  (:,:,:)		         rotn_temp  (:,:,:)      = rotn  (:,:,:)
         hdivn_temp (:,:,:)      = hdivn (:,:,:)		         hdivn_temp (:,:,:)      = hdivn (:,:,:)
         rotb_temp  (:,:,:)      = rotb  (:,:,:)		         rotb_temp  (:,:,:)      = rotb  (:,:,:)
         hdivb_temp (:,:,:)      = hdivb (:,:,:)		         hdivb_temp (:,:,:)      = hdivb (:,:,:)
         !							         !
         ! 2. Create averages and reassign variables		         ! 2. Create averages and reassign variables
         un_tm    (:,:,:)        = un_tm   (:,:,:)        + u	         un_tm    (:,:,:)        = un_tm   (:,:,:)        + u
         vn_tm    (:,:,:)        = vn_tm   (:,:,:)        + v	         vn_tm    (:,:,:)        = vn_tm   (:,:,:)        + v
         tsn_tm   (:,:,:,jp_tem) = tsn_tm  (:,:,:,jp_tem) + t	         tsn_tm   (:,:,:,jp_tem) = tsn_tm  (:,:,:,jp_tem) + t
         tsn_tm   (:,:,:,jp_sal) = tsn_tm  (:,:,:,jp_sal) + t	         tsn_tm   (:,:,:,jp_sal) = tsn_tm  (:,:,:,jp_sal) + t
         rhop_tm (:,:,:)         = rhop_tm (:,:,:)        + r	         rhop_tm (:,:,:)         = rhop_tm (:,:,:)        + r
         avt_tm   (:,:,:)        = avt_tm  (:,:,:)        + a	         avt_tm   (:,:,:)        = avt_tm  (:,:,:)        + a
# if defined key_zdfddm						# if defined key_zdfddm
         avs_tm   (:,:,:)        = avs_tm  (:,:,:)        + a	         avs_tm   (:,:,:)        = avs_tm  (:,:,:)        + a
# endif								# endif
#if defined key_ldfslp						#if defined key_ldfslp
         wslpi_tm (:,:,:)        = wslpi_tm(:,:,:)        + w	         wslpi_tm (:,:,:)        = wslpi_tm(:,:,:)        + w
         wslpj_tm (:,:,:)        = wslpj_tm(:,:,:)        + w	         wslpj_tm (:,:,:)        = wslpj_tm(:,:,:)        + w
         uslp_tm  (:,:,:)        = uslp_tm (:,:,:)        + u	         uslp_tm  (:,:,:)        = uslp_tm (:,:,:)        + u
         vslp_tm  (:,:,:)        = vslp_tm (:,:,:)        + v	         vslp_tm  (:,:,:)        = vslp_tm (:,:,:)        + v
#endif								#endif
# if defined key_trabbl						# if defined key_trabbl
          IF( nn_bbl_ldf == 1 ) THEN				          IF( nn_bbl_ldf == 1 ) THEN
             ahu_bbl_tm(:,:)     = ahu_bbl_tm(:,:)        + a	             ahu_bbl_tm(:,:)     = ahu_bbl_tm(:,:)        + a
             ahv_bbl_tm(:,:)     = ahv_bbl_tm(:,:)        + a	             ahv_bbl_tm(:,:)     = ahv_bbl_tm(:,:)        + a
          ENDIF							          ENDIF
          IF( nn_bbl_adv == 1 ) THEN				          IF( nn_bbl_adv == 1 ) THEN
             utr_bbl_tm(:,:)     = utr_bbl_tm(:,:)        + u	             utr_bbl_tm(:,:)     = utr_bbl_tm(:,:)        + u
             vtr_bbl_tm(:,:)     = vtr_bbl_tm(:,:)        + v	             vtr_bbl_tm(:,:)     = vtr_bbl_tm(:,:)        + v
          ENDIF							          ENDIF
# endif								# endif
         sshn_tm  (:,:)          = sshn_tm    (:,:)       + s	         sshn_tm  (:,:)          = sshn_tm    (:,:)       + s
         rnf_tm   (:,:)          = rnf_tm     (:,:)       + r	         rnf_tm   (:,:)          = rnf_tm     (:,:)       + r
         h_rnf_tm (:,:)          = h_rnf_tm   (:,:)       + h	         h_rnf_tm (:,:)          = h_rnf_tm   (:,:)       + h
         hmld_tm  (:,:)          = hmld_tm    (:,:)       + h	         hmld_tm  (:,:)          = hmld_tm    (:,:)       + h
         fr_i_tm  (:,:)          = fr_i_tm    (:,:)       + f	         fr_i_tm  (:,:)          = fr_i_tm    (:,:)       + f
         emp_tm   (:,:)          = emp_tm     (:,:)       + e	         emp_tm   (:,:)          = emp_tm     (:,:)       + e
         fmmflx_tm(:,:)          = fmmflx_tm  (:,:)       + f	         fmmflx_tm(:,:)          = fmmflx_tm  (:,:)       + f
         qsr_tm   (:,:)          = qsr_tm     (:,:)       + q	         qsr_tm   (:,:)          = qsr_tm     (:,:)       + q
         wndm_tm  (:,:)          = wndm_tm    (:,:)       + w	         wndm_tm  (:,:)          = wndm_tm    (:,:)       + w
         !							         !
         sshn     (:,:)          = sshn_tm    (:,:) * r1_ndtt	         sshn     (:,:)          = sshn_tm    (:,:) * r1_ndtt
         sshb     (:,:)          = sshb_hold  (:,:)		         sshb     (:,:)          = sshb_hold  (:,:)
         rnf      (:,:)          = rnf_tm     (:,:) * r1_ndtt	         rnf      (:,:)          = rnf_tm     (:,:) * r1_ndtt
         h_rnf    (:,:)          = h_rnf_tm   (:,:) * r1_ndtt	         h_rnf    (:,:)          = h_rnf_tm   (:,:) * r1_ndtt
         hmld     (:,:)          = hmld_tm    (:,:) * r1_ndtt	         hmld     (:,:)          = hmld_tm    (:,:) * r1_ndtt
         !  variables that are initialized after averages	         !  variables that are initialized after averages
         emp_b    (:,:) = emp_b_hold (:,:)			         emp_b    (:,:) = emp_b_hold (:,:)
         IF( kt == nittrc000 ) THEN				         IF( kt == nittrc000 ) THEN
            wndm  (:,:)          = wndm_tm    (:,:) * r1_ndtt	            wndm  (:,:)          = wndm_tm    (:,:) * r1_ndtt
            qsr   (:,:)          = qsr_tm     (:,:) * r1_ndtt	            qsr   (:,:)          = qsr_tm     (:,:) * r1_ndtt
            emp   (:,:)          = emp_tm     (:,:) * r1_ndtt	            emp   (:,:)          = emp_tm     (:,:) * r1_ndtt
            fmmflx(:,:)          = fmmflx_tm  (:,:) * r1_ndtt	            fmmflx(:,:)          = fmmflx_tm  (:,:) * r1_ndtt
            fr_i  (:,:)          = fr_i_tm    (:,:) * r1_ndtt	            fr_i  (:,:)          = fr_i_tm    (:,:) * r1_ndtt
# if defined key_trabbl						# if defined key_trabbl
            IF( nn_bbl_ldf == 1 ) THEN				            IF( nn_bbl_ldf == 1 ) THEN
               ahu_bbl(:,:)      = ahu_bbl_tm (:,:) * r1_ndtt	               ahu_bbl(:,:)      = ahu_bbl_tm (:,:) * r1_ndtt
               ahv_bbl(:,:)      = ahv_bbl_tm (:,:) * r1_ndtt	               ahv_bbl(:,:)      = ahv_bbl_tm (:,:) * r1_ndtt
            ENDIF						            ENDIF
            IF( nn_bbl_adv == 1 ) THEN				            IF( nn_bbl_adv == 1 ) THEN
               utr_bbl(:,:)      = utr_bbl_tm (:,:) * r1_ndtt	               utr_bbl(:,:)      = utr_bbl_tm (:,:) * r1_ndtt
               vtr_bbl(:,:)      = vtr_bbl_tm (:,:) * r1_ndtt	               vtr_bbl(:,:)      = vtr_bbl_tm (:,:) * r1_ndtt
            ENDIF						            ENDIF
# endif								# endif
         ELSE							         ELSE
            wndm  (:,:)          = wndm_tm    (:,:) * r1_ndtt	            wndm  (:,:)          = wndm_tm    (:,:) * r1_ndtt
            qsr   (:,:)          = qsr_tm     (:,:) * r1_ndtt	            qsr   (:,:)          = qsr_tm     (:,:) * r1_ndtt
            emp   (:,:)          = emp_tm     (:,:) * r1_ndtt	            emp   (:,:)          = emp_tm     (:,:) * r1_ndtt
            fmmflx(:,:)          = fmmflx_tm  (:,:) * r1_ndtt	            fmmflx(:,:)          = fmmflx_tm  (:,:) * r1_ndtt
            fr_i  (:,:)          = fr_i_tm    (:,:) * r1_ndtt	            fr_i  (:,:)          = fr_i_tm    (:,:) * r1_ndtt
# if defined key_trabbl						# if defined key_trabbl
            IF( nn_bbl_ldf == 1 ) THEN				            IF( nn_bbl_ldf == 1 ) THEN
               ahu_bbl(:,:)      = ahu_bbl_tm (:,:) * r1_ndtt	               ahu_bbl(:,:)      = ahu_bbl_tm (:,:) * r1_ndtt
               ahv_bbl(:,:)      = ahv_bbl_tm (:,:) * r1_ndtt	               ahv_bbl(:,:)      = ahv_bbl_tm (:,:) * r1_ndtt
            ENDIF						            ENDIF
            IF( nn_bbl_adv == 1 ) THEN				            IF( nn_bbl_adv == 1 ) THEN
               utr_bbl(:,:)      = utr_bbl_tm (:,:) * r1_ndtt	               utr_bbl(:,:)      = utr_bbl_tm (:,:) * r1_ndtt
               vtr_bbl(:,:)      = vtr_bbl_tm (:,:) * r1_ndtt	               vtr_bbl(:,:)      = vtr_bbl_tm (:,:) * r1_ndtt
            ENDIF						            ENDIF
# endif								# endif
         ENDIF							         ENDIF
         !							         !
         DO jk = 1, jpk						         DO jk = 1, jpk
            DO jj = 1, jpj					            DO jj = 1, jpj
               DO ji = 1, jpi					               DO ji = 1, jpi
                  z1_ne3t = r1_ndttrcp1  / fse3t(ji,jj,jk)	                  z1_ne3t = r1_ndttrcp1  / fse3t(ji,jj,jk)
                  z1_ne3u = r1_ndttrcp1  / fse3u(ji,jj,jk)	                  z1_ne3u = r1_ndttrcp1  / fse3u(ji,jj,jk)
                  z1_ne3v = r1_ndttrcp1  / fse3v(ji,jj,jk)	                  z1_ne3v = r1_ndttrcp1  / fse3v(ji,jj,jk)
                  z1_ne3w = r1_ndttrcp1  / fse3w(ji,jj,jk)	                  z1_ne3w = r1_ndttrcp1  / fse3w(ji,jj,jk)
                  !						                  !
                  un   (ji,jj,jk)        = un_tm   (ji,jj,jk)	                  un   (ji,jj,jk)        = un_tm   (ji,jj,jk)
                  vn   (ji,jj,jk)        = vn_tm   (ji,jj,jk)	                  vn   (ji,jj,jk)        = vn_tm   (ji,jj,jk)
                  tsn  (ji,jj,jk,jp_tem) = tsn_tm  (ji,jj,jk,	                  tsn  (ji,jj,jk,jp_tem) = tsn_tm  (ji,jj,jk,
                  tsn  (ji,jj,jk,jp_sal) = tsn_tm  (ji,jj,jk,	                  tsn  (ji,jj,jk,jp_sal) = tsn_tm  (ji,jj,jk,
                  rhop (ji,jj,jk)        = rhop_tm (ji,jj,jk)	                  rhop (ji,jj,jk)        = rhop_tm (ji,jj,jk)
                  avt  (ji,jj,jk)        = avt_tm  (ji,jj,jk)	                  avt  (ji,jj,jk)        = avt_tm  (ji,jj,jk)
# if defined key_zdfddm						# if defined key_zdfddm
                  avs  (ji,jj,jk)        = avs_tm  (ji,jj,jk)	                  avs  (ji,jj,jk)        = avs_tm  (ji,jj,jk)
# endif								# endif
#if defined key_ldfslp						#if defined key_ldfslp
                  wslpi(ji,jj,jk)        = wslpi_tm(ji,jj,jk)	                  wslpi(ji,jj,jk)        = wslpi_tm(ji,jj,jk)
                  wslpj(ji,jj,jk)        = wslpj_tm(ji,jj,jk)	                  wslpj(ji,jj,jk)        = wslpj_tm(ji,jj,jk)
                  uslp (ji,jj,jk)        = uslp_tm (ji,jj,jk)	                  uslp (ji,jj,jk)        = uslp_tm (ji,jj,jk)
                  vslp (ji,jj,jk)        = vslp_tm (ji,jj,jk)	                  vslp (ji,jj,jk)        = vslp_tm (ji,jj,jk)
#endif								#endif
               ENDDO						               ENDDO
            ENDDO						            ENDDO
         ENDDO							         ENDDO
         !							         !
         CALL trc_sub_ssh( kt )         ! after ssh & vertica	         CALL trc_sub_ssh( kt )         ! after ssh & vertica
         !							         !
      ENDIF							      ENDIF
      !								      !
      IF( nn_timing == 1 )  CALL timing_start('trc_sub_stp')	      IF( nn_timing == 1 )  CALL timing_start('trc_sub_stp')
      !								      !
   END SUBROUTINE trc_sub_stp					   END SUBROUTINE trc_sub_stp

   SUBROUTINE trc_sub_ini					   SUBROUTINE trc_sub_ini
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trc_sub_ini  ***	      !!                     ***  ROUTINE trc_sub_ini  ***
      !!                      					      !!                      
      !! ** Purpose : Initialize variables needed for sub-ste	      !! ** Purpose : Initialize variables needed for sub-ste
      !! 							      !! 
      !! ** Method  : 						      !! ** Method  : 
      !!              Compute the averages for sub-stepping	      !!              Compute the averages for sub-stepping
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER ::   ierr						      INTEGER ::   ierr
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      IF( nn_timing == 1 )  CALL timing_start('trc_sub_ini')	      IF( nn_timing == 1 )  CALL timing_start('trc_sub_ini')
      !								      !
      IF(lwp) WRITE(numout,*)					      IF(lwp) WRITE(numout,*)
      IF(lwp) WRITE(numout,*) 'trc_sub_ini : initial set up o	      IF(lwp) WRITE(numout,*) 'trc_sub_ini : initial set up o
      IF(lwp) WRITE(numout,*) '~~~~~~~'				      IF(lwp) WRITE(numout,*) '~~~~~~~'

      ierr =  trc_sub_alloc    ()				      ierr =  trc_sub_alloc    ()
      IF( lk_mpp    )   CALL mpp_sum( ierr )			      IF( lk_mpp    )   CALL mpp_sum( ierr )
      IF( ierr /= 0 )   CALL ctl_stop( 'STOP', 'top_sub_alloc	      IF( ierr /= 0 )   CALL ctl_stop( 'STOP', 'top_sub_alloc

      un_tm   (:,:,:)        = un   (:,:,:)        * fse3u(:,	      un_tm   (:,:,:)        = un   (:,:,:)        * fse3u(:,
      vn_tm   (:,:,:)        = vn   (:,:,:)        * fse3v(:,	      vn_tm   (:,:,:)        = vn   (:,:,:)        * fse3v(:,
      tsn_tm  (:,:,:,jp_tem) = tsn  (:,:,:,jp_tem) * fse3t(:,	      tsn_tm  (:,:,:,jp_tem) = tsn  (:,:,:,jp_tem) * fse3t(:,
      tsn_tm  (:,:,:,jp_sal) = tsn  (:,:,:,jp_sal) * fse3t(:,	      tsn_tm  (:,:,:,jp_sal) = tsn  (:,:,:,jp_sal) * fse3t(:,
      rhop_tm (:,:,:)        = rhop (:,:,:)        * fse3t(:,	      rhop_tm (:,:,:)        = rhop (:,:,:)        * fse3t(:,
      avt_tm  (:,:,:)        = avt  (:,:,:)        * fse3w(:,	      avt_tm  (:,:,:)        = avt  (:,:,:)        * fse3w(:,
# if defined key_zdfddm						# if defined key_zdfddm
      avs_tm  (:,:,:)        = avs  (:,:,:)        * fse3w(:,	      avs_tm  (:,:,:)        = avs  (:,:,:)        * fse3w(:,
# endif								# endif
#if defined key_ldfslp						#if defined key_ldfslp
      wslpi_tm(:,:,:)        = wslpi(:,:,:)			      wslpi_tm(:,:,:)        = wslpi(:,:,:)
      wslpj_tm(:,:,:)        = wslpj(:,:,:)			      wslpj_tm(:,:,:)        = wslpj(:,:,:)
      uslp_tm (:,:,:)        = uslp (:,:,:)			      uslp_tm (:,:,:)        = uslp (:,:,:)
      vslp_tm (:,:,:)        = vslp (:,:,:)			      vslp_tm (:,:,:)        = vslp (:,:,:)
#endif								#endif
      sshn_tm  (:,:) = sshn  (:,:) 				      sshn_tm  (:,:) = sshn  (:,:) 
      rnf_tm   (:,:) = rnf   (:,:) 				      rnf_tm   (:,:) = rnf   (:,:) 
      h_rnf_tm (:,:) = h_rnf (:,:) 				      h_rnf_tm (:,:) = h_rnf (:,:) 
      hmld_tm  (:,:) = hmld  (:,:)				      hmld_tm  (:,:) = hmld  (:,:)

      ! Physics variables that are set after initialization:	      ! Physics variables that are set after initialization:
      fr_i_tm(:,:) = 0._wp					      fr_i_tm(:,:) = 0._wp
      emp_tm (:,:) = 0._wp					      emp_tm (:,:) = 0._wp
      fmmflx_tm(:,:)  = 0._wp					      fmmflx_tm(:,:)  = 0._wp
      qsr_tm (:,:) = 0._wp					      qsr_tm (:,:) = 0._wp
      wndm_tm(:,:) = 0._wp					      wndm_tm(:,:) = 0._wp
# if defined key_trabbl						# if defined key_trabbl
      IF( nn_bbl_ldf == 1 ) THEN				      IF( nn_bbl_ldf == 1 ) THEN
         ahu_bbl_tm(:,:) = 0._wp				         ahu_bbl_tm(:,:) = 0._wp
         ahv_bbl_tm(:,:) = 0._wp				         ahv_bbl_tm(:,:) = 0._wp
      ENDIF							      ENDIF
      IF( nn_bbl_adv == 1 ) THEN				      IF( nn_bbl_adv == 1 ) THEN
         utr_bbl_tm(:,:) = 0._wp				         utr_bbl_tm(:,:) = 0._wp
         vtr_bbl_tm(:,:) = 0._wp				         vtr_bbl_tm(:,:) = 0._wp
      ENDIF							      ENDIF
# endif								# endif
      !								      !
      IF( nn_timing == 1 )  CALL timing_stop('trc_sub_ini')	      IF( nn_timing == 1 )  CALL timing_stop('trc_sub_ini')
      !								      !
   END SUBROUTINE trc_sub_ini					   END SUBROUTINE trc_sub_ini

   SUBROUTINE trc_sub_reset( kt )				   SUBROUTINE trc_sub_reset( kt )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trc_sub_reset  ***	      !!                     ***  ROUTINE trc_sub_reset  ***
      !!                      					      !!                      
      !! ** Purpose : Reset physics variables averaged for su	      !! ** Purpose : Reset physics variables averaged for su
      !! 							      !! 
      !! ** Method  : 						      !! ** Method  : 
      !!              Compute the averages for sub-stepping	      !!              Compute the averages for sub-stepping
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER, INTENT( in ) ::  kt  ! ocean time-step index	      INTEGER, INTENT( in ) ::  kt  ! ocean time-step index
      INTEGER :: jk                 ! dummy loop indices	      INTEGER :: jk                 ! dummy loop indices
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      IF( nn_timing == 1 )  CALL timing_start('trc_sub_reset'	      IF( nn_timing == 1 )  CALL timing_start('trc_sub_reset'
      !								      !
      !   restore physics variables				      !   restore physics variables
      un    (:,:,:)   =  un_temp    (:,:,:)			      un    (:,:,:)   =  un_temp    (:,:,:)
      vn    (:,:,:)   =  vn_temp    (:,:,:)			      vn    (:,:,:)   =  vn_temp    (:,:,:)
      wn    (:,:,:)   =  wn_temp    (:,:,:)			      wn    (:,:,:)   =  wn_temp    (:,:,:)
      tsn   (:,:,:,:) =  tsn_temp   (:,:,:,:)			      tsn   (:,:,:,:) =  tsn_temp   (:,:,:,:)
      rhop  (:,:,:)   =  rhop_temp  (:,:,:)			      rhop  (:,:,:)   =  rhop_temp  (:,:,:)
      avt   (:,:,:)   =  avt_temp   (:,:,:)			      avt   (:,:,:)   =  avt_temp   (:,:,:)
# if defined key_zdfddm						# if defined key_zdfddm
      avs   (:,:,:)   =  avs_temp   (:,:,:)			      avs   (:,:,:)   =  avs_temp   (:,:,:)
# endif								# endif
#if defined key_ldfslp						#if defined key_ldfslp
      wslpi (:,:,:)   =  wslpi_temp (:,:,:)			      wslpi (:,:,:)   =  wslpi_temp (:,:,:)
      wslpj (:,:,:)   =  wslpj_temp (:,:,:)			      wslpj (:,:,:)   =  wslpj_temp (:,:,:)
      uslp  (:,:,:)   =  uslp_temp  (:,:,:)			      uslp  (:,:,:)   =  uslp_temp  (:,:,:)
      vslp  (:,:,:)   =  vslp_temp  (:,:,:)			      vslp  (:,:,:)   =  vslp_temp  (:,:,:)
#endif								#endif
      sshn  (:,:)     =  sshn_temp  (:,:)			      sshn  (:,:)     =  sshn_temp  (:,:)
      sshb  (:,:)     =  sshb_temp  (:,:)			      sshb  (:,:)     =  sshb_temp  (:,:)
      ssha  (:,:)     =  ssha_temp  (:,:)			      ssha  (:,:)     =  ssha_temp  (:,:)
      rnf   (:,:)     =  rnf_temp   (:,:)			      rnf   (:,:)     =  rnf_temp   (:,:)
      h_rnf (:,:)     =  h_rnf_temp (:,:)			      h_rnf (:,:)     =  h_rnf_temp (:,:)
      !								      !
      hmld  (:,:)     =  hmld_temp  (:,:)			      hmld  (:,:)     =  hmld_temp  (:,:)
      fr_i  (:,:)     =  fr_i_temp  (:,:)			      fr_i  (:,:)     =  fr_i_temp  (:,:)
      emp   (:,:)     =  emp_temp   (:,:)			      emp   (:,:)     =  emp_temp   (:,:)
      fmmflx(:,:)     =  fmmflx_temp(:,:)			      fmmflx(:,:)     =  fmmflx_temp(:,:)
      emp_b (:,:)     =  emp_b_temp (:,:)			      emp_b (:,:)     =  emp_b_temp (:,:)
      qsr   (:,:)     =  qsr_temp   (:,:)			      qsr   (:,:)     =  qsr_temp   (:,:)
      wndm  (:,:)     =  wndm_temp  (:,:)			      wndm  (:,:)     =  wndm_temp  (:,:)
# if defined key_trabbl						# if defined key_trabbl
      IF( nn_bbl_ldf == 1 ) THEN				      IF( nn_bbl_ldf == 1 ) THEN
         ahu_bbl(:,:) = ahu_bbl_temp(:,:) 			         ahu_bbl(:,:) = ahu_bbl_temp(:,:) 
         ahv_bbl(:,:) = ahv_bbl_temp(:,:) 			         ahv_bbl(:,:) = ahv_bbl_temp(:,:) 
      ENDIF							      ENDIF
      IF( nn_bbl_adv == 1 ) THEN				      IF( nn_bbl_adv == 1 ) THEN
         utr_bbl(:,:) = utr_bbl_temp(:,:) 			         utr_bbl(:,:) = utr_bbl_temp(:,:) 
         vtr_bbl(:,:) = vtr_bbl_temp(:,:) 			         vtr_bbl(:,:) = vtr_bbl_temp(:,:) 
      ENDIF							      ENDIF
# endif								# endif
      !								      !
      hdivn (:,:,:)   =  hdivn_temp (:,:,:)			      hdivn (:,:,:)   =  hdivn_temp (:,:,:)
      rotn  (:,:,:)   =  rotn_temp  (:,:,:)			      rotn  (:,:,:)   =  rotn_temp  (:,:,:)
      hdivb (:,:,:)   =  hdivb_temp (:,:,:)			      hdivb (:,:,:)   =  hdivb_temp (:,:,:)
      rotb  (:,:,:)   =  rotb_temp  (:,:,:)			      rotb  (:,:,:)   =  rotb_temp  (:,:,:)
      !                                      			      !                                      

      ! Start new averages					      ! Start new averages
         un_tm   (:,:,:)        = un   (:,:,:)        * fse3u	         un_tm   (:,:,:)        = un   (:,:,:)        * fse3u
         vn_tm   (:,:,:)        = vn   (:,:,:)        * fse3v	         vn_tm   (:,:,:)        = vn   (:,:,:)        * fse3v
         tsn_tm  (:,:,:,jp_tem) = tsn  (:,:,:,jp_tem) * fse3t	         tsn_tm  (:,:,:,jp_tem) = tsn  (:,:,:,jp_tem) * fse3t
         tsn_tm  (:,:,:,jp_sal) = tsn  (:,:,:,jp_sal) * fse3t	         tsn_tm  (:,:,:,jp_sal) = tsn  (:,:,:,jp_sal) * fse3t
         rhop_tm (:,:,:)        = rhop (:,:,:)        * fse3t	         rhop_tm (:,:,:)        = rhop (:,:,:)        * fse3t
         avt_tm  (:,:,:)        = avt  (:,:,:)        * fse3w	         avt_tm  (:,:,:)        = avt  (:,:,:)        * fse3w
# if defined key_zdfddm						# if defined key_zdfddm
         avs_tm  (:,:,:)        = avs  (:,:,:)        * fse3w	         avs_tm  (:,:,:)        = avs  (:,:,:)        * fse3w
# endif								# endif
#if defined key_ldfslp						#if defined key_ldfslp
         wslpi_tm(:,:,:)        = wslpi(:,:,:) 			         wslpi_tm(:,:,:)        = wslpi(:,:,:) 
         wslpj_tm(:,:,:)        = wslpj(:,:,:)			         wslpj_tm(:,:,:)        = wslpj(:,:,:)
         uslp_tm (:,:,:)        = uslp (:,:,:)			         uslp_tm (:,:,:)        = uslp (:,:,:)
         vslp_tm (:,:,:)        = vslp (:,:,:)			         vslp_tm (:,:,:)        = vslp (:,:,:)
#endif								#endif
      !								      !
      sshb_hold  (:,:) = sshn  (:,:)				      sshb_hold  (:,:) = sshn  (:,:)
      emp_b_hold (:,:) = emp   (:,:)				      emp_b_hold (:,:) = emp   (:,:)
      sshn_tm    (:,:) = sshn  (:,:) 				      sshn_tm    (:,:) = sshn  (:,:) 
      rnf_tm     (:,:) = rnf   (:,:) 				      rnf_tm     (:,:) = rnf   (:,:) 
      h_rnf_tm   (:,:) = h_rnf (:,:) 				      h_rnf_tm   (:,:) = h_rnf (:,:) 
      hmld_tm    (:,:) = hmld  (:,:)				      hmld_tm    (:,:) = hmld  (:,:)
      fr_i_tm    (:,:) = fr_i  (:,:)				      fr_i_tm    (:,:) = fr_i  (:,:)
      emp_tm     (:,:) = emp   (:,:)				      emp_tm     (:,:) = emp   (:,:)
      fmmflx_tm  (:,:) = fmmflx(:,:)				      fmmflx_tm  (:,:) = fmmflx(:,:)
      qsr_tm     (:,:) = qsr   (:,:)				      qsr_tm     (:,:) = qsr   (:,:)
      wndm_tm    (:,:) = wndm  (:,:)				      wndm_tm    (:,:) = wndm  (:,:)
# if defined key_trabbl						# if defined key_trabbl
      IF( nn_bbl_ldf == 1 ) THEN				      IF( nn_bbl_ldf == 1 ) THEN
         ahu_bbl_tm(:,:) = ahu_bbl(:,:) 			         ahu_bbl_tm(:,:) = ahu_bbl(:,:) 
         ahv_bbl_tm(:,:) = ahv_bbl(:,:) 			         ahv_bbl_tm(:,:) = ahv_bbl(:,:) 
      ENDIF							      ENDIF
      IF( nn_bbl_adv == 1 ) THEN				      IF( nn_bbl_adv == 1 ) THEN
         utr_bbl_tm(:,:) = utr_bbl(:,:) 			         utr_bbl_tm(:,:) = utr_bbl(:,:) 
         vtr_bbl_tm(:,:) = vtr_bbl(:,:) 			         vtr_bbl_tm(:,:) = vtr_bbl(:,:) 
      ENDIF							      ENDIF
# endif								# endif
      !								      !
      !								      !
      IF( nn_timing == 1 )  CALL timing_stop('trc_sub_reset')	      IF( nn_timing == 1 )  CALL timing_stop('trc_sub_reset')
      !								      !
   END SUBROUTINE trc_sub_reset					   END SUBROUTINE trc_sub_reset


   SUBROUTINE trc_sub_ssh( kt ) 				   SUBROUTINE trc_sub_ssh( kt ) 
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                ***  ROUTINE trc_sub_ssh  ***		      !!                ***  ROUTINE trc_sub_ssh  ***
      !!                   					      !!                   
      !! ** Purpose :   compute the after ssh (ssha), the now	      !! ** Purpose :   compute the after ssh (ssha), the now
      !!              and update the now vertical coordinate 	      !!              and update the now vertical coordinate 
      !!							      !!
      !! ** Method  : - Using the incompressibility hypothesi	      !! ** Method  : - Using the incompressibility hypothesi
      !!      velocity is computed by integrating the horizon	      !!      velocity is computed by integrating the horizon
      !!      from the bottom to the surface minus the scale 	      !!      from the bottom to the surface minus the scale 
      !!        The boundary conditions are w=0 at the bottom	      !!        The boundary conditions are w=0 at the bottom
      !!							      !!
      !! ** action  :   ssha    : after sea surface height	      !! ** action  :   ssha    : after sea surface height
      !!                wn      : now vertical velocity		      !!                wn      : now vertical velocity
      !!                sshu_a, sshv_a, sshf_a  : after sea s	      !!                sshu_a, sshv_a, sshf_a  : after sea s
      !!							      !!
      !! Reference  : Leclair, M., and G. Madec, 2009, Ocean 	      !! Reference  : Leclair, M., and G. Madec, 2009, Ocean 
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      INTEGER, INTENT(in) ::   kt   ! time step			      INTEGER, INTENT(in) ::   kt   ! time step
      !								      !
      INTEGER  ::   ji, jj, jk   ! dummy loop indices		      INTEGER  ::   ji, jj, jk   ! dummy loop indices
      REAL(wp) ::   zcoefu, zcoefv, zcoeff, z2dt, z1_2dt, z1_	      REAL(wp) ::   zcoefu, zcoefv, zcoeff, z2dt, z1_2dt, z1_
      REAL(wp), POINTER, DIMENSION(:,:) :: zhdiv		      REAL(wp), POINTER, DIMENSION(:,:) :: zhdiv
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      IF( nn_timing == 1 )  CALL timing_start('trc_sub_ssh')	      IF( nn_timing == 1 )  CALL timing_start('trc_sub_ssh')
      !								      !
      ! Allocate temporary workspace				      ! Allocate temporary workspace
      CALL wrk_alloc( jpi, jpj, zhdiv )				      CALL wrk_alloc( jpi, jpj, zhdiv )

      IF( kt == nittrc000 ) THEN				      IF( kt == nittrc000 ) THEN
         !							         !
         IF(lwp) WRITE(numout,*)				         IF(lwp) WRITE(numout,*)
         IF(lwp) WRITE(numout,*) 'trc_sub_ssh : after sea sur	         IF(lwp) WRITE(numout,*) 'trc_sub_ssh : after sea sur
         IF(lwp) WRITE(numout,*) '~~~~~~~~~~~ '			         IF(lwp) WRITE(numout,*) '~~~~~~~~~~~ '
         !							         !
         wn(:,:,jpk) = 0._wp                  ! bottom bounda	         wn(:,:,jpk) = 0._wp                  ! bottom bounda
         !							         !
      ENDIF							      ENDIF
      !								      !
      CALL div_cur( kt )                              ! Horiz	      CALL div_cur( kt )                              ! Horiz
      !								      !
      z2dt = 2._wp * rdt                              ! set t	      z2dt = 2._wp * rdt                              ! set t
      IF( neuler == 0 .AND. kt == nittrc000 )   z2dt = rdt	      IF( neuler == 0 .AND. kt == nittrc000 )   z2dt = rdt

      !                                           !----------	      !                                           !----------
      !                                           !   After S	      !                                           !   After S
      !                                           !----------	      !                                           !----------
      zhdiv(:,:) = 0._wp					      zhdiv(:,:) = 0._wp
      DO jk = 1, jpkm1                                 ! Hori	      DO jk = 1, jpkm1                                 ! Hori
        zhdiv(:,:) = zhdiv(:,:) + fse3t(:,:,jk) * hdivn(:,:,j	        zhdiv(:,:) = zhdiv(:,:) + fse3t(:,:,jk) * hdivn(:,:,j
      END DO							      END DO
      !                                                ! Sea 	      !                                                ! Sea 
      ! In forward Euler time stepping case, the same formula	      ! In forward Euler time stepping case, the same formula
      ! because emp_b field is initialized with the vlaues of	      ! because emp_b field is initialized with the vlaues of
      z1_rau0 = 0.5 / rau0					      z1_rau0 = 0.5 / rau0
      ssha(:,:) = (  sshb(:,:) - z2dt * ( z1_rau0 * ( emp_b(:	      ssha(:,:) = (  sshb(:,:) - z2dt * ( z1_rau0 * ( emp_b(:
#if ! defined key_dynspg_ts					#if ! defined key_dynspg_ts
      ! These lines are not necessary with time splitting sin	      ! These lines are not necessary with time splitting sin
      ! boundary condition on sea level is set during ts loop	      ! boundary condition on sea level is set during ts loop
#if defined key_agrif						#if defined key_agrif
      CALL agrif_ssh( kt )					      CALL agrif_ssh( kt )
#endif								#endif
#if defined key_bdy						#if defined key_bdy
      ssha(:,:) = ssha(:,:) * bdytmask(:,:)			      ssha(:,:) = ssha(:,:) * bdytmask(:,:)
      CALL lbc_lnk( ssha, 'T', 1. ) 				      CALL lbc_lnk( ssha, 'T', 1. ) 
#endif								#endif
#endif								#endif


      !                                           !----------	      !                                           !----------
      !                                           !     Now V	      !                                           !     Now V
      !                                           !----------	      !                                           !----------
      z1_2dt = 1.e0 / z2dt					      z1_2dt = 1.e0 / z2dt
      DO jk = jpkm1, 1, -1                             ! inte	      DO jk = jpkm1, 1, -1                             ! inte
         ! - ML - need 3 lines here because replacement of fs	         ! - ML - need 3 lines here because replacement of fs
         wn(:,:,jk) = wn(:,:,jk+1) -   fse3t_n(:,:,jk) * hdiv	         wn(:,:,jk) = wn(:,:,jk+1) -   fse3t_n(:,:,jk) * hdiv
            &                      - ( fse3t_a(:,:,jk) - fse3	            &                      - ( fse3t_a(:,:,jk) - fse3
            &                         * tmask(:,:,jk) * z1_2d	            &                         * tmask(:,:,jk) * z1_2d
#if defined key_bdy						#if defined key_bdy
         wn(:,:,jk) = wn(:,:,jk) * bdytmask(:,:)		         wn(:,:,jk) = wn(:,:,jk) * bdytmask(:,:)
#endif								#endif
      END DO							      END DO

      !								      !
      CALL wrk_dealloc( jpi, jpj, zhdiv )			      CALL wrk_dealloc( jpi, jpj, zhdiv )
      !								      !
      IF( nn_timing == 1 )  CALL timing_stop('trc_sub_ssh')	      IF( nn_timing == 1 )  CALL timing_stop('trc_sub_ssh')
      !								      !
   END SUBROUTINE trc_sub_ssh					   END SUBROUTINE trc_sub_ssh

   INTEGER FUNCTION trc_sub_alloc()				   INTEGER FUNCTION trc_sub_alloc()
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                    *** ROUTINE trc_sub_alloc ***	      !!                    *** ROUTINE trc_sub_alloc ***
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      USE lib_mpp, ONLY: ctl_warn				      USE lib_mpp, ONLY: ctl_warn
      INTEGER ::  ierr						      INTEGER ::  ierr
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      ALLOCATE( un_temp(jpi,jpj,jpk)        ,  vn_temp(jpi,jp	      ALLOCATE( un_temp(jpi,jpj,jpk)        ,  vn_temp(jpi,jp
         &      wn_temp(jpi,jpj,jpk)        ,  avt_temp(jpi,j	         &      wn_temp(jpi,jpj,jpk)        ,  avt_temp(jpi,j
         &      rhop_temp(jpi,jpj,jpk)      ,  rhop_tm(jpi,jp	         &      rhop_temp(jpi,jpj,jpk)      ,  rhop_tm(jpi,jp
         &      sshn_temp(jpi,jpj)          ,  sshb_temp(jpi,	         &      sshn_temp(jpi,jpj)          ,  sshb_temp(jpi,
         &      ssha_temp(jpi,jpj)          ,                	         &      ssha_temp(jpi,jpj)          ,                
#if defined key_ldfslp						#if defined key_ldfslp
         &      wslpi_temp(jpi,jpj,jpk)     ,  wslpj_temp(jpi	         &      wslpi_temp(jpi,jpj,jpk)     ,  wslpj_temp(jpi
         &      uslp_temp(jpi,jpj,jpk)      ,  vslp_temp(jpi,	         &      uslp_temp(jpi,jpj,jpk)      ,  vslp_temp(jpi,
#endif								#endif
#if defined key_trabbl						#if defined key_trabbl
         &      ahu_bbl_temp(jpi,jpj)       ,  ahv_bbl_temp(j	         &      ahu_bbl_temp(jpi,jpj)       ,  ahv_bbl_temp(j
         &      utr_bbl_temp(jpi,jpj)       ,  vtr_bbl_temp(j	         &      utr_bbl_temp(jpi,jpj)       ,  vtr_bbl_temp(j
#endif								#endif
         &      rnf_temp(jpi,jpj)           ,  h_rnf_temp(jpi	         &      rnf_temp(jpi,jpj)           ,  h_rnf_temp(jpi
         &      tsn_temp(jpi,jpj,jpk,2)     ,  emp_b_temp(jpi	         &      tsn_temp(jpi,jpj,jpk,2)     ,  emp_b_temp(jpi
         &      emp_temp(jpi,jpj)           ,  fmmflx_temp(jp	         &      emp_temp(jpi,jpj)           ,  fmmflx_temp(jp
         &      hmld_temp(jpi,jpj)          ,  qsr_temp(jpi,j	         &      hmld_temp(jpi,jpj)          ,  qsr_temp(jpi,j
         &      fr_i_temp(jpi,jpj)          ,  fr_i_tm(jpi,jp	         &      fr_i_temp(jpi,jpj)          ,  fr_i_tm(jpi,jp
         &      wndm_temp(jpi,jpj)          ,  wndm_tm(jpi,jp	         &      wndm_temp(jpi,jpj)          ,  wndm_tm(jpi,jp
# if defined key_zdfddm						# if defined key_zdfddm
         &      avs_tm(jpi,jpj,jpk)         ,  avs_temp(jpi,j	         &      avs_tm(jpi,jpj,jpk)         ,  avs_temp(jpi,j
# endif								# endif
         &      hdivn_temp(jpi,jpj,jpk)     ,  hdivb_temp(jpi	         &      hdivn_temp(jpi,jpj,jpk)     ,  hdivb_temp(jpi
         &      rotn_temp(jpi,jpj,jpk)      ,  rotb_temp(jpi,	         &      rotn_temp(jpi,jpj,jpk)      ,  rotb_temp(jpi,
         &      un_tm(jpi,jpj,jpk)          ,  vn_tm(jpi,jpj,	         &      un_tm(jpi,jpj,jpk)          ,  vn_tm(jpi,jpj,
         &      avt_tm(jpi,jpj,jpk)                          	         &      avt_tm(jpi,jpj,jpk)                          
         &      sshn_tm(jpi,jpj)            ,  sshb_hold(jpi,	         &      sshn_tm(jpi,jpj)            ,  sshb_hold(jpi,
         &      tsn_tm(jpi,jpj,jpk,2)       ,                	         &      tsn_tm(jpi,jpj,jpk,2)       ,                
         &      emp_tm(jpi,jpj)             ,  fmmflx_tm(jpi,	         &      emp_tm(jpi,jpj)             ,  fmmflx_tm(jpi,
         &      emp_b_hold(jpi,jpj)         ,                	         &      emp_b_hold(jpi,jpj)         ,                
         &      hmld_tm(jpi,jpj)            ,  qsr_tm(jpi,jpj	         &      hmld_tm(jpi,jpj)            ,  qsr_tm(jpi,jpj
#if defined key_ldfslp						#if defined key_ldfslp
         &      wslpi_tm(jpi,jpj,jpk)       ,  wslpj_tm(jpi,j	         &      wslpi_tm(jpi,jpj,jpk)       ,  wslpj_tm(jpi,j
         &      uslp_tm(jpi,jpj,jpk)        ,  vslp_tm(jpi,jp	         &      uslp_tm(jpi,jpj,jpk)        ,  vslp_tm(jpi,jp
#endif								#endif
#if defined key_trabbl						#if defined key_trabbl
         &      ahu_bbl_tm(jpi,jpj)         ,  ahv_bbl_tm(jpi	         &      ahu_bbl_tm(jpi,jpj)         ,  ahv_bbl_tm(jpi
         &      utr_bbl_tm(jpi,jpj)         ,  vtr_bbl_tm(jpi	         &      utr_bbl_tm(jpi,jpj)         ,  vtr_bbl_tm(jpi
#endif								#endif
         &      rnf_tm(jpi,jpj)             ,  h_rnf_tm(jpi,j	         &      rnf_tm(jpi,jpj)             ,  h_rnf_tm(jpi,j
         &                                    STAT=trc_sub_al	         &                                    STAT=trc_sub_al
      IF( trc_sub_alloc /= 0 )   CALL ctl_warn('trc_sub_alloc	      IF( trc_sub_alloc /= 0 )   CALL ctl_warn('trc_sub_alloc

      !								      !
   END FUNCTION trc_sub_alloc					   END FUNCTION trc_sub_alloc

#else								#else
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   Default key                                     NO pa	   !!   Default key                                     NO pa
   !!--------------------------------------------------------	   !!--------------------------------------------------------
CONTAINS							CONTAINS
   SUBROUTINE trc_sub_stp( kt )        ! Empty routine		   SUBROUTINE trc_sub_stp( kt )        ! Empty routine
      WRITE(*,*) 'trc_sub_stp: You should not have seen this 	      WRITE(*,*) 'trc_sub_stp: You should not have seen this 
   END SUBROUTINE trc_sub_stp					   END SUBROUTINE trc_sub_stp
   SUBROUTINE trc_sub_ini        ! Empty routine		   SUBROUTINE trc_sub_ini        ! Empty routine
      WRITE(*,*) 'trc_sub_ini: You should not have seen this 	      WRITE(*,*) 'trc_sub_ini: You should not have seen this 
   END SUBROUTINE trc_sub_ini					   END SUBROUTINE trc_sub_ini

#endif								#endif

   !!========================================================	   !!========================================================
END MODULE trcsub						END MODULE trcsub
diff -Bby /home/amh001/work/LATESTNEMO/NEMOGCM/NEMO/TOP_SRC/trcwri.F90 /home/amh001/NEMO36/NEMOGCM/NEMO/TOP_SRC/trcwri.F90
MODULE trcwri							MODULE trcwri
   !!========================================================	   !!========================================================
   !!                       *** MODULE trcwri ***		   !!                       *** MODULE trcwri ***
   !!    TOP :   Output of passive tracers			   !!    TOP :   Output of passive tracers
   !!========================================================	   !!========================================================
   !! History :   1.0  !  2009-05 (C. Ethe)  Original code	   !! History :   1.0  !  2009-05 (C. Ethe)  Original code
   !!--------------------------------------------------------	   !!--------------------------------------------------------
#if defined key_top && defined key_iomput			#if defined key_top && defined key_iomput
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!   'key_top'                                           T	   !!   'key_top'                                           T
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! trc_wri_trc   :  outputs of concentration fields		   !! trc_wri_trc   :  outputs of concentration fields
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   USE dom_oce     ! ocean space and time domain variables	   USE dom_oce     ! ocean space and time domain variables
   USE oce_trc     ! shared variables between ocean and passi	   USE oce_trc     ! shared variables between ocean and passi
   USE trc         ! passive tracers common variables 		   USE trc         ! passive tracers common variables 
   USE iom         ! I/O manager				   USE iom         ! I/O manager
   USE dianam      ! Output file name				   USE dianam      ! Output file name
   USE trcwri_pisces						   USE trcwri_pisces
							      >	   USE trcwri_canoe
							      >	   USE trcwri_cmoc
   USE trcwri_cfc						   USE trcwri_cfc
   USE trcwri_c14b						   USE trcwri_c14b
   USE trcwri_age					      <
   USE trcwri_my_trc						   USE trcwri_my_trc

   IMPLICIT NONE						   IMPLICIT NONE
   PRIVATE							   PRIVATE

   PUBLIC trc_wri      						   PUBLIC trc_wri      

   !! * Substitutions						   !! * Substitutions
#  include "top_substitute.h90"					#  include "top_substitute.h90"

CONTAINS							CONTAINS

   SUBROUTINE trc_wri( kt )					   SUBROUTINE trc_wri( kt )
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !!                     ***  ROUTINE trc_wri  ***		      !!                     ***  ROUTINE trc_wri  ***
      !! 							      !! 
      !! ** Purpose :   output passive tracers fields and dyn	      !! ** Purpose :   output passive tracers fields and dyn
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      INTEGER, INTENT( in )     :: kt				      INTEGER, INTENT( in )     :: kt
      !								      !
      INTEGER                   :: jn				      INTEGER                   :: jn
      CHARACTER (len=20)        :: cltra			      CHARACTER (len=20)        :: cltra
      CHARACTER (len=40)        :: clhstnam			      CHARACTER (len=40)        :: clhstnam
      INTEGER ::   inum = 11            ! temporary logical u	      INTEGER ::   inum = 11            ! temporary logical u
      !!-----------------------------------------------------	      !!-----------------------------------------------------
      !								      !
      IF( nn_timing == 1 )  CALL timing_start('trc_wri')	      IF( nn_timing == 1 )  CALL timing_start('trc_wri')
      !								      !
      IF( lk_offline .AND. kt == nittrc000 .AND. lwp ) THEN  	      IF( lk_offline .AND. kt == nittrc000 .AND. lwp ) THEN  
         CALL dia_nam( clhstnam, nn_writetrc,' ' )		         CALL dia_nam( clhstnam, nn_writetrc,' ' )
         CALL ctl_opn( inum, 'date.file', 'REPLACE', 'FORMATT	         CALL ctl_opn( inum, 'date.file', 'REPLACE', 'FORMATT
         WRITE(inum,*) clhstnam					         WRITE(inum,*) clhstnam
         CLOSE(inum)						         CLOSE(inum)
      ENDIF							      ENDIF
      ! write the tracer concentrations in the file		      ! write the tracer concentrations in the file
      ! ---------------------------------------			      ! ---------------------------------------
      IF( lk_pisces  )   CALL trc_wri_pisces     ! PISCES 	      IF( lk_pisces  )   CALL trc_wri_pisces     ! PISCES 
      IF( lk_my_trc  )   CALL trc_wri_my_trc     ! MY_TRC  tr |	      IF( lk_canoe  )   CALL trc_wri_canoe     ! PISCES 
							      >	      IF( lk_cmoc  )   CALL trc_wri_cmoc     ! CMOC 
      IF( lk_cfc     )   CALL trc_wri_cfc        ! surface fl	      IF( lk_cfc     )   CALL trc_wri_cfc        ! surface fl
      IF( lk_c14b    )   CALL trc_wri_c14b       ! surface fl	      IF( lk_c14b    )   CALL trc_wri_c14b       ! surface fl
      IF( lk_age     )   CALL trc_wri_age        ! AGE tracer |	      IF( lk_my_trc  )   CALL trc_wri_my_trc     ! MY_TRC  tr
      !								      !
      IF( nn_timing == 1 )  CALL timing_stop('trc_wri')		      IF( nn_timing == 1 )  CALL timing_stop('trc_wri')
      !								      !
   END SUBROUTINE trc_wri					   END SUBROUTINE trc_wri

#else								#else
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !!  Dummy module :                                     No 	   !!  Dummy module :                                     No 
   !!--------------------------------------------------------	   !!--------------------------------------------------------
   PUBLIC trc_wri						   PUBLIC trc_wri
CONTAINS							CONTAINS
   SUBROUTINE trc_wri( kt )                     ! Empty routi	   SUBROUTINE trc_wri( kt )                     ! Empty routi
   INTEGER, INTENT(in) :: kt					   INTEGER, INTENT(in) :: kt
   END SUBROUTINE trc_wri					   END SUBROUTINE trc_wri
#endif								#endif

   !!--------------------------------------------------------	   !!--------------------------------------------------------
   !! NEMO/TOP 3.3 , NEMO Consortium (2010)			   !! NEMO/TOP 3.3 , NEMO Consortium (2010)
   !! $Id: trcwri.F90 8353 2017-07-19 14:41:00Z lovato $      |	   !! $Id: trcwri.F90 3750 2013-01-14 16:25:10Z cetlod $ 
   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C	   !! Software governed by the CeCILL licence (NEMOGCM/NEMO_C
   !!========================================================	   !!========================================================
END MODULE trcwri						END MODULE trcwri
